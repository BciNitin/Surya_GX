//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }

    /**
     * @param isForgotPswd (optional) 
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(isForgotPswd: boolean | undefined, body: ForgotPasswordDto | undefined): Observable<ForgotPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ForgotPassword?";
        if (isForgotPswd === null)
            throw new Error("The parameter 'isForgotPswd' cannot be null.");
        else if (isForgotPswd !== undefined)
            url_ += "isForgotPswd=" + encodeURIComponent("" + isForgotPswd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForgotPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForgotPasswordOutput>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ForgotPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForgotPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForgotPasswordOutput>(null as any);
    }
}

@Injectable()
export class ApprovalLevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalLevelDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(null as any);
    }

    /**
     * @param levelCode (optional) 
     * @param levelName (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(levelCode: number | undefined, levelName: string | null | undefined, activeInactiveStatusId: number | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ApprovalLevelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/GetAll?";
        if (levelCode === null)
            throw new Error("The parameter 'levelCode' cannot be null.");
        else if (levelCode !== undefined)
            url_ += "LevelCode=" + encodeURIComponent("" + levelCode) + "&";
        if (levelName !== undefined && levelName !== null)
            url_ += "LevelName=" + encodeURIComponent("" + levelName) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalLevelListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalLevelListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalLevelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalLevelDto | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalLevelDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(null as any);
    }

    /**
     * @param levelName (optional) 
     * @return Success
     */
    isLevelPresent(levelName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/IsLevelPresent?";
        if (levelName !== undefined && levelName !== null)
            url_ += "LevelName=" + encodeURIComponent("" + levelName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsLevelPresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsLevelPresent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsLevelPresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ApprovalLevelDto | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalLevelDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getList(): Observable<ApprovalLevelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalLevelListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalLevelListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ApprovalLevelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelListDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ApprovalUserModuleMappingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getActivitySubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetActivitySubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivitySubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivitySubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetActivitySubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalUserModuleMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalUserModuleMappingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(null as any);
    }

    /**
     * @param appLevelId (optional) 
     * @param userId (optional) 
     * @param moduleId (optional) 
     * @param subModuleId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(appLevelId: number | null | undefined, userId: number | null | undefined, moduleId: number | null | undefined, subModuleId: number | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ApprovalUserModuleMappingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetAll?";
        if (appLevelId !== undefined && appLevelId !== null)
            url_ += "AppLevelId=" + encodeURIComponent("" + appLevelId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (subModuleId !== undefined && subModuleId !== null)
            url_ += "SubModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalUserModuleMappingListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalUserModuleMappingListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalUserModuleMappingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalUserModuleMappingDto | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalUserModuleMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalUserModuleMappingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ApprovalUserModuleMappingDto | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalUserModuleMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalUserModuleMappingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AtesttableMasterServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AtesttableMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/AtesttableMasterService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AtesttableMasterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AtesttableMasterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AtesttableMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtesttableMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AtesttableMasterDto>(null as any);
    }
}

@Injectable()
export class ChangePswdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<ChangePasswordDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangePasswordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangePasswordDto>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ChangePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordForSuperAdmin(body: ChangePasswordSuperAdminDto | undefined): Observable<ChangePasswordSuperAdminOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/ChangePasswordForSuperAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePasswordForSuperAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePasswordForSuperAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangePasswordSuperAdminOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangePasswordSuperAdminOutputDto>;
        }));
    }

    protected processChangePasswordForSuperAdmin(response: HttpResponseBase): Observable<ChangePasswordSuperAdminOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordSuperAdminOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordSuperAdminOutputDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPasswordManager(body: WMSPasswordManagerDto | undefined): Observable<WMSPasswordManagerDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/CreatePasswordManager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePasswordManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePasswordManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WMSPasswordManagerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WMSPasswordManagerDto>;
        }));
    }

    protected processCreatePasswordManager(response: HttpResponseBase): Observable<WMSPasswordManagerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WMSPasswordManagerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WMSPasswordManagerDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPasswordManager(input: string | null | undefined): Observable<WMSPasswordManagerDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/GetPasswordManager?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WMSPasswordManagerDetailsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WMSPasswordManagerDetailsDto[]>;
        }));
    }

    protected processGetPasswordManager(response: HttpResponseBase): Observable<WMSPasswordManagerDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WMSPasswordManagerDetailsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WMSPasswordManagerDetailsDto[]>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    encryptPassword(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/EncryptPassword?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEncryptPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEncryptPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processEncryptPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    decryptPassword(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/DecryptPassword?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecryptPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecryptPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDecryptPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param currentUser (optional) 
     * @param keyword (optional) 
     * @param username (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(currentUser: number | undefined, keyword: string | null | undefined, username: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestedUsersListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/GetAll?";
        if (currentUser === null)
            throw new Error("The parameter 'currentUser' cannot be null.");
        else if (currentUser !== undefined)
            url_ += "CurrentUser=" + encodeURIComponent("" + currentUser) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (username !== undefined && username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestedUsersListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestedUsersListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RequestedUsersListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestedUsersListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestedUsersListDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ClientFormsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ClientFormsDto | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientFormsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientFormsDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ClientFormsDto | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientFormsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientFormsDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientFormsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientFormsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param clientId (optional) 
     * @param formName (optional) 
     * @param isActive (optional) 
     * @param formStatus (optional) 
     * @param approveDateTime (optional) 
     * @param permissions (optional) 
     * @param menuId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, clientId: number | null | undefined, formName: string | null | undefined, isActive: boolean | null | undefined, formStatus: number | null | undefined, approveDateTime: moment.Moment | null | undefined, permissions: string | null | undefined, menuId: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientFormsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (formName !== undefined && formName !== null)
            url_ += "FormName=" + encodeURIComponent("" + formName) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (formStatus !== undefined && formStatus !== null)
            url_ += "FormStatus=" + encodeURIComponent("" + formStatus) + "&";
        if (approveDateTime !== undefined && approveDateTime !== null)
            url_ += "ApproveDateTime=" + encodeURIComponent(approveDateTime ? "" + approveDateTime.toISOString() : "") + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (menuId !== undefined && menuId !== null)
            url_ += "MenuId=" + encodeURIComponent("" + menuId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientFormsDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientFormsDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClientFormsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMenu(): Observable<Menu[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAllMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Menu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Menu[]>;
        }));
    }

    protected processGetAllMenu(response: HttpResponseBase): Observable<Menu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Menu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Menu[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllRolePermission(): Observable<Menu[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAllRolePermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRolePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Menu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Menu[]>;
        }));
    }

    protected processGetAllRolePermission(response: HttpResponseBase): Observable<Menu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Menu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Menu[]>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ElogApiServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    all_showAllTables(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/All_showAllTables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll_showAllTables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll_showAllTables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAll_showAllTables(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @param columnName (optional) 
     * @param values (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    formDataPush(tableName: string | null | undefined, columnName: string | null | undefined, values: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/FormDataPush?";
        if (tableName !== undefined && tableName !== null)
            url_ += "TableName=" + encodeURIComponent("" + tableName) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (values !== undefined && values !== null)
            url_ += "Values=" + encodeURIComponent("" + values) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormDataPush(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormDataPush(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFormDataPush(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param value (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    updateLogWiseData(id: number | undefined, tablename: string | null | undefined, columnName: string | null | undefined, value: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/UpdateLogWiseData?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (value !== undefined && value !== null)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLogWiseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLogWiseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLogWiseData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @param pagenumber (optional) 
     * @param pagesize (optional) 
     * @return Success
     */
    getcreateForms(tablename: string | null | undefined, pagenumber: number | undefined, pagesize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetcreateForms?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (pagenumber === null)
            throw new Error("The parameter 'pagenumber' cannot be null.");
        else if (pagenumber !== undefined)
            url_ += "pagenumber=" + encodeURIComponent("" + pagenumber) + "&";
        if (pagesize === null)
            throw new Error("The parameter 'pagesize' cannot be null.");
        else if (pagesize !== undefined)
            url_ += "pagesize=" + encodeURIComponent("" + pagesize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcreateForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcreateForms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetcreateForms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @return Success
     */
    showTableColumns(tablename: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/showTableColumns?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowTableColumns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowTableColumns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processShowTableColumns(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @return Success
     */
    setFetch(tablename: string | null | undefined): Observable<SetfetchNewDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/setFetch?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFetch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetfetchNewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetfetchNewDto>;
        }));
    }

    protected processSetFetch(response: HttpResponseBase): Observable<SetfetchNewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetfetchNewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetfetchNewDto>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @return Success
     */
    setoldFetch(tablename: string | null | undefined): Observable<SetfetchDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/setoldFetch?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetoldFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetoldFetch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetfetchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetfetchDto>;
        }));
    }

    protected processSetoldFetch(response: HttpResponseBase): Observable<SetfetchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetfetchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetfetchDto>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    getspTableStructureToBeCreate(tablename: string | null | undefined, columnName: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetspTableStructureToBeCreate?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetspTableStructureToBeCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetspTableStructureToBeCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetspTableStructureToBeCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param limit (optional) 
     * @param condition (optional) 
     * @param conditionText (optional) 
     * @return Success
     */
    fetchTableWiseData(tablename: string | null | undefined, columnName: string | null | undefined, limit: number | undefined, condition: string | null | undefined, conditionText: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/FetchTableWiseData?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (condition !== undefined && condition !== null)
            url_ += "Condition=" + encodeURIComponent("" + condition) + "&";
        if (conditionText !== undefined && conditionText !== null)
            url_ += "ConditionText=" + encodeURIComponent("" + conditionText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTableWiseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTableWiseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFetchTableWiseData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param limit (optional) 
     * @return Success
     */
    getDistictColumnWiseData(tablename: string | null | undefined, columnName: string | null | undefined, limit: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetDistictColumnWiseData?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistictColumnWiseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistictColumnWiseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetDistictColumnWiseData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param conditionText (optional) 
     * @return Success
     */
    getCheckpointReportWise(conditionText: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetCheckpointReportWise?";
        if (conditionText !== undefined && conditionText !== null)
            url_ += "ConditionText=" + encodeURIComponent("" + conditionText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointReportWise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointReportWise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCheckpointReportWise(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClientForm(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetClientForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetClientForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ElogControlsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ElogControlsDto | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElogControlsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElogControlsDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ElogControlsDto | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElogControlsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElogControlsDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElogControlsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElogControlsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param eLogId (optional) 
     * @param controlLabel (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, eLogId: number | null | undefined, controlLabel: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ElogControlsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (eLogId !== undefined && eLogId !== null)
            url_ += "ELogId=" + encodeURIComponent("" + eLogId) + "&";
        if (controlLabel !== undefined && controlLabel !== null)
            url_ += "ControlLabel=" + encodeURIComponent("" + controlLabel) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElogControlsDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElogControlsDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ElogControlsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ElogSuryaApiServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPlantMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetPlantMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPlantMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getMaterialMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetMaterialMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetMaterialMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCustomerMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetCustomerMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetCustomerMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getLineMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetLineMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetLineMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getLineNumber(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetLineNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetLineNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getStorageLocationMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetStorageLocationMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocationMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocationMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetStorageLocationMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBinMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetBinMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBinMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBinMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetBinMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBinById(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetBinById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBinById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBinById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetBinById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBin(body: Bin | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/UpdateBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBinCode(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetBinCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBinCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBinCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetBinCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getSiftMaster(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetSiftMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiftMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiftMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetSiftMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param shiftCode (optional) 
     * @param shiftDescription (optional) 
     * @param sShiftStartTime (optional) 
     * @param sShiftEndTime (optional) 
     * @return Success
     */
    updateSiftMaster(shiftCode: string | null | undefined, shiftDescription: string | null | undefined, sShiftStartTime: moment.Moment | undefined, sShiftEndTime: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/UpdateSiftMaster?";
        if (shiftCode !== undefined && shiftCode !== null)
            url_ += "ShiftCode=" + encodeURIComponent("" + shiftCode) + "&";
        if (shiftDescription !== undefined && shiftDescription !== null)
            url_ += "ShiftDescription=" + encodeURIComponent("" + shiftDescription) + "&";
        if (sShiftStartTime === null)
            throw new Error("The parameter 'sShiftStartTime' cannot be null.");
        else if (sShiftStartTime !== undefined)
            url_ += "sShiftStartTime=" + encodeURIComponent(sShiftStartTime ? "" + sShiftStartTime.toISOString() : "") + "&";
        if (sShiftEndTime === null)
            throw new Error("The parameter 'sShiftEndTime' cannot be null.");
        else if (sShiftEndTime !== undefined)
            url_ += "sShiftEndTime=" + encodeURIComponent(sShiftEndTime ? "" + sShiftEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSiftMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSiftMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSiftMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBinMaster(body: Bin | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/CreateBinMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBinMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBinMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateBinMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param binCode (optional) 
     * @return Success
     */
    deleteBinMaster(binCode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/DeleteBinMaster?";
        if (binCode !== undefined && binCode !== null)
            url_ += "BinCode=" + encodeURIComponent("" + binCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBinMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBinMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBinMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param shiftCode (optional) 
     * @param shiftDescription (optional) 
     * @param sShiftStartTime (optional) 
     * @param sShiftEndTime (optional) 
     * @return Success
     */
    createSiftMaster(shiftCode: string | null | undefined, shiftDescription: string | null | undefined, sShiftStartTime: moment.Moment | undefined, sShiftEndTime: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/CreateSiftMaster?";
        if (shiftCode !== undefined && shiftCode !== null)
            url_ += "ShiftCode=" + encodeURIComponent("" + shiftCode) + "&";
        if (shiftDescription !== undefined && shiftDescription !== null)
            url_ += "ShiftDescription=" + encodeURIComponent("" + shiftDescription) + "&";
        if (sShiftStartTime === null)
            throw new Error("The parameter 'sShiftStartTime' cannot be null.");
        else if (sShiftStartTime !== undefined)
            url_ += "sShiftStartTime=" + encodeURIComponent(sShiftStartTime ? "" + sShiftStartTime.toISOString() : "") + "&";
        if (sShiftEndTime === null)
            throw new Error("The parameter 'sShiftEndTime' cannot be null.");
        else if (sShiftEndTime !== undefined)
            url_ += "sShiftEndTime=" + encodeURIComponent(sShiftEndTime ? "" + sShiftEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSiftMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSiftMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateSiftMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param plantCode (optional) 
     * @param plantType (optional) 
     * @param description (optional) 
     * @param address (optional) 
     * @param active (optional) 
     * @return Success
     */
    postPlantMaster(plantCode: string | null | undefined, plantType: string | null | undefined, description: string | null | undefined, address: string | null | undefined, active: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/PostPlantMaster?";
        if (plantCode !== undefined && plantCode !== null)
            url_ += "PlantCode=" + encodeURIComponent("" + plantCode) + "&";
        if (plantType !== undefined && plantType !== null)
            url_ += "PlantType=" + encodeURIComponent("" + plantType) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlantMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlantMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostPlantMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param sPlantCode (optional) 
     * @param binCode (optional) 
     * @param description (optional) 
     * @param active (optional) 
     * @return Success
     */
    postBinMaster(sPlantCode: string | null | undefined, binCode: string | null | undefined, description: string | null | undefined, active: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/PostBinMaster?";
        if (sPlantCode !== undefined && sPlantCode !== null)
            url_ += "sPlantCode=" + encodeURIComponent("" + sPlantCode) + "&";
        if (binCode !== undefined && binCode !== null)
            url_ += "BinCode=" + encodeURIComponent("" + binCode) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostBinMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostBinMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostBinMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPackingOrderDetails(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetPackingOrderDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackingOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackingOrderDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPackingOrderDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param plantCode (optional) 
     * @param userid (optional) 
     * @param lineBarCode (optional) 
     * @return Success
     */
    lineBinMapping_ScanLine(plantCode: string | null | undefined, userid: string | null | undefined, lineBarCode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/LineBinMapping_ScanLine?";
        if (plantCode !== undefined && plantCode !== null)
            url_ += "PlantCode=" + encodeURIComponent("" + plantCode) + "&";
        if (userid !== undefined && userid !== null)
            url_ += "Userid=" + encodeURIComponent("" + userid) + "&";
        if (lineBarCode !== undefined && lineBarCode !== null)
            url_ += "LineBarCode=" + encodeURIComponent("" + lineBarCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLineBinMapping_ScanLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLineBinMapping_ScanLine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLineBinMapping_ScanLine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param plantCode (optional) 
     * @param userid (optional) 
     * @param barcode (optional) 
     * @return Success
     */
    lineBinMapping_ScanBarcode(plantCode: string | null | undefined, userid: string | null | undefined, barcode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/LineBinMapping_ScanBarcode?";
        if (plantCode !== undefined && plantCode !== null)
            url_ += "PlantCode=" + encodeURIComponent("" + plantCode) + "&";
        if (userid !== undefined && userid !== null)
            url_ += "Userid=" + encodeURIComponent("" + userid) + "&";
        if (barcode !== undefined && barcode !== null)
            url_ += "Barcode=" + encodeURIComponent("" + barcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLineBinMapping_ScanBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLineBinMapping_ScanBarcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLineBinMapping_ScanBarcode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lineBinMapping_Mapping(body: LineWorkBinMapping | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/LineBinMapping_Mapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLineBinMapping_Mapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLineBinMapping_Mapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLineBinMapping_Mapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateSerialNo(body: GenerateSerialNumber | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GenerateSerialNo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateSerialNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateSerialNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateSerialNo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param packingOrder (optional) 
     * @return Success
     */
    getSerialNumberDetails(packingOrder: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogSuryaApiService/GetSerialNumberDetails?";
        if (packingOrder !== undefined && packingOrder !== null)
            url_ += "packingOrder=" + encodeURIComponent("" + packingOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSerialNumberDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSerialNumberDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetSerialNumberDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FormApprovalDataServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FormApprovalDataDto | undefined): Observable<FormApprovalDataDto> {
        let url_ = this.baseUrl + "/api/services/app/FormApprovalDataService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormApprovalDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormApprovalDataDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FormApprovalDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormApprovalDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormApprovalDataDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param formId (optional) 
     * @param status (optional) 
     * @param remark (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, formId: number | null | undefined, status: number | null | undefined, remark: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FormApprovalDataDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FormApprovalDataService/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (formId !== undefined && formId !== null)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (remark !== undefined && remark !== null)
            url_ += "Remark=" + encodeURIComponent("" + remark) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormApprovalDataDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormApprovalDataDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FormApprovalDataDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormApprovalDataDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormApprovalDataDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class HardwareConnectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printerAvailable(body: Connection | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HardwareConnection/PrinterAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrinterAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrinterAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPrinterAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    weighingMachineAvailable(body: Connection | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HardwareConnection/WeighingMachineAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeighingMachineAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeighingMachineAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processWeighingMachineAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class LogAnalyticsServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LogAnalyticsDto> {
        let url_ = this.baseUrl + "/api/services/app/LogAnalyticsServices/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogAnalyticsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LogAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogAnalyticsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param clientId (optional) 
     * @param formName (optional) 
     * @param isActive (optional) 
     * @param count (optional) 
     * @param totalActiveForm (optional) 
     * @param totalInactiveForms (optional) 
     * @param totalApprovalCount (optional) 
     * @param totalDisApproveCount (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, clientId: number | null | undefined, formName: string | null | undefined, isActive: boolean | null | undefined, count: number | undefined, totalActiveForm: number | undefined, totalInactiveForms: number | undefined, totalApprovalCount: number | undefined, totalDisApproveCount: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LogAnalyticsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LogAnalyticsServices/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (formName !== undefined && formName !== null)
            url_ += "FormName=" + encodeURIComponent("" + formName) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (totalActiveForm === null)
            throw new Error("The parameter 'totalActiveForm' cannot be null.");
        else if (totalActiveForm !== undefined)
            url_ += "totalActiveForm=" + encodeURIComponent("" + totalActiveForm) + "&";
        if (totalInactiveForms === null)
            throw new Error("The parameter 'totalInactiveForms' cannot be null.");
        else if (totalInactiveForms !== undefined)
            url_ += "totalInactiveForms=" + encodeURIComponent("" + totalInactiveForms) + "&";
        if (totalApprovalCount === null)
            throw new Error("The parameter 'totalApprovalCount' cannot be null.");
        else if (totalApprovalCount !== undefined)
            url_ += "totalApprovalCount=" + encodeURIComponent("" + totalApprovalCount) + "&";
        if (totalDisApproveCount === null)
            throw new Error("The parameter 'totalDisApproveCount' cannot be null.");
        else if (totalDisApproveCount !== undefined)
            url_ += "totalDisApproveCount=" + encodeURIComponent("" + totalDisApproveCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogAnalyticsDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogAnalyticsDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LogAnalyticsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogAnalyticsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogAnalyticsDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByFilter(input: number | undefined): Observable<LogAnalyticsListDto> {
        let url_ = this.baseUrl + "/api/services/app/LogAnalyticsServices/GetByFilter?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogAnalyticsListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogAnalyticsListDto>;
        }));
    }

    protected processGetByFilter(response: HttpResponseBase): Observable<LogAnalyticsListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogAnalyticsListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogAnalyticsListDto>(null as any);
    }
}

@Injectable()
export class LogFormsHistoryServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LogFormHistoryDto | undefined): Observable<LogFormHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/LogFormsHistoryService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogFormHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogFormHistoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LogFormHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogFormHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogFormHistoryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LogFormHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/LogFormsHistoryService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogFormHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogFormHistoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LogFormHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogFormHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogFormHistoryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param formId (optional) 
     * @param remarks (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | undefined, formId: number | undefined, remarks: string | null | undefined, status: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LogFormHistoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LogFormsHistoryService/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (remarks !== undefined && remarks !== null)
            url_ += "Remarks=" + encodeURIComponent("" + remarks) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogFormHistoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogFormHistoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LogFormHistoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogFormHistoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogFormHistoryDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class LogsDataServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LogsDataDto | undefined): Observable<LogsDataDto> {
        let url_ = this.baseUrl + "/api/services/app/LogsDataServices/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogsDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogsDataDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LogsDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogsDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogsDataDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LogsDataDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LogsDataServices/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogsDataDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogsDataDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LogsDataDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogsDataDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogsDataDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ModuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllModule(keyword: string | null | undefined, status: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ModuleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllModule?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleListDtoPagedResultDto>;
        }));
    }

    protected processGetAllModule(response: HttpResponseBase): Observable<ModuleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleListDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param status (optional) 
     * @param moduleId (optional) 
     * @param approvalRequired (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSubModule(keyword: string | null | undefined, status: number | null | undefined, moduleId: number | null | undefined, approvalRequired: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SubModuleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllSubModule?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (approvalRequired !== undefined && approvalRequired !== null)
            url_ += "ApprovalRequired=" + encodeURIComponent("" + approvalRequired) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubModuleListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubModuleListDtoPagedResultDto>;
        }));
    }

    protected processGetAllSubModule(response: HttpResponseBase): Observable<SubModuleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubModuleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ModuleDto | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSubModules(id: number | undefined): Observable<SubModuleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubModules?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubModuleDto[]>;
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SubModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSubModule(id: number | undefined): Observable<SubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubModule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubModuleDto>;
        }));
    }

    protected processGetSubModule(response: HttpResponseBase): Observable<SubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubModule(body: UpdateSubModuleDto | undefined): Observable<UpdateSubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/UpdateSubModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateSubModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateSubModuleDto>;
        }));
    }

    protected processUpdateSubModule(response: HttpResponseBase): Observable<UpdateSubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateSubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateSubModuleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignSubModules(body: ModuleSubModuleDto | undefined): Observable<ModuleSubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/AssignSubModules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignSubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleSubModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleSubModuleDto>;
        }));
    }

    protected processAssignSubModules(response: HttpResponseBase): Observable<ModuleSubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleSubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSubModuleDto>(null as any);
    }

    /**
     * @param moduleName (optional) 
     * @return Success
     */
    getModuleByName(moduleName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModuleByName?";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetModuleByName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param submoduleName (optional) 
     * @return Success
     */
    getSubmoduleByName(submoduleName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubmoduleByName?";
        if (submoduleName !== undefined && submoduleName !== null)
            url_ += "submoduleName=" + encodeURIComponent("" + submoduleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmoduleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmoduleByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetSubmoduleByName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class NotificationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: NotificationDto | undefined): Observable<NotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/NotificationService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param notification_type (optional) 
     * @param assign_roles (optional) 
     * @param assign_email (optional) 
     * @param assign_mobile (optional) 
     * @param log_Id (optional) 
     * @param isActive (optional) 
     * @param repeat (optional) 
     * @param createdOn (optional) 
     * @param modifiedOn (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | undefined, notification_type: number | undefined, assign_roles: string | null | undefined, assign_email: number | undefined, assign_mobile: number | undefined, log_Id: number | undefined, isActive: boolean | undefined, repeat: number | undefined, createdOn: moment.Moment | undefined, modifiedOn: moment.Moment | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NotificationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NotificationService/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (notification_type === null)
            throw new Error("The parameter 'notification_type' cannot be null.");
        else if (notification_type !== undefined)
            url_ += "notification_type=" + encodeURIComponent("" + notification_type) + "&";
        if (assign_roles !== undefined && assign_roles !== null)
            url_ += "assign_roles=" + encodeURIComponent("" + assign_roles) + "&";
        if (assign_email === null)
            throw new Error("The parameter 'assign_email' cannot be null.");
        else if (assign_email !== undefined)
            url_ += "assign_email=" + encodeURIComponent("" + assign_email) + "&";
        if (assign_mobile === null)
            throw new Error("The parameter 'assign_mobile' cannot be null.");
        else if (assign_mobile !== undefined)
            url_ += "assign_mobile=" + encodeURIComponent("" + assign_mobile) + "&";
        if (log_Id === null)
            throw new Error("The parameter 'log_Id' cannot be null.");
        else if (log_Id !== undefined)
            url_ += "log_Id=" + encodeURIComponent("" + log_Id) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (repeat === null)
            throw new Error("The parameter 'repeat' cannot be null.");
        else if (repeat !== undefined)
            url_ += "Repeat=" + encodeURIComponent("" + repeat) + "&";
        if (createdOn === null)
            throw new Error("The parameter 'createdOn' cannot be null.");
        else if (createdOn !== undefined)
            url_ += "CreatedOn=" + encodeURIComponent(createdOn ? "" + createdOn.toISOString() : "") + "&";
        if (modifiedOn === null)
            throw new Error("The parameter 'modifiedOn' cannot be null.");
        else if (modifiedOn !== undefined)
            url_ += "ModifiedOn=" + encodeURIComponent(modifiedOn ? "" + modifiedOn.toISOString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NotificationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PlantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param plantTypeId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param countryId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, plantTypeId: number | null | undefined, activeInactiveStatusId: number | null | undefined, countryId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PlantListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (plantTypeId !== undefined && plantTypeId !== null)
            url_ += "PlantTypeId=" + encodeURIComponent("" + plantTypeId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PlantListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePlantDto | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PlantDto | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectPlant(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Plant/ApproveOrRejectPlant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectPlant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectPlant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param approvalStatusId (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, approvalStatusId: number | null | undefined, status: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectRole(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/ApproveOrRejectRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermisionName(): Observable<ActionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermisionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermisionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermisionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionDto[]>;
        }));
    }

    protected processGetAllPermisionName(response: HttpResponseBase): Observable<ActionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ActionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubModulesWithPermissions(): Observable<RolePermissionsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllSubModulesWithPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModulesWithPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModulesWithPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermissionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermissionsDto[]>;
        }));
    }

    protected processGetAllSubModulesWithPermissions(response: HttpResponseBase): Observable<RolePermissionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RolePermissionsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionsDto[]>(null as any);
    }
}

@Injectable()
export class SelectListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getModes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetModes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCheckpointTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCheckpointTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCheckpointTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param plantId (optional) 
     * @param subModuleId (optional) 
     * @return Success
     */
    getChecklistTypes(plantId: number | null | undefined, subModuleId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklistTypes?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        if (subModuleId === null)
            throw new Error("The parameter 'subModuleId' cannot be null.");
        else if (subModuleId !== undefined)
            url_ += "subModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklistTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklistTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetChecklistTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param subModuleName (optional) 
     * @return Success
     */
    getChecklistTypesBySubModuleName(subModuleName: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklistTypesBySubModuleName?";
        if (subModuleName !== undefined && subModuleName !== null)
            url_ += "subModuleName=" + encodeURIComponent("" + subModuleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklistTypesBySubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklistTypesBySubModuleName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetChecklistTypesBySubModuleName(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param includeIsControllerModes (optional) 
     * @return Success
     */
    getModesBySetting(userId: number | undefined, includeIsControllerModes: boolean | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModesBySetting?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (includeIsControllerModes === null)
            throw new Error("The parameter 'includeIsControllerModes' cannot be null.");
        else if (includeIsControllerModes !== undefined)
            url_ += "includeIsControllerModes=" + encodeURIComponent("" + includeIsControllerModes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModesBySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModesBySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetModesBySetting(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDesignation(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDesignation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDesignation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDesignation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetDesignation(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getApprovalStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetApprovalStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetApprovalStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPlant(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetPlant(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPlantsOnUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlantsOnUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantsOnUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantsOnUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetPlantsOnUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getPlantByUserId(userId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlantByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetPlantByUserId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getReportingManagerUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetReportingManagerUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportingManagerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportingManagerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetReportingManagerUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByRole(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByRole(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByModule(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByModule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByModule(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByPlant(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPlant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPlant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByPlant(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    getStates(countryId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStates?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByGate(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByGate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByGate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByGate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByGate(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByLocation(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByLocation(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMasterPlants(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllMasterPlants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterPlants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllMasterPlants(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubPlants(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllSubPlants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubPlants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllSubPlants(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getStorageLocations(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStorageLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetStorageLocations(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getStorageLocationsWithPlantId(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStorageLocationsWithPlantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocationsWithPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocationsWithPlantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetStorageLocationsWithPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getDepartments(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getDepartmentsByPlantId(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDepartmentsByPlantId?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsByPlantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetDepartmentsByPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByCubicle(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCubicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCubicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByCubicle(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByEquipment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByEquipment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByEquipment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByEquipment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByEquipment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getEquipmentTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetEquipmentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquipmentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquipmentTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetEquipmentTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByHandlingUnit(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByHandlingUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByHandlingUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByHandlingUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByHandlingUnit(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getHandlingUnitTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetHandlingUnitTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandlingUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandlingUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetHandlingUnitTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortBySubModule(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortBySubModule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortBySubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortBySubModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortBySubModule(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByStandardWeightBox(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByStandardWeightBox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByStandardWeightBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByStandardWeightBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByStandardWeightBox(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSubModuleType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSubModuleType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModuleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModuleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSubModuleType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByStandardWeights(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByStandardWeights";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByStandardWeights(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByStandardWeights(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByStandardWeights(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByDepartment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByDepartment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByDepartment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByUnitOfMeasurement(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByUnitOfMeasurement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByUnitOfMeasurement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByUnitOfMeasurement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByUnitOfMeasurement(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getUnitOfMeasurementTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetUnitOfMeasurementTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurementTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurementTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetUnitOfMeasurementTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getConversionUOMMasters(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetConversionUOMMasters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConversionUOMMasters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversionUOMMasters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetConversionUOMMasters(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByArea(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByArea";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByArea(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByInspectionChecklist(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByInspectionChecklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByInspectionChecklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByInspectionChecklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByInspectionChecklist(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByWeighingMachine(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeighingMachine";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeighingMachine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeighingMachine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByWeighingMachine(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByDevice(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByDevice";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByDevice(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAreas(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAreasByPlantId(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreasByPlantId?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreasByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreasByPlantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAreasByPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param departmentId (optional) 
     * @return Success
     */
    getAreasByDepartmentId(departmentId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreasByDepartmentId?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreasByDepartmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreasByDepartmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAreasByDepartmentId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCubicles(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubicles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCubicles(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param areaId (optional) 
     * @return Success
     */
    getCubiclesByAreaId(areaId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubiclesByAreaId?";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubiclesByAreaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubiclesByAreaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCubiclesByAreaId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDeviceTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDeviceTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetDeviceTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getTemperatureUnit(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetTemperatureUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemperatureUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemperatureUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetTemperatureUnit(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getGateEntrysortBy(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetGateEntrysortBy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntrysortBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntrysortBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetGateEntrysortBy(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getWeighingMachineFrequencyType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetWeighingMachineFrequencyType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineFrequencyType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineFrequencyType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetWeighingMachineFrequencyType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getWeighingMachineBalancedType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetWeighingMachineBalancedType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineBalancedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineBalancedType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetWeighingMachineBalancedType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByChecklistType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByChecklistType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByChecklistType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByChecklistType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByChecklistType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAssociatedPlantByUserId(userId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAssociatedPlantByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociatedPlantByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociatedPlantByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAssociatedPlantByUserId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getHolidayType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetHolidayType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetHolidayType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByCalender(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCalender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCalender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCalender(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByCalender(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPrinters(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPrinters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrinters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrinters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetPrinters(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getTransactionStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetTransactionStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetTransactionStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getGateEntryStatus(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetGateEntryStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntryStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetGateEntryStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getSortByVehicleInspection(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByVehicleInspection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByVehicleInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByVehicleInspection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByVehicleInspection(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByMaterialInspection(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByMaterialInspection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByMaterialInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByMaterialInspection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByMaterialInspection(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param checklistTypeId (optional) 
     * @return Success
     */
    getChecklists(checklistTypeId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklists?";
        if (checklistTypeId === null)
            throw new Error("The parameter 'checklistTypeId' cannot be null.");
        else if (checklistTypeId !== undefined)
            url_ += "checklistTypeId=" + encodeURIComponent("" + checklistTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetChecklists(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByWeightCapture(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeightCapture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeightCapture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeightCapture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByWeightCapture(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByGRNPosting(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByGRNPosting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByGRNPosting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByGRNPosting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByGRNPosting(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getStandardWeightBox(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStandardWeightBox?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStandardWeightBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardWeightBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetStandardWeightBox(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param purchaseorderId (optional) 
     * @return Success
     */
    getInvoiceByPurchaseOrderId(purchaseorderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetInvoiceByPurchaseOrderId?";
        if (purchaseorderId === null)
            throw new Error("The parameter 'purchaseorderId' cannot be null.");
        else if (purchaseorderId !== undefined)
            url_ += "purchaseorderId=" + encodeURIComponent("" + purchaseorderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceByPurchaseOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceByPurchaseOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetInvoiceByPurchaseOrderId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getUnitOfMeasurementById(uomId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetUnitOfMeasurementById?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurementById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetUnitOfMeasurementById(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByPalletization(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPalletization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPalletization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPalletization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByPalletization(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMaterialSelectList(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllMaterialSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterialSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterialSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetAllMaterialSelectList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPallets(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPallets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetAllPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPalletizationPallets(): Observable<SelectListDtoWithPlantIdPalletization[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletizationPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletizationPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletizationPallets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantIdPalletization[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantIdPalletization[]>;
        }));
    }

    protected processGetAllPalletizationPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantIdPalletization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantIdPalletization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantIdPalletization[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPalletMasterPallets(): Observable<SelectListDtoWithPlantIdPalletization[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletMasterPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletMasterPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletMasterPallets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantIdPalletization[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantIdPalletization[]>;
        }));
    }

    protected processGetAllPalletMasterPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantIdPalletization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantIdPalletization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantIdPalletization[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByPutAway(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPutAway";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPutAway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPutAway(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByPutAway(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByCubicleAssignment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCubicleAssignment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCubicleAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCubicleAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByCubicleAssignment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortBySamplingCubicleAssignment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortBySamplingCubicleAssignment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortBySamplingCubicleAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortBySamplingCubicleAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortBySamplingCubicleAssignment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCubicleBarcode(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllCubicleBarcode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCubicleBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCubicleBarcode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetAllCubicleBarcode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getCubicleAssignmentGroupStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubicleAssignmentGroupStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleAssignmentGroupStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleAssignmentGroupStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCubicleAssignmentGroupStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCalibrationStatusTest(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCalibrationStatusTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibrationStatusTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibrationStatusTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCalibrationStatusTest(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCalibrationStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCalibrationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibrationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibrationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetCalibrationStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByWeighingCalibration(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeighingCalibration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeighingCalibration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeighingCalibration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByWeighingCalibration(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param purchaseorderIdList (optional) 
     * @param plantId (optional) 
     * @return Success
     */
    getmaterialsByPurchaseOrder(purchaseorderIdList: number[] | null | undefined, plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetmaterialsByPurchaseOrder?";
        if (purchaseorderIdList !== undefined && purchaseorderIdList !== null)
            purchaseorderIdList && purchaseorderIdList.forEach(item => { url_ += "purchaseorderIdList=" + encodeURIComponent("" + item) + "&"; });
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmaterialsByPurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmaterialsByPurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetmaterialsByPurchaseOrder(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllApprovelLevels(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllApprovelLevels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApprovelLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApprovelLevels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllApprovelLevels(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllcubicals(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllcubicals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllcubicals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllcubicals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllcubicals(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllcubicalsOfCurrentPlantId(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllcubicalsOfCurrentPlantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllcubicalsOfCurrentPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllcubicalsOfCurrentPlantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllcubicalsOfCurrentPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllActivity(subModule: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllActivity?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllActivity(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllEquipments(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllEquipments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllEquipments(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getMaterialMaster(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetMaterialMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetMaterialMaster(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSortByPasswordRequestedUsers(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPasswordRequestedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPasswordRequestedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPasswordRequestedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetSortByPasswordRequestedUsers(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllCheckList(subModule: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllCheckList?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCheckList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetAllCheckList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllInspectionCheckList(subModule: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllInspectionCheckList?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInspectionCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInspectionCheckList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDtoWithPlantId[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDtoWithPlantId[]>;
        }));
    }

    protected processGetAllInspectionCheckList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPalletCode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllPalletCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllShipperCode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllShipperCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShipperCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShipperCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetAllShipperCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getProcessOrdersAssignedToCubicle(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetProcessOrdersAssignedToCubicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersAssignedToCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersAssignedToCubicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetProcessOrdersAssignedToCubicle(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPlantCode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlantCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectListDto[]>;
        }));
    }

    protected processGetPlantCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(null as any);
    }

    /**
     * @param plantCode (optional) 
     * @return Success
     */
    getPackingOrderNo(plantCode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPackingOrderNo?";
        if (plantCode !== undefined && plantCode !== null)
            url_ += "plantCode=" + encodeURIComponent("" + plantCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackingOrderNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackingOrderNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPackingOrderNo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getLineWorkNo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetLineWorkNo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineWorkNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineWorkNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetLineWorkNo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Setting/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadLogo(file: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Setting/UploadLogo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadLogo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getLogo(): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingDto>;
        }));
    }

    protected processGetLogo(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(null as any);
    }
}

@Injectable()
export class StandardWeightServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StandardWeightDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StandardWeightDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(null as any);
    }

    /**
     * @param subPlantId (optional) 
     * @param capacity (optional) 
     * @param departmentId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param keyword (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, capacity: number | null | undefined, departmentId: number | null | undefined, activeInactiveStatusId: number | null | undefined, keyword: string | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<StandardWeightListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (capacity !== undefined && capacity !== null)
            url_ += "Capacity=" + encodeURIComponent("" + capacity) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StandardWeightListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StandardWeightListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StandardWeightListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateStandardWeightDto | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StandardWeightDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StandardWeightDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StandardWeightDto | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StandardWeightDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StandardWeightDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getStandardWeightStampingDueList(): Observable<StandardWeightStampingDueListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/GetStandardWeightStampingDueList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStandardWeightStampingDueList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardWeightStampingDueList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StandardWeightStampingDueListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StandardWeightStampingDueListDto[]>;
        }));
    }

    protected processGetStandardWeightStampingDueList(response: HttpResponseBase): Observable<StandardWeightStampingDueListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StandardWeightStampingDueListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightStampingDueListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectStandardWeight(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/ApproveOrRejectStandardWeight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectStandardWeight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectStandardWeight(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectStandardWeight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateUsingActiveDirectory(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateUsingActiveDirectory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateUsingActiveDirectory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateUsingActiveDirectory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticateUsingActiveDirectory(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserProfile(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param userName (optional) 
     * @param plantId (optional) 
     * @param modeId (optional) 
     * @param designationId (optional) 
     * @param approvalStatusId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param creationFromTime (optional) 
     * @param creationToTime (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(userName: string | null | undefined, plantId: number | null | undefined, modeId: number | null | undefined, designationId: number | null | undefined, approvalStatusId: number | null | undefined, activeInactiveStatusId: number | null | undefined, creationFromTime: moment.Moment | null | undefined, creationToTime: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UsersListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (modeId !== undefined && modeId !== null)
            url_ += "ModeId=" + encodeURIComponent("" + modeId) + "&";
        if (designationId !== undefined && designationId !== null)
            url_ += "DesignationId=" + encodeURIComponent("" + designationId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (creationFromTime !== undefined && creationFromTime !== null)
            url_ += "CreationFromTime=" + encodeURIComponent(creationFromTime ? "" + creationFromTime.toISOString() : "") + "&";
        if (creationToTime !== undefined && creationToTime !== null)
            url_ += "CreationToTime=" + encodeURIComponent(creationToTime ? "" + creationToTime.toISOString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UsersListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UsersListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UsersListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserProfile(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectUser(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ApproveOrRejectUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllRoles(): Observable<RoleCheckboxDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleCheckboxDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleCheckboxDto>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleCheckboxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleCheckboxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleCheckboxDto>(null as any);
    }

    /**
     * @param noOfUsers (optional) 
     * @return Success
     */
    addOrUpdateUserCreationLimit(noOfUsers: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/AddOrUpdateUserCreationLimit?";
        if (noOfUsers === null)
            throw new Error("The parameter 'noOfUsers' cannot be null.");
        else if (noOfUsers !== undefined)
            url_ += "noOfUsers=" + encodeURIComponent("" + noOfUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateUserCreationLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateUserCreationLimit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddOrUpdateUserCreationLimit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WeighingMachineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeighingMachineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeighingMachineDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param subPlantId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, subPlantId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WeighingMachineListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeighingMachineListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeighingMachineListDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WeighingMachineListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWeighingMachineDto | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeighingMachineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeighingMachineDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WeighingMachineDto | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeighingMachineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeighingMachineDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectWeighingMachine(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/ApproveOrRejectWeighingMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectWeighingMachine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectWeighingMachine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectWeighingMachine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getStampingDueOnWMList(): Observable<WeighingMachineStampingDueOnListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/GetStampingDueOnWMList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStampingDueOnWMList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStampingDueOnWMList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeighingMachineStampingDueOnListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeighingMachineStampingDueOnListDto[]>;
        }));
    }

    protected processGetStampingDueOnWMList(response: HttpResponseBase): Observable<WeighingMachineStampingDueOnListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WeighingMachineStampingDueOnListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineStampingDueOnListDto[]>(null as any);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ForgotPasswordDto implements IForgotPasswordDto {
    employeeCode: string;
    passwordStatus: number;

    constructor(data?: IForgotPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeCode = _data["employeeCode"];
            this.passwordStatus = _data["passwordStatus"];
        }
    }

    static fromJS(data: any): ForgotPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeCode"] = this.employeeCode;
        data["passwordStatus"] = this.passwordStatus;
        return data;
    }

    clone(): ForgotPasswordDto {
        const json = this.toJSON();
        let result = new ForgotPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordDto {
    employeeCode: string;
    passwordStatus: number;
}

export class ForgotPasswordOutput implements IForgotPasswordOutput {
    result: boolean;
    userRole: string | undefined;

    constructor(data?: IForgotPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.userRole = _data["userRole"];
        }
    }

    static fromJS(data: any): ForgotPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["userRole"] = this.userRole;
        return data;
    }

    clone(): ForgotPasswordOutput {
        const json = this.toJSON();
        let result = new ForgotPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordOutput {
    result: boolean;
    userRole: string | undefined;
}

export class ApprovalLevelDto implements IApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalLevelDto {
        const json = this.toJSON();
        let result = new ApprovalLevelDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ApprovalLevelListDto implements IApprovalLevelListDto {
    levelCode: number;
    levelName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalLevelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalLevelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalLevelListDto {
        const json = this.toJSON();
        let result = new ApprovalLevelListDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelListDto {
    levelCode: number;
    levelName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ApprovalLevelListDtoPagedResultDto implements IApprovalLevelListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalLevelListDto[] | undefined;

    constructor(data?: IApprovalLevelListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalLevelListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalLevelListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApprovalLevelListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalLevelListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalLevelListDto[] | undefined;
}

export class CreateApprovalLevelDto implements ICreateApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateApprovalLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateApprovalLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateApprovalLevelDto {
        const json = this.toJSON();
        let result = new CreateApprovalLevelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
}

export class SelectListDto implements ISelectListDto {
    value: string | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["id"] = this.id;
        return data;
    }

    clone(): SelectListDto {
        const json = this.toJSON();
        let result = new SelectListDto();
        result.init(json);
        return result;
    }
}

export interface ISelectListDto {
    value: string | undefined;
    id: any | undefined;
}

export class ApprovalUserModuleMappingDto implements IApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalUserModuleMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalUserModuleMappingDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    id: number;
}

export class ApprovalUserModuleMappingListDto implements IApprovalUserModuleMappingListDto {
    userEnteredAppLevelId: string | undefined;
    userEnteredUserId: string | undefined;
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    id: number;

    constructor(data?: IApprovalUserModuleMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEnteredAppLevelId = _data["userEnteredAppLevelId"];
            this.userEnteredUserId = _data["userEnteredUserId"];
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.moduleName = _data["moduleName"];
            this.subModuleName = _data["subModuleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEnteredAppLevelId"] = this.userEnteredAppLevelId;
        data["userEnteredUserId"] = this.userEnteredUserId;
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["moduleName"] = this.moduleName;
        data["subModuleName"] = this.subModuleName;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalUserModuleMappingListDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingListDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingListDto {
    userEnteredAppLevelId: string | undefined;
    userEnteredUserId: string | undefined;
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    id: number;
}

export class ApprovalUserModuleMappingListDtoPagedResultDto implements IApprovalUserModuleMappingListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalUserModuleMappingListDto[] | undefined;

    constructor(data?: IApprovalUserModuleMappingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalUserModuleMappingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApprovalUserModuleMappingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalUserModuleMappingListDto[] | undefined;
}

export class CreateApprovalUserModuleMappingDto implements ICreateApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;

    constructor(data?: ICreateApprovalUserModuleMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateApprovalUserModuleMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalUserModuleMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateApprovalUserModuleMappingDto {
        const json = this.toJSON();
        let result = new CreateApprovalUserModuleMappingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
}

export class AtesttableMasterDto implements IAtesttableMasterDto {
    testfield1: string | undefined;
    testfield2: string | undefined;
    testfield3: string | undefined;
    testfield4: string | undefined;
    id: number;

    constructor(data?: IAtesttableMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testfield1 = _data["testfield1"];
            this.testfield2 = _data["testfield2"];
            this.testfield3 = _data["testfield3"];
            this.testfield4 = _data["testfield4"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AtesttableMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AtesttableMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testfield1"] = this.testfield1;
        data["testfield2"] = this.testfield2;
        data["testfield3"] = this.testfield3;
        data["testfield4"] = this.testfield4;
        data["id"] = this.id;
        return data;
    }

    clone(): AtesttableMasterDto {
        const json = this.toJSON();
        let result = new AtesttableMasterDto();
        result.init(json);
        return result;
    }
}

export interface IAtesttableMasterDto {
    testfield1: string | undefined;
    testfield2: string | undefined;
    testfield3: string | undefined;
    testfield4: string | undefined;
    id: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
    userId: number;
    newPassword: string;
    confirmPassword: string | undefined;
    passwordStatus: number;
    currentUser: number;
    status: boolean;
    userName: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
            this.passwordStatus = _data["passwordStatus"];
            this.currentUser = _data["currentUser"];
            this.status = _data["status"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        data["passwordStatus"] = this.passwordStatus;
        data["currentUser"] = this.currentUser;
        data["status"] = this.status;
        data["userName"] = this.userName;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    userId: number;
    newPassword: string;
    confirmPassword: string | undefined;
    passwordStatus: number;
    currentUser: number;
    status: boolean;
    userName: string | undefined;
}

export class ChangePasswordSuperAdminDto implements IChangePasswordSuperAdminDto {
    employeeCode: string;
    newPassword: string;

    constructor(data?: IChangePasswordSuperAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeCode = _data["employeeCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordSuperAdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordSuperAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeCode"] = this.employeeCode;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordSuperAdminDto {
        const json = this.toJSON();
        let result = new ChangePasswordSuperAdminDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordSuperAdminDto {
    employeeCode: string;
    newPassword: string;
}

export class ChangePasswordSuperAdminOutputDto implements IChangePasswordSuperAdminOutputDto {
    status: boolean;
    message: string | undefined;

    constructor(data?: IChangePasswordSuperAdminOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ChangePasswordSuperAdminOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordSuperAdminOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }

    clone(): ChangePasswordSuperAdminOutputDto {
        const json = this.toJSON();
        let result = new ChangePasswordSuperAdminOutputDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordSuperAdminOutputDto {
    status: boolean;
    message: string | undefined;
}

export class UserDto implements IUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    isDeleted: boolean;
    plants: number[] | undefined;
    designationId: number | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    employeeCode: string | undefined;
    createdOn: moment.Moment;
    roleNames: string[] | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    activeInactiveStatusOfUser: boolean;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(item);
            }
            this.designationId = _data["designationId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.modeId = _data["modeId"];
            this.employeeCode = _data["employeeCode"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.activeInactiveStatusOfUser = _data["activeInactiveStatusOfUser"];
            this.passwordStatus = _data["passwordStatus"];
            this.passwordResetTime = _data["passwordResetTime"] ? moment(_data["passwordResetTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item);
        }
        data["designationId"] = this.designationId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["modeId"] = this.modeId;
        data["employeeCode"] = this.employeeCode;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["activeInactiveStatusOfUser"] = this.activeInactiveStatusOfUser;
        data["passwordStatus"] = this.passwordStatus;
        data["passwordResetTime"] = this.passwordResetTime ? this.passwordResetTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    isDeleted: boolean;
    plants: number[] | undefined;
    designationId: number | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    employeeCode: string | undefined;
    createdOn: moment.Moment;
    roleNames: string[] | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    activeInactiveStatusOfUser: boolean;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    id: number;
}

export class WMSPasswordManagerDto implements IWMSPasswordManagerDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IWMSPasswordManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMSPasswordManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WMSPasswordManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): WMSPasswordManagerDto {
        const json = this.toJSON();
        let result = new WMSPasswordManagerDto();
        result.init(json);
        return result;
    }
}

export interface IWMSPasswordManagerDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    id: number;
}

export class WMSPasswordManagerDetailsDto implements IWMSPasswordManagerDetailsDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment | undefined;
    id: number;

    constructor(data?: IWMSPasswordManagerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? moment(_data["modifiedOn"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMSPasswordManagerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WMSPasswordManagerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): WMSPasswordManagerDetailsDto {
        const json = this.toJSON();
        let result = new WMSPasswordManagerDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IWMSPasswordManagerDetailsDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment | undefined;
    id: number;
}

export class RequestedUsersListDto implements IRequestedUsersListDto {
    userId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    request: string | undefined;
    status: string | undefined;
    roleNames: string | undefined;
    id: number;

    constructor(data?: IRequestedUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.request = _data["request"];
            this.status = _data["status"];
            this.roleNames = _data["roleNames"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestedUsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedUsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["request"] = this.request;
        data["status"] = this.status;
        data["roleNames"] = this.roleNames;
        data["id"] = this.id;
        return data;
    }

    clone(): RequestedUsersListDto {
        const json = this.toJSON();
        let result = new RequestedUsersListDto();
        result.init(json);
        return result;
    }
}

export interface IRequestedUsersListDto {
    userId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    request: string | undefined;
    status: string | undefined;
    roleNames: string | undefined;
    id: number;
}

export class RequestedUsersListDtoPagedResultDto implements IRequestedUsersListDtoPagedResultDto {
    totalCount: number;
    items: RequestedUsersListDto[] | undefined;

    constructor(data?: IRequestedUsersListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RequestedUsersListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestedUsersListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedUsersListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RequestedUsersListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RequestedUsersListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRequestedUsersListDtoPagedResultDto {
    totalCount: number;
    items: RequestedUsersListDto[] | undefined;
}

export class ClientFormsDto implements IClientFormsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment | undefined;
    formEndDate: moment.Moment | undefined;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment | undefined;
    modifiedDate: moment.Moment | undefined;
    formStatus: number;
    updatedBy: string | undefined;
    approvedBy: string | undefined;
    checkedBy: string | undefined;
    createdBy: string | undefined;
    approveDateTime: moment.Moment;
    permissions: string | undefined;
    menuId: string | undefined;
    id: number;

    constructor(data?: IClientFormsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.formName = _data["formName"];
            this.formStartDate = _data["formStartDate"] ? moment(_data["formStartDate"].toString()) : <any>undefined;
            this.formEndDate = _data["formEndDate"] ? moment(_data["formEndDate"].toString()) : <any>undefined;
            this.formJson = _data["formJson"];
            this.isActive = _data["isActive"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.formStatus = _data["formStatus"];
            this.updatedBy = _data["updatedBy"];
            this.approvedBy = _data["approvedBy"];
            this.checkedBy = _data["checkedBy"];
            this.createdBy = _data["createdBy"];
            this.approveDateTime = _data["approveDateTime"] ? moment(_data["approveDateTime"].toString()) : <any>undefined;
            this.permissions = _data["permissions"];
            this.menuId = _data["menuId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientFormsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFormsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["formName"] = this.formName;
        data["formStartDate"] = this.formStartDate ? this.formStartDate.toISOString() : <any>undefined;
        data["formEndDate"] = this.formEndDate ? this.formEndDate.toISOString() : <any>undefined;
        data["formJson"] = this.formJson;
        data["isActive"] = this.isActive;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["formStatus"] = this.formStatus;
        data["updatedBy"] = this.updatedBy;
        data["approvedBy"] = this.approvedBy;
        data["checkedBy"] = this.checkedBy;
        data["createdBy"] = this.createdBy;
        data["approveDateTime"] = this.approveDateTime ? this.approveDateTime.toISOString() : <any>undefined;
        data["permissions"] = this.permissions;
        data["menuId"] = this.menuId;
        data["id"] = this.id;
        return data;
    }

    clone(): ClientFormsDto {
        const json = this.toJSON();
        let result = new ClientFormsDto();
        result.init(json);
        return result;
    }
}

export interface IClientFormsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment | undefined;
    formEndDate: moment.Moment | undefined;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment | undefined;
    modifiedDate: moment.Moment | undefined;
    formStatus: number;
    updatedBy: string | undefined;
    approvedBy: string | undefined;
    checkedBy: string | undefined;
    createdBy: string | undefined;
    approveDateTime: moment.Moment;
    permissions: string | undefined;
    menuId: string | undefined;
    id: number;
}

export class ClientFormsDtoPagedResultDto implements IClientFormsDtoPagedResultDto {
    totalCount: number;
    items: ClientFormsDto[] | undefined;

    constructor(data?: IClientFormsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ClientFormsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientFormsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFormsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClientFormsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ClientFormsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IClientFormsDtoPagedResultDto {
    totalCount: number;
    items: ClientFormsDto[] | undefined;
}

export class Int64StringKeyValue implements IInt64StringKeyValue {
    key: number;
    value: string | undefined;

    constructor(data?: IInt64StringKeyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Int64StringKeyValue {
        data = typeof data === 'object' ? data : {};
        let result = new Int64StringKeyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): Int64StringKeyValue {
        const json = this.toJSON();
        let result = new Int64StringKeyValue();
        result.init(json);
        return result;
    }
}

export interface IInt64StringKeyValue {
    key: number;
    value: string | undefined;
}

export class SmartDateTime implements ISmartDateTime {
    readonly year: number;
    readonly month: number;
    readonly day: number;
    readonly hour: number;
    readonly minute: number;
    readonly second: number;
    dateTime: moment.Moment;

    constructor(data?: ISmartDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).year = _data["year"];
            (<any>this).month = _data["month"];
            (<any>this).day = _data["day"];
            (<any>this).hour = _data["hour"];
            (<any>this).minute = _data["minute"];
            (<any>this).second = _data["second"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SmartDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new SmartDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): SmartDateTime {
        const json = this.toJSON();
        let result = new SmartDateTime();
        result.init(json);
        return result;
    }
}

export interface ISmartDateTime {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    second: number;
    dateTime: moment.Moment;
}

export class Menu implements IMenu {
    id: number;
    module: string;
    subModule: string;
    path: string;
    displayName: string | undefined;
    componentName: string | undefined;
    permissionName: string | undefined;
    createdBy: Int64StringKeyValue;
    createdOn: SmartDateTime;
    readonly isDeleted: boolean;
    readonly isDirty: boolean;
    readonly isNew: boolean;
    readonly isSelfDirty: boolean;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.module = _data["module"];
            this.subModule = _data["subModule"];
            this.path = _data["path"];
            this.displayName = _data["displayName"];
            this.componentName = _data["componentName"];
            this.permissionName = _data["permissionName"];
            this.createdBy = _data["createdBy"] ? Int64StringKeyValue.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdOn = _data["createdOn"] ? SmartDateTime.fromJS(_data["createdOn"]) : <any>undefined;
            (<any>this).isDeleted = _data["isDeleted"];
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isSelfDirty = _data["isSelfDirty"];
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["subModule"] = this.subModule;
        data["path"] = this.path;
        data["displayName"] = this.displayName;
        data["componentName"] = this.componentName;
        data["permissionName"] = this.permissionName;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isSelfDirty"] = this.isSelfDirty;
        return data;
    }

    clone(): Menu {
        const json = this.toJSON();
        let result = new Menu();
        result.init(json);
        return result;
    }
}

export interface IMenu {
    id: number;
    module: string;
    subModule: string;
    path: string;
    displayName: string | undefined;
    componentName: string | undefined;
    permissionName: string | undefined;
    createdBy: Int64StringKeyValue;
    createdOn: SmartDateTime;
    isDeleted: boolean;
    isDirty: boolean;
    isNew: boolean;
    isSelfDirty: boolean;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export enum SerializationFormat {
    _0 = 0,
    _1 = 1,
}

export enum SchemaSerializationMode {
    _1 = 1,
    _2 = 2,
}

export class SortVersion implements ISortVersion {
    readonly fullVersion: number;
    readonly sortId: string;

    constructor(data?: ISortVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).fullVersion = _data["fullVersion"];
            (<any>this).sortId = _data["sortId"];
        }
    }

    static fromJS(data: any): SortVersion {
        data = typeof data === 'object' ? data : {};
        let result = new SortVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullVersion"] = this.fullVersion;
        data["sortId"] = this.sortId;
        return data;
    }

    clone(): SortVersion {
        const json = this.toJSON();
        let result = new SortVersion();
        result.init(json);
        return result;
    }
}

export interface ISortVersion {
    fullVersion: number;
    sortId: string;
}

export class CompareInfo implements ICompareInfo {
    readonly name: string | undefined;
    version: SortVersion;
    readonly lcid: number;

    constructor(data?: ICompareInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.version = _data["version"] ? SortVersion.fromJS(_data["version"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
        }
    }

    static fromJS(data: any): CompareInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CompareInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        return data;
    }

    clone(): CompareInfo {
        const json = this.toJSON();
        let result = new CompareInfo();
        result.init(json);
        return result;
    }
}

export interface ICompareInfo {
    name: string | undefined;
    version: SortVersion;
    lcid: number;
}

export class TextInfo implements ITextInfo {
    readonly ansiCodePage: number;
    readonly oemCodePage: number;
    readonly macCodePage: number;
    readonly ebcdicCodePage: number;
    readonly lcid: number;
    readonly cultureName: string | undefined;
    readonly isReadOnly: boolean;
    listSeparator: string | undefined;
    readonly isRightToLeft: boolean;

    constructor(data?: ITextInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ansiCodePage = _data["ansiCodePage"];
            (<any>this).oemCodePage = _data["oemCodePage"];
            (<any>this).macCodePage = _data["macCodePage"];
            (<any>this).ebcdicCodePage = _data["ebcdicCodePage"];
            (<any>this).lcid = _data["lcid"];
            (<any>this).cultureName = _data["cultureName"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            this.listSeparator = _data["listSeparator"];
            (<any>this).isRightToLeft = _data["isRightToLeft"];
        }
    }

    static fromJS(data: any): TextInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TextInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ansiCodePage"] = this.ansiCodePage;
        data["oemCodePage"] = this.oemCodePage;
        data["macCodePage"] = this.macCodePage;
        data["ebcdicCodePage"] = this.ebcdicCodePage;
        data["lcid"] = this.lcid;
        data["cultureName"] = this.cultureName;
        data["isReadOnly"] = this.isReadOnly;
        data["listSeparator"] = this.listSeparator;
        data["isRightToLeft"] = this.isRightToLeft;
        return data;
    }

    clone(): TextInfo {
        const json = this.toJSON();
        let result = new TextInfo();
        result.init(json);
        return result;
    }
}

export interface ITextInfo {
    ansiCodePage: number;
    oemCodePage: number;
    macCodePage: number;
    ebcdicCodePage: number;
    lcid: number;
    cultureName: string | undefined;
    isReadOnly: boolean;
    listSeparator: string | undefined;
    isRightToLeft: boolean;
}

export enum CultureTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
}

export enum DigitShapes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class NumberFormatInfo implements INumberFormatInfo {
    currencyDecimalDigits: number;
    currencyDecimalSeparator: string | undefined;
    readonly isReadOnly: boolean;
    currencyGroupSizes: number[] | undefined;
    numberGroupSizes: number[] | undefined;
    percentGroupSizes: number[] | undefined;
    currencyGroupSeparator: string | undefined;
    currencySymbol: string | undefined;
    naNSymbol: string | undefined;
    currencyNegativePattern: number;
    numberNegativePattern: number;
    percentPositivePattern: number;
    percentNegativePattern: number;
    negativeInfinitySymbol: string | undefined;
    negativeSign: string | undefined;
    numberDecimalDigits: number;
    numberDecimalSeparator: string | undefined;
    numberGroupSeparator: string | undefined;
    currencyPositivePattern: number;
    positiveInfinitySymbol: string | undefined;
    positiveSign: string | undefined;
    percentDecimalDigits: number;
    percentDecimalSeparator: string | undefined;
    percentGroupSeparator: string | undefined;
    percentSymbol: string | undefined;
    perMilleSymbol: string | undefined;
    nativeDigits: string[] | undefined;
    digitSubstitution: DigitShapes;

    constructor(data?: INumberFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyDecimalDigits = _data["currencyDecimalDigits"];
            this.currencyDecimalSeparator = _data["currencyDecimalSeparator"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["currencyGroupSizes"])) {
                this.currencyGroupSizes = [] as any;
                for (let item of _data["currencyGroupSizes"])
                    this.currencyGroupSizes.push(item);
            }
            if (Array.isArray(_data["numberGroupSizes"])) {
                this.numberGroupSizes = [] as any;
                for (let item of _data["numberGroupSizes"])
                    this.numberGroupSizes.push(item);
            }
            if (Array.isArray(_data["percentGroupSizes"])) {
                this.percentGroupSizes = [] as any;
                for (let item of _data["percentGroupSizes"])
                    this.percentGroupSizes.push(item);
            }
            this.currencyGroupSeparator = _data["currencyGroupSeparator"];
            this.currencySymbol = _data["currencySymbol"];
            this.naNSymbol = _data["naNSymbol"];
            this.currencyNegativePattern = _data["currencyNegativePattern"];
            this.numberNegativePattern = _data["numberNegativePattern"];
            this.percentPositivePattern = _data["percentPositivePattern"];
            this.percentNegativePattern = _data["percentNegativePattern"];
            this.negativeInfinitySymbol = _data["negativeInfinitySymbol"];
            this.negativeSign = _data["negativeSign"];
            this.numberDecimalDigits = _data["numberDecimalDigits"];
            this.numberDecimalSeparator = _data["numberDecimalSeparator"];
            this.numberGroupSeparator = _data["numberGroupSeparator"];
            this.currencyPositivePattern = _data["currencyPositivePattern"];
            this.positiveInfinitySymbol = _data["positiveInfinitySymbol"];
            this.positiveSign = _data["positiveSign"];
            this.percentDecimalDigits = _data["percentDecimalDigits"];
            this.percentDecimalSeparator = _data["percentDecimalSeparator"];
            this.percentGroupSeparator = _data["percentGroupSeparator"];
            this.percentSymbol = _data["percentSymbol"];
            this.perMilleSymbol = _data["perMilleSymbol"];
            if (Array.isArray(_data["nativeDigits"])) {
                this.nativeDigits = [] as any;
                for (let item of _data["nativeDigits"])
                    this.nativeDigits.push(item);
            }
            this.digitSubstitution = _data["digitSubstitution"];
        }
    }

    static fromJS(data: any): NumberFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NumberFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyDecimalDigits"] = this.currencyDecimalDigits;
        data["currencyDecimalSeparator"] = this.currencyDecimalSeparator;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.currencyGroupSizes)) {
            data["currencyGroupSizes"] = [];
            for (let item of this.currencyGroupSizes)
                data["currencyGroupSizes"].push(item);
        }
        if (Array.isArray(this.numberGroupSizes)) {
            data["numberGroupSizes"] = [];
            for (let item of this.numberGroupSizes)
                data["numberGroupSizes"].push(item);
        }
        if (Array.isArray(this.percentGroupSizes)) {
            data["percentGroupSizes"] = [];
            for (let item of this.percentGroupSizes)
                data["percentGroupSizes"].push(item);
        }
        data["currencyGroupSeparator"] = this.currencyGroupSeparator;
        data["currencySymbol"] = this.currencySymbol;
        data["naNSymbol"] = this.naNSymbol;
        data["currencyNegativePattern"] = this.currencyNegativePattern;
        data["numberNegativePattern"] = this.numberNegativePattern;
        data["percentPositivePattern"] = this.percentPositivePattern;
        data["percentNegativePattern"] = this.percentNegativePattern;
        data["negativeInfinitySymbol"] = this.negativeInfinitySymbol;
        data["negativeSign"] = this.negativeSign;
        data["numberDecimalDigits"] = this.numberDecimalDigits;
        data["numberDecimalSeparator"] = this.numberDecimalSeparator;
        data["numberGroupSeparator"] = this.numberGroupSeparator;
        data["currencyPositivePattern"] = this.currencyPositivePattern;
        data["positiveInfinitySymbol"] = this.positiveInfinitySymbol;
        data["positiveSign"] = this.positiveSign;
        data["percentDecimalDigits"] = this.percentDecimalDigits;
        data["percentDecimalSeparator"] = this.percentDecimalSeparator;
        data["percentGroupSeparator"] = this.percentGroupSeparator;
        data["percentSymbol"] = this.percentSymbol;
        data["perMilleSymbol"] = this.perMilleSymbol;
        if (Array.isArray(this.nativeDigits)) {
            data["nativeDigits"] = [];
            for (let item of this.nativeDigits)
                data["nativeDigits"].push(item);
        }
        data["digitSubstitution"] = this.digitSubstitution;
        return data;
    }

    clone(): NumberFormatInfo {
        const json = this.toJSON();
        let result = new NumberFormatInfo();
        result.init(json);
        return result;
    }
}

export interface INumberFormatInfo {
    currencyDecimalDigits: number;
    currencyDecimalSeparator: string | undefined;
    isReadOnly: boolean;
    currencyGroupSizes: number[] | undefined;
    numberGroupSizes: number[] | undefined;
    percentGroupSizes: number[] | undefined;
    currencyGroupSeparator: string | undefined;
    currencySymbol: string | undefined;
    naNSymbol: string | undefined;
    currencyNegativePattern: number;
    numberNegativePattern: number;
    percentPositivePattern: number;
    percentNegativePattern: number;
    negativeInfinitySymbol: string | undefined;
    negativeSign: string | undefined;
    numberDecimalDigits: number;
    numberDecimalSeparator: string | undefined;
    numberGroupSeparator: string | undefined;
    currencyPositivePattern: number;
    positiveInfinitySymbol: string | undefined;
    positiveSign: string | undefined;
    percentDecimalDigits: number;
    percentDecimalSeparator: string | undefined;
    percentGroupSeparator: string | undefined;
    percentSymbol: string | undefined;
    perMilleSymbol: string | undefined;
    nativeDigits: string[] | undefined;
    digitSubstitution: DigitShapes;
}

export enum CalendarAlgorithmType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Calendar implements ICalendar {
    readonly minSupportedDateTime: moment.Moment;
    readonly maxSupportedDateTime: moment.Moment;
    algorithmType: CalendarAlgorithmType;
    readonly isReadOnly: boolean;
    readonly eras: number[] | undefined;
    twoDigitYearMax: number;

    constructor(data?: ICalendar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).minSupportedDateTime = _data["minSupportedDateTime"] ? moment(_data["minSupportedDateTime"].toString()) : <any>undefined;
            (<any>this).maxSupportedDateTime = _data["maxSupportedDateTime"] ? moment(_data["maxSupportedDateTime"].toString()) : <any>undefined;
            this.algorithmType = _data["algorithmType"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["eras"])) {
                (<any>this).eras = [] as any;
                for (let item of _data["eras"])
                    (<any>this).eras.push(item);
            }
            this.twoDigitYearMax = _data["twoDigitYearMax"];
        }
    }

    static fromJS(data: any): Calendar {
        data = typeof data === 'object' ? data : {};
        let result = new Calendar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minSupportedDateTime"] = this.minSupportedDateTime ? this.minSupportedDateTime.toISOString() : <any>undefined;
        data["maxSupportedDateTime"] = this.maxSupportedDateTime ? this.maxSupportedDateTime.toISOString() : <any>undefined;
        data["algorithmType"] = this.algorithmType;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.eras)) {
            data["eras"] = [];
            for (let item of this.eras)
                data["eras"].push(item);
        }
        data["twoDigitYearMax"] = this.twoDigitYearMax;
        return data;
    }

    clone(): Calendar {
        const json = this.toJSON();
        let result = new Calendar();
        result.init(json);
        return result;
    }
}

export interface ICalendar {
    minSupportedDateTime: moment.Moment;
    maxSupportedDateTime: moment.Moment;
    algorithmType: CalendarAlgorithmType;
    isReadOnly: boolean;
    eras: number[] | undefined;
    twoDigitYearMax: number;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum CalendarWeekRule {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DateTimeFormatInfo implements IDateTimeFormatInfo {
    amDesignator: string | undefined;
    calendar: Calendar;
    dateSeparator: string | undefined;
    firstDayOfWeek: DayOfWeek;
    calendarWeekRule: CalendarWeekRule;
    fullDateTimePattern: string | undefined;
    longDatePattern: string | undefined;
    longTimePattern: string | undefined;
    monthDayPattern: string | undefined;
    pmDesignator: string | undefined;
    readonly rfC1123Pattern: string | undefined;
    shortDatePattern: string | undefined;
    shortTimePattern: string | undefined;
    readonly sortableDateTimePattern: string | undefined;
    timeSeparator: string | undefined;
    readonly universalSortableDateTimePattern: string | undefined;
    yearMonthPattern: string | undefined;
    abbreviatedDayNames: string[] | undefined;
    shortestDayNames: string[] | undefined;
    dayNames: string[] | undefined;
    abbreviatedMonthNames: string[] | undefined;
    monthNames: string[] | undefined;
    readonly isReadOnly: boolean;
    readonly nativeCalendarName: string | undefined;
    abbreviatedMonthGenitiveNames: string[] | undefined;
    monthGenitiveNames: string[] | undefined;

    constructor(data?: IDateTimeFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amDesignator = _data["amDesignator"];
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            this.dateSeparator = _data["dateSeparator"];
            this.firstDayOfWeek = _data["firstDayOfWeek"];
            this.calendarWeekRule = _data["calendarWeekRule"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.longDatePattern = _data["longDatePattern"];
            this.longTimePattern = _data["longTimePattern"];
            this.monthDayPattern = _data["monthDayPattern"];
            this.pmDesignator = _data["pmDesignator"];
            (<any>this).rfC1123Pattern = _data["rfC1123Pattern"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.shortTimePattern = _data["shortTimePattern"];
            (<any>this).sortableDateTimePattern = _data["sortableDateTimePattern"];
            this.timeSeparator = _data["timeSeparator"];
            (<any>this).universalSortableDateTimePattern = _data["universalSortableDateTimePattern"];
            this.yearMonthPattern = _data["yearMonthPattern"];
            if (Array.isArray(_data["abbreviatedDayNames"])) {
                this.abbreviatedDayNames = [] as any;
                for (let item of _data["abbreviatedDayNames"])
                    this.abbreviatedDayNames.push(item);
            }
            if (Array.isArray(_data["shortestDayNames"])) {
                this.shortestDayNames = [] as any;
                for (let item of _data["shortestDayNames"])
                    this.shortestDayNames.push(item);
            }
            if (Array.isArray(_data["dayNames"])) {
                this.dayNames = [] as any;
                for (let item of _data["dayNames"])
                    this.dayNames.push(item);
            }
            if (Array.isArray(_data["abbreviatedMonthNames"])) {
                this.abbreviatedMonthNames = [] as any;
                for (let item of _data["abbreviatedMonthNames"])
                    this.abbreviatedMonthNames.push(item);
            }
            if (Array.isArray(_data["monthNames"])) {
                this.monthNames = [] as any;
                for (let item of _data["monthNames"])
                    this.monthNames.push(item);
            }
            (<any>this).isReadOnly = _data["isReadOnly"];
            (<any>this).nativeCalendarName = _data["nativeCalendarName"];
            if (Array.isArray(_data["abbreviatedMonthGenitiveNames"])) {
                this.abbreviatedMonthGenitiveNames = [] as any;
                for (let item of _data["abbreviatedMonthGenitiveNames"])
                    this.abbreviatedMonthGenitiveNames.push(item);
            }
            if (Array.isArray(_data["monthGenitiveNames"])) {
                this.monthGenitiveNames = [] as any;
                for (let item of _data["monthGenitiveNames"])
                    this.monthGenitiveNames.push(item);
            }
        }
    }

    static fromJS(data: any): DateTimeFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amDesignator"] = this.amDesignator;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        data["dateSeparator"] = this.dateSeparator;
        data["firstDayOfWeek"] = this.firstDayOfWeek;
        data["calendarWeekRule"] = this.calendarWeekRule;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["longDatePattern"] = this.longDatePattern;
        data["longTimePattern"] = this.longTimePattern;
        data["monthDayPattern"] = this.monthDayPattern;
        data["pmDesignator"] = this.pmDesignator;
        data["rfC1123Pattern"] = this.rfC1123Pattern;
        data["shortDatePattern"] = this.shortDatePattern;
        data["shortTimePattern"] = this.shortTimePattern;
        data["sortableDateTimePattern"] = this.sortableDateTimePattern;
        data["timeSeparator"] = this.timeSeparator;
        data["universalSortableDateTimePattern"] = this.universalSortableDateTimePattern;
        data["yearMonthPattern"] = this.yearMonthPattern;
        if (Array.isArray(this.abbreviatedDayNames)) {
            data["abbreviatedDayNames"] = [];
            for (let item of this.abbreviatedDayNames)
                data["abbreviatedDayNames"].push(item);
        }
        if (Array.isArray(this.shortestDayNames)) {
            data["shortestDayNames"] = [];
            for (let item of this.shortestDayNames)
                data["shortestDayNames"].push(item);
        }
        if (Array.isArray(this.dayNames)) {
            data["dayNames"] = [];
            for (let item of this.dayNames)
                data["dayNames"].push(item);
        }
        if (Array.isArray(this.abbreviatedMonthNames)) {
            data["abbreviatedMonthNames"] = [];
            for (let item of this.abbreviatedMonthNames)
                data["abbreviatedMonthNames"].push(item);
        }
        if (Array.isArray(this.monthNames)) {
            data["monthNames"] = [];
            for (let item of this.monthNames)
                data["monthNames"].push(item);
        }
        data["isReadOnly"] = this.isReadOnly;
        data["nativeCalendarName"] = this.nativeCalendarName;
        if (Array.isArray(this.abbreviatedMonthGenitiveNames)) {
            data["abbreviatedMonthGenitiveNames"] = [];
            for (let item of this.abbreviatedMonthGenitiveNames)
                data["abbreviatedMonthGenitiveNames"].push(item);
        }
        if (Array.isArray(this.monthGenitiveNames)) {
            data["monthGenitiveNames"] = [];
            for (let item of this.monthGenitiveNames)
                data["monthGenitiveNames"].push(item);
        }
        return data;
    }

    clone(): DateTimeFormatInfo {
        const json = this.toJSON();
        let result = new DateTimeFormatInfo();
        result.init(json);
        return result;
    }
}

export interface IDateTimeFormatInfo {
    amDesignator: string | undefined;
    calendar: Calendar;
    dateSeparator: string | undefined;
    firstDayOfWeek: DayOfWeek;
    calendarWeekRule: CalendarWeekRule;
    fullDateTimePattern: string | undefined;
    longDatePattern: string | undefined;
    longTimePattern: string | undefined;
    monthDayPattern: string | undefined;
    pmDesignator: string | undefined;
    rfC1123Pattern: string | undefined;
    shortDatePattern: string | undefined;
    shortTimePattern: string | undefined;
    sortableDateTimePattern: string | undefined;
    timeSeparator: string | undefined;
    universalSortableDateTimePattern: string | undefined;
    yearMonthPattern: string | undefined;
    abbreviatedDayNames: string[] | undefined;
    shortestDayNames: string[] | undefined;
    dayNames: string[] | undefined;
    abbreviatedMonthNames: string[] | undefined;
    monthNames: string[] | undefined;
    isReadOnly: boolean;
    nativeCalendarName: string | undefined;
    abbreviatedMonthGenitiveNames: string[] | undefined;
    monthGenitiveNames: string[] | undefined;
}

export class CultureInfo implements ICultureInfo {
    parent: CultureInfo;
    readonly lcid: number;
    readonly keyboardLayoutId: number;
    readonly name: string | undefined;
    readonly ietfLanguageTag: string | undefined;
    readonly displayName: string | undefined;
    readonly nativeName: string | undefined;
    readonly englishName: string | undefined;
    readonly twoLetterISOLanguageName: string | undefined;
    readonly threeLetterISOLanguageName: string | undefined;
    readonly threeLetterWindowsLanguageName: string | undefined;
    compareInfo: CompareInfo;
    textInfo: TextInfo;
    readonly isNeutralCulture: boolean;
    cultureTypes: CultureTypes;
    numberFormat: NumberFormatInfo;
    dateTimeFormat: DateTimeFormatInfo;
    calendar: Calendar;
    readonly optionalCalendars: Calendar[] | undefined;
    readonly useUserOverride: boolean;
    readonly isReadOnly: boolean;

    constructor(data?: ICultureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"] ? CultureInfo.fromJS(_data["parent"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
            (<any>this).keyboardLayoutId = _data["keyboardLayoutId"];
            (<any>this).name = _data["name"];
            (<any>this).ietfLanguageTag = _data["ietfLanguageTag"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).nativeName = _data["nativeName"];
            (<any>this).englishName = _data["englishName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            (<any>this).threeLetterISOLanguageName = _data["threeLetterISOLanguageName"];
            (<any>this).threeLetterWindowsLanguageName = _data["threeLetterWindowsLanguageName"];
            this.compareInfo = _data["compareInfo"] ? CompareInfo.fromJS(_data["compareInfo"]) : <any>undefined;
            this.textInfo = _data["textInfo"] ? TextInfo.fromJS(_data["textInfo"]) : <any>undefined;
            (<any>this).isNeutralCulture = _data["isNeutralCulture"];
            this.cultureTypes = _data["cultureTypes"];
            this.numberFormat = _data["numberFormat"] ? NumberFormatInfo.fromJS(_data["numberFormat"]) : <any>undefined;
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatInfo.fromJS(_data["dateTimeFormat"]) : <any>undefined;
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            if (Array.isArray(_data["optionalCalendars"])) {
                (<any>this).optionalCalendars = [] as any;
                for (let item of _data["optionalCalendars"])
                    (<any>this).optionalCalendars.push(Calendar.fromJS(item));
            }
            (<any>this).useUserOverride = _data["useUserOverride"];
            (<any>this).isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): CultureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CultureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        data["keyboardLayoutId"] = this.keyboardLayoutId;
        data["name"] = this.name;
        data["ietfLanguageTag"] = this.ietfLanguageTag;
        data["displayName"] = this.displayName;
        data["nativeName"] = this.nativeName;
        data["englishName"] = this.englishName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["threeLetterISOLanguageName"] = this.threeLetterISOLanguageName;
        data["threeLetterWindowsLanguageName"] = this.threeLetterWindowsLanguageName;
        data["compareInfo"] = this.compareInfo ? this.compareInfo.toJSON() : <any>undefined;
        data["textInfo"] = this.textInfo ? this.textInfo.toJSON() : <any>undefined;
        data["isNeutralCulture"] = this.isNeutralCulture;
        data["cultureTypes"] = this.cultureTypes;
        data["numberFormat"] = this.numberFormat ? this.numberFormat.toJSON() : <any>undefined;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        if (Array.isArray(this.optionalCalendars)) {
            data["optionalCalendars"] = [];
            for (let item of this.optionalCalendars)
                data["optionalCalendars"].push(item.toJSON());
        }
        data["useUserOverride"] = this.useUserOverride;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }

    clone(): CultureInfo {
        const json = this.toJSON();
        let result = new CultureInfo();
        result.init(json);
        return result;
    }
}

export interface ICultureInfo {
    parent: CultureInfo;
    lcid: number;
    keyboardLayoutId: number;
    name: string | undefined;
    ietfLanguageTag: string | undefined;
    displayName: string | undefined;
    nativeName: string | undefined;
    englishName: string | undefined;
    twoLetterISOLanguageName: string | undefined;
    threeLetterISOLanguageName: string | undefined;
    threeLetterWindowsLanguageName: string | undefined;
    compareInfo: CompareInfo;
    textInfo: TextInfo;
    isNeutralCulture: boolean;
    cultureTypes: CultureTypes;
    numberFormat: NumberFormatInfo;
    dateTimeFormat: DateTimeFormatInfo;
    calendar: Calendar;
    optionalCalendars: Calendar[] | undefined;
    useUserOverride: boolean;
    isReadOnly: boolean;
}

export class IComponent implements IIComponent {
    site: ISite;

    constructor(data?: IIComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IComponent {
        data = typeof data === 'object' ? data : {};
        let result = new IComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }

    clone(): IComponent {
        const json = this.toJSON();
        let result = new IComponent();
        result.init(json);
        return result;
    }
}

export interface IIComponent {
    site: ISite;
}

export class IContainer implements IIContainer {
    readonly components: any[] | undefined;

    constructor(data?: IIContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["components"])
                    (<any>this).components.push(item);
            }
        }
    }

    static fromJS(data: any): IContainer {
        data = typeof data === 'object' ? data : {};
        let result = new IContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item);
        }
        return data;
    }

    clone(): IContainer {
        const json = this.toJSON();
        let result = new IContainer();
        result.init(json);
        return result;
    }
}

export interface IIContainer {
    components: any[] | undefined;
}

export class ISite implements IISite {
    component: IComponent;
    container: IContainer;
    readonly designMode: boolean;
    name: string | undefined;

    constructor(data?: IISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.component = _data["component"] ? IComponent.fromJS(_data["component"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ISite {
        data = typeof data === 'object' ? data : {};
        let result = new ISite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        data["name"] = this.name;
        return data;
    }

    clone(): ISite {
        const json = this.toJSON();
        let result = new ISite();
        result.init(json);
        return result;
    }
}

export interface IISite {
    component: IComponent;
    container: IContainer;
    designMode: boolean;
    name: string | undefined;
}

export class DataSet implements IDataSet {
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    caseSensitive: boolean;
    readonly defaultViewManager: any[] | undefined;
    enforceConstraints: boolean;
    dataSetName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    site: ISite;
    readonly relations: any[] | undefined;
    readonly tables: any[] | undefined;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.caseSensitive = false;
            this.enforceConstraints = true;
            this.dataSetName = "";
            this.namespace = "";
            this.prefix = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remotingFormat = _data["remotingFormat"];
            this.schemaSerializationMode = _data["schemaSerializationMode"];
            this.caseSensitive = _data["caseSensitive"] !== undefined ? _data["caseSensitive"] : false;
            if (Array.isArray(_data["defaultViewManager"])) {
                (<any>this).defaultViewManager = [] as any;
                for (let item of _data["defaultViewManager"])
                    (<any>this).defaultViewManager.push(item);
            }
            this.enforceConstraints = _data["enforceConstraints"] !== undefined ? _data["enforceConstraints"] : true;
            this.dataSetName = _data["dataSetName"] !== undefined ? _data["dataSetName"] : "";
            this.namespace = _data["namespace"] !== undefined ? _data["namespace"] : "";
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)[key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.locale = _data["locale"] ? CultureInfo.fromJS(_data["locale"]) : <any>undefined;
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            if (Array.isArray(_data["relations"])) {
                (<any>this).relations = [] as any;
                for (let item of _data["relations"])
                    (<any>this).relations.push(item);
            }
            if (Array.isArray(_data["tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["tables"])
                    (<any>this).tables.push(item);
            }
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataSet {
        data = typeof data === 'object' ? data : {};
        let result = new DataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remotingFormat"] = this.remotingFormat;
        data["schemaSerializationMode"] = this.schemaSerializationMode;
        data["caseSensitive"] = this.caseSensitive;
        if (Array.isArray(this.defaultViewManager)) {
            data["defaultViewManager"] = [];
            for (let item of this.defaultViewManager)
                data["defaultViewManager"].push(item);
        }
        data["enforceConstraints"] = this.enforceConstraints;
        data["dataSetName"] = this.dataSetName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["isInitialized"] = this.isInitialized;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item);
        }
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item);
        }
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }

    clone(): DataSet {
        const json = this.toJSON();
        let result = new DataSet();
        result.init(json);
        return result;
    }
}

export interface IDataSet {
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    caseSensitive: boolean;
    defaultViewManager: any[] | undefined;
    enforceConstraints: boolean;
    dataSetName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    hasErrors: boolean;
    isInitialized: boolean;
    locale: CultureInfo;
    site: ISite;
    relations: any[] | undefined;
    tables: any[] | undefined;
    container: IContainer;
    designMode: boolean;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): IntPtr {
        const json = this.toJSON();
        let result = new IntPtr();
        result.init(json);
        return result;
    }
}

export interface IIntPtr {
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeMethodHandle {
        const json = this.toJSON();
        let result = new RuntimeMethodHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeMethodHandle {
    value: IntPtr;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }

    clone(): ModuleHandle {
        const json = this.toJSON();
        let result = new ModuleHandle();
        result.init(json);
        return result;
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType: Type;
    readonly value: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }

    clone(): CustomAttributeTypedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeTypedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: Type;
    value: any | undefined;
}

export class MemberInfo implements IMemberInfo {
    memberType: MemberTypes;
    declaringType: Type;
    reflectedType: Type;
    readonly name: string | undefined;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): MemberInfo {
        const json = this.toJSON();
        let result = new MemberInfo();
        result.init(json);
        return result;
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    declaringType: Type;
    reflectedType: Type;
    name: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    readonly memberName: string | undefined;
    readonly isField: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }

    clone(): CustomAttributeNamedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeNamedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string | undefined;
    isField: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType: Type;
    constructor_: ConstructorInfo;
    readonly constructorArguments: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustomAttributeData {
        const json = this.toJSON();
        let result = new CustomAttributeData();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeData {
    attributeType: Type;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[] | undefined;
    namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export class Module implements IModule {
    assembly: Assembly;
    readonly fullyQualifiedName: string | undefined;
    readonly name: string | undefined;
    readonly mdStreamVersion: number;
    readonly moduleVersionId: string;
    readonly scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly metadataToken: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): Module {
        const json = this.toJSON();
        let result = new Module();
        result.init(json);
        return result;
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string | undefined;
    name: string | undefined;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ConstructorInfo implements IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): ConstructorInfo {
        const json = this.toJSON();
        let result = new ConstructorInfo();
        result.init(json);
        return result;
    }
}

export interface IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    readonly name: string | undefined;
    parameterType: Type;
    readonly position: number;
    readonly isIn: boolean;
    readonly isLcid: boolean;
    readonly isOptional: boolean;
    readonly isOut: boolean;
    readonly isRetval: boolean;
    readonly defaultValue: any | undefined;
    readonly rawDefaultValue: any | undefined;
    readonly hasDefaultValue: boolean;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly metadataToken: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): ParameterInfo {
        const json = this.toJSON();
        let result = new ParameterInfo();
        result.init(json);
        return result;
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | undefined;
    parameterType: Type;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | undefined;
    rawDefaultValue: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): ICustomAttributeProvider {
        const json = this.toJSON();
        let result = new ICustomAttributeProvider();
        result.init(json);
        return result;
    }
}

export interface IICustomAttributeProvider {
}

export class MethodInfo implements IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: Type;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): MethodInfo {
        const json = this.toJSON();
        let result = new MethodInfo();
        result.init(json);
        return result;
    }
}

export interface IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: Type;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class EventInfo implements IEventInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    readonly isSpecialName: boolean;
    addMethod: MethodInfo;
    removeMethod: MethodInfo;
    raiseMethod: MethodInfo;
    readonly isMulticast: boolean;
    eventHandlerType: Type;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): EventInfo {
        const json = this.toJSON();
        let result = new EventInfo();
        result.init(json);
        return result;
    }
}

export interface IEventInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    isSpecialName: boolean;
    addMethod: MethodInfo;
    removeMethod: MethodInfo;
    raiseMethod: MethodInfo;
    isMulticast: boolean;
    eventHandlerType: Type;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeFieldHandle {
        const json = this.toJSON();
        let result = new RuntimeFieldHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeFieldHandle {
    value: IntPtr;
}

export class FieldInfo implements IFieldInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: Type;
    readonly isInitOnly: boolean;
    readonly isLiteral: boolean;
    readonly isNotSerialized: boolean;
    readonly isPinvokeImpl: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): FieldInfo {
        const json = this.toJSON();
        let result = new FieldInfo();
        result.init(json);
        return result;
    }
}

export interface IFieldInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: Type;
    isInitOnly: boolean;
    isLiteral: boolean;
    isNotSerialized: boolean;
    isPinvokeImpl: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    memberType: MemberTypes;
    propertyType: Type;
    attributes: PropertyAttributes;
    readonly isSpecialName: boolean;
    readonly canRead: boolean;
    readonly canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): PropertyInfo {
        const json = this.toJSON();
        let result = new PropertyInfo();
        result.init(json);
        return result;
    }
}

export interface IPropertyInfo {
    memberType: MemberTypes;
    propertyType: Type;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class MethodBase implements IMethodBase {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    memberType: MemberTypes;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): MethodBase {
        const json = this.toJSON();
        let result = new MethodBase();
        result.init(json);
        return result;
    }
}

export interface IMethodBase {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    value: LayoutKind;
    readonly typeId: any | undefined;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["typeId"] = this.typeId;
        return data;
    }

    clone(): StructLayoutAttribute {
        const json = this.toJSON();
        let result = new StructLayoutAttribute();
        result.init(json);
        return result;
    }
}

export interface IStructLayoutAttribute {
    value: LayoutKind;
    typeId: any | undefined;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }

    clone(): RuntimeTypeHandle {
        const json = this.toJSON();
        let result = new RuntimeTypeHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeTypeHandle {
    value: IntPtr;
}

export class TypeInfo implements ITypeInfo {
    readonly genericTypeParameters: Type[] | undefined;
    readonly declaredConstructors: ConstructorInfo[] | undefined;
    readonly declaredEvents: EventInfo[] | undefined;
    readonly declaredFields: FieldInfo[] | undefined;
    readonly declaredMembers: MemberInfo[] | undefined;
    readonly declaredMethods: MethodInfo[] | undefined;
    readonly declaredNestedTypes: TypeInfo[] | undefined;
    readonly declaredProperties: PropertyInfo[] | undefined;
    readonly implementedInterfaces: Type[] | undefined;
    readonly isInterface: boolean;
    memberType: MemberTypes;
    readonly namespace: string | undefined;
    readonly assemblyQualifiedName: string | undefined;
    readonly fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    readonly isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    readonly isTypeDefinition: boolean;
    readonly isArray: boolean;
    readonly isByRef: boolean;
    readonly isPointer: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isGenericParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericType: boolean;
    readonly isGenericTypeDefinition: boolean;
    readonly isSZArray: boolean;
    readonly isVariableBoundArray: boolean;
    readonly isByRefLike: boolean;
    readonly hasElementType: boolean;
    readonly genericTypeArguments: Type[] | undefined;
    readonly genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    readonly isAbstract: boolean;
    readonly isImport: boolean;
    readonly isSealed: boolean;
    readonly isSpecialName: boolean;
    readonly isClass: boolean;
    readonly isNestedAssembly: boolean;
    readonly isNestedFamANDAssem: boolean;
    readonly isNestedFamily: boolean;
    readonly isNestedFamORAssem: boolean;
    readonly isNestedPrivate: boolean;
    readonly isNestedPublic: boolean;
    readonly isNotPublic: boolean;
    readonly isPublic: boolean;
    readonly isAutoLayout: boolean;
    readonly isExplicitLayout: boolean;
    readonly isLayoutSequential: boolean;
    readonly isAnsiClass: boolean;
    readonly isAutoClass: boolean;
    readonly isUnicodeClass: boolean;
    readonly isCOMObject: boolean;
    readonly isContextful: boolean;
    readonly isEnum: boolean;
    readonly isMarshalByRef: boolean;
    readonly isPrimitive: boolean;
    readonly isValueType: boolean;
    readonly isSignatureType: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    readonly guid: string;
    baseType: Type;
    readonly isSerializable: boolean;
    readonly containsGenericParameters: boolean;
    readonly isVisible: boolean;
    readonly name: string | undefined;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces.push(Type.fromJS(item));
            }
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): TypeInfo {
        const json = this.toJSON();
        let result = new TypeInfo();
        result.init(json);
        return result;
    }
}

export interface ITypeInfo {
    genericTypeParameters: Type[] | undefined;
    declaredConstructors: ConstructorInfo[] | undefined;
    declaredEvents: EventInfo[] | undefined;
    declaredFields: FieldInfo[] | undefined;
    declaredMembers: MemberInfo[] | undefined;
    declaredMethods: MethodInfo[] | undefined;
    declaredNestedTypes: TypeInfo[] | undefined;
    declaredProperties: PropertyInfo[] | undefined;
    implementedInterfaces: Type[] | undefined;
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Assembly implements IAssembly {
    readonly definedTypes: TypeInfo[] | undefined;
    readonly exportedTypes: Type[] | undefined;
    readonly codeBase: string | undefined;
    entryPoint: MethodInfo;
    readonly fullName: string | undefined;
    readonly imageRuntimeVersion: string | undefined;
    readonly isDynamic: boolean;
    readonly location: string | undefined;
    readonly reflectionOnly: boolean;
    readonly isCollectible: boolean;
    readonly isFullyTrusted: boolean;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly escapedCodeBase: string | undefined;
    manifestModule: Module;
    readonly modules: Module[] | undefined;
    readonly globalAssemblyCache: boolean;
    readonly hostContext: number;
    securityRuleSet: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }

    clone(): Assembly {
        const json = this.toJSON();
        let result = new Assembly();
        result.init(json);
        return result;
    }
}

export interface IAssembly {
    definedTypes: TypeInfo[] | undefined;
    exportedTypes: Type[] | undefined;
    codeBase: string | undefined;
    entryPoint: MethodInfo;
    fullName: string | undefined;
    imageRuntimeVersion: string | undefined;
    isDynamic: boolean;
    location: string | undefined;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    escapedCodeBase: string | undefined;
    manifestModule: Module;
    modules: Module[] | undefined;
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class Type implements IType {
    readonly isInterface: boolean;
    memberType: MemberTypes;
    readonly namespace: string | undefined;
    readonly assemblyQualifiedName: string | undefined;
    readonly fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    readonly isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    readonly isTypeDefinition: boolean;
    readonly isArray: boolean;
    readonly isByRef: boolean;
    readonly isPointer: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isGenericParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericType: boolean;
    readonly isGenericTypeDefinition: boolean;
    readonly isSZArray: boolean;
    readonly isVariableBoundArray: boolean;
    readonly isByRefLike: boolean;
    readonly hasElementType: boolean;
    readonly genericTypeArguments: Type[] | undefined;
    readonly genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    readonly isAbstract: boolean;
    readonly isImport: boolean;
    readonly isSealed: boolean;
    readonly isSpecialName: boolean;
    readonly isClass: boolean;
    readonly isNestedAssembly: boolean;
    readonly isNestedFamANDAssem: boolean;
    readonly isNestedFamily: boolean;
    readonly isNestedFamORAssem: boolean;
    readonly isNestedPrivate: boolean;
    readonly isNestedPublic: boolean;
    readonly isNotPublic: boolean;
    readonly isPublic: boolean;
    readonly isAutoLayout: boolean;
    readonly isExplicitLayout: boolean;
    readonly isLayoutSequential: boolean;
    readonly isAnsiClass: boolean;
    readonly isAutoClass: boolean;
    readonly isUnicodeClass: boolean;
    readonly isCOMObject: boolean;
    readonly isContextful: boolean;
    readonly isEnum: boolean;
    readonly isMarshalByRef: boolean;
    readonly isPrimitive: boolean;
    readonly isValueType: boolean;
    readonly isSignatureType: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    readonly guid: string;
    baseType: Type;
    readonly isSerializable: boolean;
    readonly containsGenericParameters: boolean;
    readonly isVisible: boolean;
    readonly name: string | undefined;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }

    clone(): Type {
        const json = this.toJSON();
        let result = new Type();
        result.init(json);
        return result;
    }
}

export interface IType {
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum DataSetDateTime {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum MappingType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DataColumn implements IDataColumn {
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: number;
    autoIncrementStep: number;
    caption: string | undefined;
    columnName: string | undefined;
    prefix: string | undefined;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: any | undefined;
    expression: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    maxLength: number;
    namespace: string | undefined;
    readonly ordinal: number;
    readOnly: boolean;
    table: DataTable;
    unique: boolean;
    columnMapping: MappingType;
    site: ISite;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.allowDBNull = true;
            this.autoIncrement = false;
            this.autoIncrementSeed = 0;
            this.autoIncrementStep = 1;
            this.columnName = "";
            this.prefix = "";
            this.expression = "";
            this.maxLength = -1;
            this.readOnly = false;
            this.unique = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowDBNull = _data["allowDBNull"] !== undefined ? _data["allowDBNull"] : true;
            this.autoIncrement = _data["autoIncrement"] !== undefined ? _data["autoIncrement"] : false;
            this.autoIncrementSeed = _data["autoIncrementSeed"] !== undefined ? _data["autoIncrementSeed"] : 0;
            this.autoIncrementStep = _data["autoIncrementStep"] !== undefined ? _data["autoIncrementStep"] : 1;
            this.caption = _data["caption"];
            this.columnName = _data["columnName"] !== undefined ? _data["columnName"] : "";
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            this.dataType = _data["dataType"] ? Type.fromJS(_data["dataType"]) : <any>undefined;
            this.dateTimeMode = _data["dateTimeMode"];
            this.defaultValue = _data["defaultValue"];
            this.expression = _data["expression"] !== undefined ? _data["expression"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)[key] = _data["extendedProperties"][key];
                }
            }
            this.maxLength = _data["maxLength"] !== undefined ? _data["maxLength"] : -1;
            this.namespace = _data["namespace"];
            (<any>this).ordinal = _data["ordinal"];
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : false;
            this.table = _data["table"] ? DataTable.fromJS(_data["table"]) : <any>undefined;
            this.unique = _data["unique"] !== undefined ? _data["unique"] : false;
            this.columnMapping = _data["columnMapping"];
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DataColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowDBNull"] = this.allowDBNull;
        data["autoIncrement"] = this.autoIncrement;
        data["autoIncrementSeed"] = this.autoIncrementSeed;
        data["autoIncrementStep"] = this.autoIncrementStep;
        data["caption"] = this.caption;
        data["columnName"] = this.columnName;
        data["prefix"] = this.prefix;
        data["dataType"] = this.dataType ? this.dataType.toJSON() : <any>undefined;
        data["dateTimeMode"] = this.dateTimeMode;
        data["defaultValue"] = this.defaultValue;
        data["expression"] = this.expression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["maxLength"] = this.maxLength;
        data["namespace"] = this.namespace;
        data["ordinal"] = this.ordinal;
        data["readOnly"] = this.readOnly;
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["unique"] = this.unique;
        data["columnMapping"] = this.columnMapping;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }

    clone(): DataColumn {
        const json = this.toJSON();
        let result = new DataColumn();
        result.init(json);
        return result;
    }
}

export interface IDataColumn {
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: number;
    autoIncrementStep: number;
    caption: string | undefined;
    columnName: string | undefined;
    prefix: string | undefined;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: any | undefined;
    expression: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    maxLength: number;
    namespace: string | undefined;
    ordinal: number;
    readOnly: boolean;
    table: DataTable;
    unique: boolean;
    columnMapping: MappingType;
    site: ISite;
    container: IContainer;
    designMode: boolean;
}

export class DataTable implements IDataTable {
    caseSensitive: boolean;
    readonly isInitialized: boolean;
    remotingFormat: SerializationFormat;
    readonly childRelations: any[] | undefined;
    readonly columns: any[] | undefined;
    readonly constraints: any[] | undefined;
    dataSet: DataSet;
    readonly defaultView: any[] | undefined;
    displayExpression: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    readonly hasErrors: boolean;
    locale: CultureInfo;
    minimumCapacity: number;
    readonly parentRelations: any[] | undefined;
    primaryKey: DataColumn[] | undefined;
    readonly rows: any[] | undefined;
    tableName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    site: ISite;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.displayExpression = "";
            this.minimumCapacity = 50;
            this.tableName = "";
            this.prefix = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseSensitive = _data["caseSensitive"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.remotingFormat = _data["remotingFormat"];
            if (Array.isArray(_data["childRelations"])) {
                (<any>this).childRelations = [] as any;
                for (let item of _data["childRelations"])
                    (<any>this).childRelations.push(item);
            }
            if (Array.isArray(_data["columns"])) {
                (<any>this).columns = [] as any;
                for (let item of _data["columns"])
                    (<any>this).columns.push(item);
            }
            if (Array.isArray(_data["constraints"])) {
                (<any>this).constraints = [] as any;
                for (let item of _data["constraints"])
                    (<any>this).constraints.push(item);
            }
            this.dataSet = _data["dataSet"] ? DataSet.fromJS(_data["dataSet"]) : <any>undefined;
            if (Array.isArray(_data["defaultView"])) {
                (<any>this).defaultView = [] as any;
                for (let item of _data["defaultView"])
                    (<any>this).defaultView.push(item);
            }
            this.displayExpression = _data["displayExpression"] !== undefined ? _data["displayExpression"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)[key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            this.locale = _data["locale"] ? CultureInfo.fromJS(_data["locale"]) : <any>undefined;
            this.minimumCapacity = _data["minimumCapacity"] !== undefined ? _data["minimumCapacity"] : 50;
            if (Array.isArray(_data["parentRelations"])) {
                (<any>this).parentRelations = [] as any;
                for (let item of _data["parentRelations"])
                    (<any>this).parentRelations.push(item);
            }
            if (Array.isArray(_data["primaryKey"])) {
                this.primaryKey = [] as any;
                for (let item of _data["primaryKey"])
                    this.primaryKey.push(DataColumn.fromJS(item));
            }
            if (Array.isArray(_data["rows"])) {
                (<any>this).rows = [] as any;
                for (let item of _data["rows"])
                    (<any>this).rows.push(item);
            }
            this.tableName = _data["tableName"] !== undefined ? _data["tableName"] : "";
            this.namespace = _data["namespace"];
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataTable {
        data = typeof data === 'object' ? data : {};
        let result = new DataTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseSensitive"] = this.caseSensitive;
        data["isInitialized"] = this.isInitialized;
        data["remotingFormat"] = this.remotingFormat;
        if (Array.isArray(this.childRelations)) {
            data["childRelations"] = [];
            for (let item of this.childRelations)
                data["childRelations"].push(item);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.constraints)) {
            data["constraints"] = [];
            for (let item of this.constraints)
                data["constraints"].push(item);
        }
        data["dataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultView)) {
            data["defaultView"] = [];
            for (let item of this.defaultView)
                data["defaultView"].push(item);
        }
        data["displayExpression"] = this.displayExpression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["minimumCapacity"] = this.minimumCapacity;
        if (Array.isArray(this.parentRelations)) {
            data["parentRelations"] = [];
            for (let item of this.parentRelations)
                data["parentRelations"].push(item);
        }
        if (Array.isArray(this.primaryKey)) {
            data["primaryKey"] = [];
            for (let item of this.primaryKey)
                data["primaryKey"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item);
        }
        data["tableName"] = this.tableName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }

    clone(): DataTable {
        const json = this.toJSON();
        let result = new DataTable();
        result.init(json);
        return result;
    }
}

export interface IDataTable {
    caseSensitive: boolean;
    isInitialized: boolean;
    remotingFormat: SerializationFormat;
    childRelations: any[] | undefined;
    columns: any[] | undefined;
    constraints: any[] | undefined;
    dataSet: DataSet;
    defaultView: any[] | undefined;
    displayExpression: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    hasErrors: boolean;
    locale: CultureInfo;
    minimumCapacity: number;
    parentRelations: any[] | undefined;
    primaryKey: DataColumn[] | undefined;
    rows: any[] | undefined;
    tableName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    site: ISite;
    container: IContainer;
    designMode: boolean;
}

export class SetfetchNewDto implements ISetfetchNewDto {
    columnName: DataTable;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: ISetfetchNewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"] ? DataTable.fromJS(_data["columnName"]) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SetfetchNewDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetfetchNewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName ? this.columnName.toJSON() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }

    clone(): SetfetchNewDto {
        const json = this.toJSON();
        let result = new SetfetchNewDto();
        result.init(json);
        return result;
    }
}

export interface ISetfetchNewDto {
    columnName: DataTable;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class SetfetchDto implements ISetfetchDto {
    tablE_CATALOG: string | undefined;
    tablE_SCHEMA: string | undefined;
    tablE_NAME: string | undefined;
    tablE_TYPE: string | undefined;
    allData: DataTable;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: ISetfetchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tablE_CATALOG = _data["tablE_CATALOG"];
            this.tablE_SCHEMA = _data["tablE_SCHEMA"];
            this.tablE_NAME = _data["tablE_NAME"];
            this.tablE_TYPE = _data["tablE_TYPE"];
            this.allData = _data["allData"] ? DataTable.fromJS(_data["allData"]) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): SetfetchDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetfetchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tablE_CATALOG"] = this.tablE_CATALOG;
        data["tablE_SCHEMA"] = this.tablE_SCHEMA;
        data["tablE_NAME"] = this.tablE_NAME;
        data["tablE_TYPE"] = this.tablE_TYPE;
        data["allData"] = this.allData ? this.allData.toJSON() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }

    clone(): SetfetchDto {
        const json = this.toJSON();
        let result = new SetfetchDto();
        result.init(json);
        return result;
    }
}

export interface ISetfetchDto {
    tablE_CATALOG: string | undefined;
    tablE_SCHEMA: string | undefined;
    tablE_NAME: string | undefined;
    tablE_TYPE: string | undefined;
    allData: DataTable;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ElogControlsDto implements IElogControlsDto {
    eLogId: number;
    controlID: number;
    controlLabel: string | undefined;
    controlType: string | undefined;
    controlDefaults: string | undefined;
    sequence: number;
    flagIsDefaultSql: boolean;
    dbFieldName: string | undefined;
    dbDataType: string | undefined;
    flagIsMandatory: boolean;
    isActive: boolean;
    id: number;

    constructor(data?: IElogControlsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eLogId = _data["eLogId"];
            this.controlID = _data["controlID"];
            this.controlLabel = _data["controlLabel"];
            this.controlType = _data["controlType"];
            this.controlDefaults = _data["controlDefaults"];
            this.sequence = _data["sequence"];
            this.flagIsDefaultSql = _data["flagIsDefaultSql"];
            this.dbFieldName = _data["dbFieldName"];
            this.dbDataType = _data["dbDataType"];
            this.flagIsMandatory = _data["flagIsMandatory"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ElogControlsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElogControlsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eLogId"] = this.eLogId;
        data["controlID"] = this.controlID;
        data["controlLabel"] = this.controlLabel;
        data["controlType"] = this.controlType;
        data["controlDefaults"] = this.controlDefaults;
        data["sequence"] = this.sequence;
        data["flagIsDefaultSql"] = this.flagIsDefaultSql;
        data["dbFieldName"] = this.dbFieldName;
        data["dbDataType"] = this.dbDataType;
        data["flagIsMandatory"] = this.flagIsMandatory;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ElogControlsDto {
        const json = this.toJSON();
        let result = new ElogControlsDto();
        result.init(json);
        return result;
    }
}

export interface IElogControlsDto {
    eLogId: number;
    controlID: number;
    controlLabel: string | undefined;
    controlType: string | undefined;
    controlDefaults: string | undefined;
    sequence: number;
    flagIsDefaultSql: boolean;
    dbFieldName: string | undefined;
    dbDataType: string | undefined;
    flagIsMandatory: boolean;
    isActive: boolean;
    id: number;
}

export class ElogControlsDtoPagedResultDto implements IElogControlsDtoPagedResultDto {
    totalCount: number;
    items: ElogControlsDto[] | undefined;

    constructor(data?: IElogControlsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ElogControlsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ElogControlsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElogControlsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ElogControlsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ElogControlsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IElogControlsDtoPagedResultDto {
    totalCount: number;
    items: ElogControlsDto[] | undefined;
}

export class Bin implements IBin {
    id: number;
    plantCode: string | undefined;
    binCode: string | undefined;
    description: string | undefined;
    active: boolean;

    constructor(data?: IBin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plantCode = _data["plantCode"];
            this.binCode = _data["binCode"];
            this.description = _data["description"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): Bin {
        data = typeof data === 'object' ? data : {};
        let result = new Bin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plantCode"] = this.plantCode;
        data["binCode"] = this.binCode;
        data["description"] = this.description;
        data["active"] = this.active;
        return data;
    }

    clone(): Bin {
        const json = this.toJSON();
        let result = new Bin();
        result.init(json);
        return result;
    }
}

export interface IBin {
    id: number;
    plantCode: string | undefined;
    binCode: string | undefined;
    description: string | undefined;
    active: boolean;
}

export class LineWorkBinMapping implements ILineWorkBinMapping {
    plantCode: string | undefined;
    userid: string | undefined;
    barcode: string | undefined;
    lineBarCode: string | undefined;

    constructor(data?: ILineWorkBinMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantCode = _data["plantCode"];
            this.userid = _data["userid"];
            this.barcode = _data["barcode"];
            this.lineBarCode = _data["lineBarCode"];
        }
    }

    static fromJS(data: any): LineWorkBinMapping {
        data = typeof data === 'object' ? data : {};
        let result = new LineWorkBinMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantCode"] = this.plantCode;
        data["userid"] = this.userid;
        data["barcode"] = this.barcode;
        data["lineBarCode"] = this.lineBarCode;
        return data;
    }

    clone(): LineWorkBinMapping {
        const json = this.toJSON();
        let result = new LineWorkBinMapping();
        result.init(json);
        return result;
    }
}

export interface ILineWorkBinMapping {
    plantCode: string | undefined;
    userid: string | undefined;
    barcode: string | undefined;
    lineBarCode: string | undefined;
}

export class GenerateSerialNumber implements IGenerateSerialNumber {
    id: number;
    plantCode: string | undefined;
    lineCode: string | undefined;
    packingOrderNo: string | undefined;
    supplierCode: string | undefined;
    driverCode: string | undefined;
    userId: string | undefined;
    quantity: number;
    printedQty: number;
    pendingQtyToPrint: number;
    packingDate: moment.Moment;
    itemCode: string | undefined;

    constructor(data?: IGenerateSerialNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plantCode = _data["plantCode"];
            this.lineCode = _data["lineCode"];
            this.packingOrderNo = _data["packingOrderNo"];
            this.supplierCode = _data["supplierCode"];
            this.driverCode = _data["driverCode"];
            this.userId = _data["userId"];
            this.quantity = _data["quantity"];
            this.printedQty = _data["printedQty"];
            this.pendingQtyToPrint = _data["pendingQtyToPrint"];
            this.packingDate = _data["packingDate"] ? moment(_data["packingDate"].toString()) : <any>undefined;
            this.itemCode = _data["itemCode"];
        }
    }

    static fromJS(data: any): GenerateSerialNumber {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateSerialNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plantCode"] = this.plantCode;
        data["lineCode"] = this.lineCode;
        data["packingOrderNo"] = this.packingOrderNo;
        data["supplierCode"] = this.supplierCode;
        data["driverCode"] = this.driverCode;
        data["userId"] = this.userId;
        data["quantity"] = this.quantity;
        data["printedQty"] = this.printedQty;
        data["pendingQtyToPrint"] = this.pendingQtyToPrint;
        data["packingDate"] = this.packingDate ? this.packingDate.toISOString() : <any>undefined;
        data["itemCode"] = this.itemCode;
        return data;
    }

    clone(): GenerateSerialNumber {
        const json = this.toJSON();
        let result = new GenerateSerialNumber();
        result.init(json);
        return result;
    }
}

export interface IGenerateSerialNumber {
    id: number;
    plantCode: string | undefined;
    lineCode: string | undefined;
    packingOrderNo: string | undefined;
    supplierCode: string | undefined;
    driverCode: string | undefined;
    userId: string | undefined;
    quantity: number;
    printedQty: number;
    pendingQtyToPrint: number;
    packingDate: moment.Moment;
    itemCode: string | undefined;
}

export class FormApprovalDataDto implements IFormApprovalDataDto {
    formId: number;
    status: number;
    remark: string | undefined;
    id: number;

    constructor(data?: IFormApprovalDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.status = _data["status"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormApprovalDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormApprovalDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["status"] = this.status;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data;
    }

    clone(): FormApprovalDataDto {
        const json = this.toJSON();
        let result = new FormApprovalDataDto();
        result.init(json);
        return result;
    }
}

export interface IFormApprovalDataDto {
    formId: number;
    status: number;
    remark: string | undefined;
    id: number;
}

export class FormApprovalDataDtoPagedResultDto implements IFormApprovalDataDtoPagedResultDto {
    totalCount: number;
    items: FormApprovalDataDto[] | undefined;

    constructor(data?: IFormApprovalDataDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormApprovalDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormApprovalDataDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormApprovalDataDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FormApprovalDataDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormApprovalDataDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormApprovalDataDtoPagedResultDto {
    totalCount: number;
    items: FormApprovalDataDto[] | undefined;
}

export class Connection implements IConnection {
    ipAddress: string;
    port: number;

    constructor(data?: IConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): Connection {
        data = typeof data === 'object' ? data : {};
        let result = new Connection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        return data;
    }

    clone(): Connection {
        const json = this.toJSON();
        let result = new Connection();
        result.init(json);
        return result;
    }
}

export interface IConnection {
    ipAddress: string;
    port: number;
}

export class LogAnalyticsDto implements ILogAnalyticsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment;
    formEndDate: moment.Moment;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment;
    modifiedDate: moment.Moment;
    formStatus: number;
    updatedBy: string | undefined;
    approvedBy: string | undefined;
    checkedBy: string | undefined;
    createdBy: string | undefined;
    approveDateTime: moment.Moment;
    id: number;

    constructor(data?: ILogAnalyticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.formName = _data["formName"];
            this.formStartDate = _data["formStartDate"] ? moment(_data["formStartDate"].toString()) : <any>undefined;
            this.formEndDate = _data["formEndDate"] ? moment(_data["formEndDate"].toString()) : <any>undefined;
            this.formJson = _data["formJson"];
            this.isActive = _data["isActive"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.formStatus = _data["formStatus"];
            this.updatedBy = _data["updatedBy"];
            this.approvedBy = _data["approvedBy"];
            this.checkedBy = _data["checkedBy"];
            this.createdBy = _data["createdBy"];
            this.approveDateTime = _data["approveDateTime"] ? moment(_data["approveDateTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LogAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["formName"] = this.formName;
        data["formStartDate"] = this.formStartDate ? this.formStartDate.toISOString() : <any>undefined;
        data["formEndDate"] = this.formEndDate ? this.formEndDate.toISOString() : <any>undefined;
        data["formJson"] = this.formJson;
        data["isActive"] = this.isActive;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["formStatus"] = this.formStatus;
        data["updatedBy"] = this.updatedBy;
        data["approvedBy"] = this.approvedBy;
        data["checkedBy"] = this.checkedBy;
        data["createdBy"] = this.createdBy;
        data["approveDateTime"] = this.approveDateTime ? this.approveDateTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): LogAnalyticsDto {
        const json = this.toJSON();
        let result = new LogAnalyticsDto();
        result.init(json);
        return result;
    }
}

export interface ILogAnalyticsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment;
    formEndDate: moment.Moment;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment;
    modifiedDate: moment.Moment;
    formStatus: number;
    updatedBy: string | undefined;
    approvedBy: string | undefined;
    checkedBy: string | undefined;
    createdBy: string | undefined;
    approveDateTime: moment.Moment;
    id: number;
}

export class LogAnalyticsDtoPagedResultDto implements ILogAnalyticsDtoPagedResultDto {
    totalCount: number;
    items: LogAnalyticsDto[] | undefined;

    constructor(data?: ILogAnalyticsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LogAnalyticsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogAnalyticsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogAnalyticsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LogAnalyticsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LogAnalyticsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILogAnalyticsDtoPagedResultDto {
    totalCount: number;
    items: LogAnalyticsDto[] | undefined;
}

export class LogAnalyticsListDto implements ILogAnalyticsListDto {
    count: number;
    totalActiveForm: number;
    totalInactiveForms: number;
    totalApprovalCount: number;
    totalDisApproveCount: number;
    logAnalytics: LogAnalyticsDto[] | undefined;

    constructor(data?: ILogAnalyticsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.totalActiveForm = _data["totalActiveForm"];
            this.totalInactiveForms = _data["totalInactiveForms"];
            this.totalApprovalCount = _data["totalApprovalCount"];
            this.totalDisApproveCount = _data["totalDisApproveCount"];
            if (Array.isArray(_data["logAnalytics"])) {
                this.logAnalytics = [] as any;
                for (let item of _data["logAnalytics"])
                    this.logAnalytics.push(LogAnalyticsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogAnalyticsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogAnalyticsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["totalActiveForm"] = this.totalActiveForm;
        data["totalInactiveForms"] = this.totalInactiveForms;
        data["totalApprovalCount"] = this.totalApprovalCount;
        data["totalDisApproveCount"] = this.totalDisApproveCount;
        if (Array.isArray(this.logAnalytics)) {
            data["logAnalytics"] = [];
            for (let item of this.logAnalytics)
                data["logAnalytics"].push(item.toJSON());
        }
        return data;
    }

    clone(): LogAnalyticsListDto {
        const json = this.toJSON();
        let result = new LogAnalyticsListDto();
        result.init(json);
        return result;
    }
}

export interface ILogAnalyticsListDto {
    count: number;
    totalActiveForm: number;
    totalInactiveForms: number;
    totalApprovalCount: number;
    totalDisApproveCount: number;
    logAnalytics: LogAnalyticsDto[] | undefined;
}

export class LogFormHistoryDto implements ILogFormHistoryDto {
    formId: number;
    remarks: string | undefined;
    status: number;
    id: number;

    constructor(data?: ILogFormHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.remarks = _data["remarks"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LogFormHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogFormHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["remarks"] = this.remarks;
        data["status"] = this.status;
        data["id"] = this.id;
        return data;
    }

    clone(): LogFormHistoryDto {
        const json = this.toJSON();
        let result = new LogFormHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ILogFormHistoryDto {
    formId: number;
    remarks: string | undefined;
    status: number;
    id: number;
}

export class LogFormHistoryDtoPagedResultDto implements ILogFormHistoryDtoPagedResultDto {
    totalCount: number;
    items: LogFormHistoryDto[] | undefined;

    constructor(data?: ILogFormHistoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LogFormHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogFormHistoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogFormHistoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LogFormHistoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LogFormHistoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILogFormHistoryDtoPagedResultDto {
    totalCount: number;
    items: LogFormHistoryDto[] | undefined;
}

export class LogsDataDto implements ILogsDataDto {
    action: string | undefined;
    createdTime: moment.Moment;
    data: string | undefined;
    createdBy: string | undefined;
    submodule: string | undefined;
    moduleName: string | undefined;
    id: number;

    constructor(data?: ILogsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
            this.data = _data["data"];
            this.createdBy = _data["createdBy"];
            this.submodule = _data["submodule"];
            this.moduleName = _data["moduleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LogsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["data"] = this.data;
        data["createdBy"] = this.createdBy;
        data["submodule"] = this.submodule;
        data["moduleName"] = this.moduleName;
        data["id"] = this.id;
        return data;
    }

    clone(): LogsDataDto {
        const json = this.toJSON();
        let result = new LogsDataDto();
        result.init(json);
        return result;
    }
}

export interface ILogsDataDto {
    action: string | undefined;
    createdTime: moment.Moment;
    data: string | undefined;
    createdBy: string | undefined;
    submodule: string | undefined;
    moduleName: string | undefined;
    id: number;
}

export class LogsDataDtoPagedResultDto implements ILogsDataDtoPagedResultDto {
    totalCount: number;
    items: LogsDataDto[] | undefined;

    constructor(data?: ILogsDataDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LogsDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogsDataDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogsDataDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LogsDataDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LogsDataDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILogsDataDtoPagedResultDto {
    totalCount: number;
    items: LogsDataDto[] | undefined;
}

export class ModuleListDto implements IModuleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IModuleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ModuleListDto {
        const json = this.toJSON();
        let result = new ModuleListDto();
        result.init(json);
        return result;
    }
}

export interface IModuleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ModuleListDtoPagedResultDto implements IModuleListDtoPagedResultDto {
    totalCount: number;
    items: ModuleListDto[] | undefined;

    constructor(data?: IModuleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ModuleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModuleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ModuleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IModuleListDtoPagedResultDto {
    totalCount: number;
    items: ModuleListDto[] | undefined;
}

export class SubModuleListDto implements ISubModuleListDto {
    name: string | undefined;
    moduleName: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    subModuleType: string | undefined;
    moduleId: number | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalRequired: string | undefined;
    id: number;

    constructor(data?: ISubModuleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.moduleName = _data["moduleName"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.subModuleType = _data["subModuleType"];
            this.moduleId = _data["moduleId"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalRequired = _data["userEnteredApprovalRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubModuleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["moduleName"] = this.moduleName;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["subModuleType"] = this.subModuleType;
        data["moduleId"] = this.moduleId;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalRequired"] = this.userEnteredApprovalRequired;
        data["id"] = this.id;
        return data;
    }

    clone(): SubModuleListDto {
        const json = this.toJSON();
        let result = new SubModuleListDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleListDto {
    name: string | undefined;
    moduleName: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    subModuleType: string | undefined;
    moduleId: number | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalRequired: string | undefined;
    id: number;
}

export class SubModuleListDtoPagedResultDto implements ISubModuleListDtoPagedResultDto {
    totalCount: number;
    items: SubModuleListDto[] | undefined;

    constructor(data?: ISubModuleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SubModuleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubModuleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubModuleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SubModuleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleListDtoPagedResultDto {
    totalCount: number;
    items: SubModuleListDto[] | undefined;
}

export class SubModuleDto implements ISubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    sequence: number;
    isActive: boolean;
    subModuleTypeId: number | undefined;
    isApprovalRequired: boolean;
    isApprovalWorkflowRequired: boolean;
    id: number;

    constructor(data?: ISubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSelected = _data["isSelected"];
            this.isMandatory = _data["isMandatory"];
            this.isDeleted = _data["isDeleted"];
            this.sequence = _data["sequence"];
            this.isActive = _data["isActive"];
            this.subModuleTypeId = _data["subModuleTypeId"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.isApprovalWorkflowRequired = _data["isApprovalWorkflowRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSelected"] = this.isSelected;
        data["isMandatory"] = this.isMandatory;
        data["isDeleted"] = this.isDeleted;
        data["sequence"] = this.sequence;
        data["isActive"] = this.isActive;
        data["subModuleTypeId"] = this.subModuleTypeId;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["isApprovalWorkflowRequired"] = this.isApprovalWorkflowRequired;
        data["id"] = this.id;
        return data;
    }

    clone(): SubModuleDto {
        const json = this.toJSON();
        let result = new SubModuleDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    sequence: number;
    isActive: boolean;
    subModuleTypeId: number | undefined;
    isApprovalRequired: boolean;
    isApprovalWorkflowRequired: boolean;
    id: number;
}

export class ModuleDto implements IModuleDto {
    name: string;
    displayName: string;
    description: string;
    isDeleted: boolean;
    isActive: boolean;
    createdOn: moment.Moment | undefined;
    subModules: SubModuleDto[];
    id: number;

    constructor(data?: IModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subModules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["subModules"])) {
                this.subModules = [] as any;
                for (let item of _data["subModules"])
                    this.subModules.push(SubModuleDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.subModules)) {
            data["subModules"] = [];
            for (let item of this.subModules)
                data["subModules"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ModuleDto {
        const json = this.toJSON();
        let result = new ModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleDto {
    name: string;
    displayName: string;
    description: string;
    isDeleted: boolean;
    isActive: boolean;
    createdOn: moment.Moment | undefined;
    subModules: SubModuleDto[];
    id: number;
}

export class UpdateSubModuleDto implements IUpdateSubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    isActive: boolean;
    isApprovalRequired: boolean;
    id: number;

    constructor(data?: IUpdateSubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSelected = _data["isSelected"];
            this.isMandatory = _data["isMandatory"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSelected"] = this.isSelected;
        data["isMandatory"] = this.isMandatory;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSubModuleDto {
        const json = this.toJSON();
        let result = new UpdateSubModuleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    isActive: boolean;
    isApprovalRequired: boolean;
    id: number;
}

export class ModuleSubModuleDto implements IModuleSubModuleDto {
    subModule: SubModuleDto[] | undefined;
    isMandatory: boolean;
    isSelected: boolean;
    isActive: boolean;
    id: number;

    constructor(data?: IModuleSubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subModule"])) {
                this.subModule = [] as any;
                for (let item of _data["subModule"])
                    this.subModule.push(SubModuleDto.fromJS(item));
            }
            this.isMandatory = _data["isMandatory"];
            this.isSelected = _data["isSelected"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleSubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subModule)) {
            data["subModule"] = [];
            for (let item of this.subModule)
                data["subModule"].push(item.toJSON());
        }
        data["isMandatory"] = this.isMandatory;
        data["isSelected"] = this.isSelected;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ModuleSubModuleDto {
        const json = this.toJSON();
        let result = new ModuleSubModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleSubModuleDto {
    subModule: SubModuleDto[] | undefined;
    isMandatory: boolean;
    isSelected: boolean;
    isActive: boolean;
    id: number;
}

export class NotificationDto implements INotificationDto {
    id: number;
    notification_type: number;
    assign_roles: string | undefined;
    assign_email: number;
    assign_mobile: number;
    log_Id: number;
    isActive: boolean;
    repeat: number;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.notification_type = _data["notification_type"];
            this.assign_roles = _data["assign_roles"];
            this.assign_email = _data["assign_email"];
            this.assign_mobile = _data["assign_mobile"];
            this.log_Id = _data["log_Id"];
            this.isActive = _data["isActive"];
            this.repeat = _data["repeat"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? moment(_data["modifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["notification_type"] = this.notification_type;
        data["assign_roles"] = this.assign_roles;
        data["assign_email"] = this.assign_email;
        data["assign_mobile"] = this.assign_mobile;
        data["log_Id"] = this.log_Id;
        data["isActive"] = this.isActive;
        data["repeat"] = this.repeat;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        return data;
    }

    clone(): NotificationDto {
        const json = this.toJSON();
        let result = new NotificationDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDto {
    id: number;
    notification_type: number;
    assign_roles: string | undefined;
    assign_email: number;
    assign_mobile: number;
    log_Id: number;
    isActive: boolean;
    repeat: number;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment;
}

export class NotificationDtoPagedResultDto implements INotificationDtoPagedResultDto {
    totalCount: number;
    items: NotificationDto[] | undefined;

    constructor(data?: INotificationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): NotificationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NotificationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDtoPagedResultDto {
    totalCount: number;
    items: NotificationDto[] | undefined;
}

export class PlantDto implements IPlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    userEnteredApprovalStatus: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IPlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.masterPlantId = _data["masterPlantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.taxRegistrationNo = _data["taxRegistrationNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.website = _data["website"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["masterPlantId"] = this.masterPlantId;
        data["plantTypeId"] = this.plantTypeId;
        data["taxRegistrationNo"] = this.taxRegistrationNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["website"] = this.website;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data;
    }

    clone(): PlantDto {
        const json = this.toJSON();
        let result = new PlantDto();
        result.init(json);
        return result;
    }
}

export interface IPlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    userEnteredApprovalStatus: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class PlantListDto implements IPlantListDto {
    plantName: string | undefined;
    plantId: string | undefined;
    plantTypeId: number | undefined;
    license: string | undefined;
    countryId: number | undefined;
    isActive: boolean;
    countryName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    masterPlantId: number | undefined;
    id: number;

    constructor(data?: IPlantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.license = _data["license"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
            this.countryName = _data["countryName"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.masterPlantId = _data["masterPlantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["plantTypeId"] = this.plantTypeId;
        data["license"] = this.license;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        data["countryName"] = this.countryName;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["masterPlantId"] = this.masterPlantId;
        data["id"] = this.id;
        return data;
    }

    clone(): PlantListDto {
        const json = this.toJSON();
        let result = new PlantListDto();
        result.init(json);
        return result;
    }
}

export interface IPlantListDto {
    plantName: string | undefined;
    plantId: string | undefined;
    plantTypeId: number | undefined;
    license: string | undefined;
    countryId: number | undefined;
    isActive: boolean;
    countryName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    masterPlantId: number | undefined;
    id: number;
}

export class PlantListDtoPagedResultDto implements IPlantListDtoPagedResultDto {
    totalCount: number;
    items: PlantListDto[] | undefined;

    constructor(data?: IPlantListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PlantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlantListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PlantListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PlantListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlantListDtoPagedResultDto {
    totalCount: number;
    items: PlantListDto[] | undefined;
}

export class CreatePlantDto implements ICreatePlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreatePlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.masterPlantId = _data["masterPlantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.taxRegistrationNo = _data["taxRegistrationNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["masterPlantId"] = this.masterPlantId;
        data["plantTypeId"] = this.plantTypeId;
        data["taxRegistrationNo"] = this.taxRegistrationNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["website"] = this.website;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreatePlantDto {
        const json = this.toJSON();
        let result = new CreatePlantDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class ApprovalStatusDto implements IApprovalStatusDto {
    approvalStatusId: number;
    description: string | undefined;
    id: number;

    constructor(data?: IApprovalStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalStatusId = _data["approvalStatusId"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalStatusId"] = this.approvalStatusId;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalStatusDto {
        const json = this.toJSON();
        let result = new ApprovalStatusDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalStatusDto {
    approvalStatusId: number;
    description: string | undefined;
    id: number;
}

export class ActionDto implements IActionDto {
    id: number;
    action: string | undefined;
    isGranted: boolean;
    permissionName: string | undefined;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
            this.isGranted = _data["isGranted"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["isGranted"] = this.isGranted;
        data["permissionName"] = this.permissionName;
        return data;
    }

    clone(): ActionDto {
        const json = this.toJSON();
        let result = new ActionDto();
        result.init(json);
        return result;
    }
}

export interface IActionDto {
    id: number;
    action: string | undefined;
    isGranted: boolean;
    permissionName: string | undefined;
}

export class RolePermissionsDto implements IRolePermissionsDto {
    moduleSubModuleId: number;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    isGranted: boolean;
    isSuperAdminPermission: boolean;
    grantedPermissions: ActionDto[];

    constructor(data?: IRolePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleSubModuleId = _data["moduleSubModuleId"];
            this.moduleName = _data["moduleName"];
            this.subModuleName = _data["subModuleName"];
            this.isGranted = _data["isGranted"];
            this.isSuperAdminPermission = _data["isSuperAdminPermission"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(ActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleSubModuleId"] = this.moduleSubModuleId;
        data["moduleName"] = this.moduleName;
        data["subModuleName"] = this.subModuleName;
        data["isGranted"] = this.isGranted;
        data["isSuperAdminPermission"] = this.isSuperAdminPermission;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): RolePermissionsDto {
        const json = this.toJSON();
        let result = new RolePermissionsDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionsDto {
    moduleSubModuleId: number;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    isGranted: boolean;
    isSuperAdminPermission: boolean;
    grantedPermissions: ActionDto[];
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
    modulePermissions: RolePermissionsDto[];
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isSuperAdminRole: boolean;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
            this.isActive = true;
            this.modulePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            if (Array.isArray(_data["modulePermissions"])) {
                this.modulePermissions = [] as any;
                for (let item of _data["modulePermissions"])
                    this.modulePermissions.push(RolePermissionsDto.fromJS(item));
            }
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isSuperAdminRole = _data["isSuperAdminRole"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.modulePermissions)) {
            data["modulePermissions"] = [];
            for (let item of this.modulePermissions)
                data["modulePermissions"].push(item.toJSON());
        }
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isSuperAdminRole"] = this.isSuperAdminRole;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
    modulePermissions: RolePermissionsDto[];
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isSuperAdminRole: boolean;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class RoleListDtoPagedResultDto implements IRoleListDtoPagedResultDto {
    totalCount: number;
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoPagedResultDto {
    totalCount: number;
    items: RoleListDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    isDeleted: boolean;
    isActive: boolean;
    description: string | undefined;
    createdOn: moment.Moment;
    modulePermissions: RolePermissionsDto[];

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
            this.isActive = true;
            this.modulePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.description = _data["description"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["modulePermissions"])) {
                this.modulePermissions = [] as any;
                for (let item of _data["modulePermissions"])
                    this.modulePermissions.push(RolePermissionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.modulePermissions)) {
            data["modulePermissions"] = [];
            for (let item of this.modulePermissions)
                data["modulePermissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    isDeleted: boolean;
    isActive: boolean;
    description: string | undefined;
    createdOn: moment.Moment;
    modulePermissions: RolePermissionsDto[];
}

export class SelectListDtoWithPlantId implements ISelectListDtoWithPlantId {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    leastCountDigitAfterDecimal: number | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDtoWithPlantId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.plantId = _data["plantId"];
            this.isActive = _data["isActive"];
            this.isSampling = _data["isSampling"];
            this.isReservationNo = _data["isReservationNo"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDtoWithPlantId {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDtoWithPlantId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["plantId"] = this.plantId;
        data["isActive"] = this.isActive;
        data["isSampling"] = this.isSampling;
        data["isReservationNo"] = this.isReservationNo;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["id"] = this.id;
        return data;
    }

    clone(): SelectListDtoWithPlantId {
        const json = this.toJSON();
        let result = new SelectListDtoWithPlantId();
        result.init(json);
        return result;
    }
}

export interface ISelectListDtoWithPlantId {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    leastCountDigitAfterDecimal: number | undefined;
    id: any | undefined;
}

export class SelectListDtoWithPlantIdPalletization implements ISelectListDtoWithPlantIdPalletization {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    productBatchNo: string | undefined;
    containerBarCode: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDtoWithPlantIdPalletization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.plantId = _data["plantId"];
            this.isActive = _data["isActive"];
            this.isSampling = _data["isSampling"];
            this.isReservationNo = _data["isReservationNo"];
            this.productBatchNo = _data["productBatchNo"];
            this.containerBarCode = _data["containerBarCode"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDtoWithPlantIdPalletization {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDtoWithPlantIdPalletization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["plantId"] = this.plantId;
        data["isActive"] = this.isActive;
        data["isSampling"] = this.isSampling;
        data["isReservationNo"] = this.isReservationNo;
        data["productBatchNo"] = this.productBatchNo;
        data["containerBarCode"] = this.containerBarCode;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): SelectListDtoWithPlantIdPalletization {
        const json = this.toJSON();
        let result = new SelectListDtoWithPlantIdPalletization();
        result.init(json);
        return result;
    }
}

export interface ISelectListDtoWithPlantIdPalletization {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    productBatchNo: string | undefined;
    containerBarCode: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    id: any | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleNames: string[] | undefined;
    permissions: string[] | undefined;
    transactionActiveSubModules: string[] | undefined;
    plantCode: string | undefined;
    modeId: number;
    isControllerMode: boolean;
    isGateEntrySubModuleActive: boolean;
    isMaterialInspectionModuleSelected: boolean;
    resetPasswordDaysLeft: number;
    approvalLevelId: number | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
            if (Array.isArray(_data["transactionActiveSubModules"])) {
                this.transactionActiveSubModules = [] as any;
                for (let item of _data["transactionActiveSubModules"])
                    this.transactionActiveSubModules.push(item);
            }
            this.plantCode = _data["plantCode"];
            this.modeId = _data["modeId"];
            this.isControllerMode = _data["isControllerMode"];
            this.isGateEntrySubModuleActive = _data["isGateEntrySubModuleActive"];
            this.isMaterialInspectionModuleSelected = _data["isMaterialInspectionModuleSelected"];
            this.resetPasswordDaysLeft = _data["resetPasswordDaysLeft"];
            this.approvalLevelId = _data["approvalLevelId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.transactionActiveSubModules)) {
            data["transactionActiveSubModules"] = [];
            for (let item of this.transactionActiveSubModules)
                data["transactionActiveSubModules"].push(item);
        }
        data["plantCode"] = this.plantCode;
        data["modeId"] = this.modeId;
        data["isControllerMode"] = this.isControllerMode;
        data["isGateEntrySubModuleActive"] = this.isGateEntrySubModuleActive;
        data["isMaterialInspectionModuleSelected"] = this.isMaterialInspectionModuleSelected;
        data["resetPasswordDaysLeft"] = this.resetPasswordDaysLeft;
        data["approvalLevelId"] = this.approvalLevelId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleNames: string[] | undefined;
    permissions: string[] | undefined;
    transactionActiveSubModules: string[] | undefined;
    plantCode: string | undefined;
    modeId: number;
    isControllerMode: boolean;
    isGateEntrySubModuleActive: boolean;
    isMaterialInspectionModuleSelected: boolean;
    resetPasswordDaysLeft: number;
    approvalLevelId: number | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SettingDto implements ISettingDto {
    id: number;
    name: string | undefined;
    value: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): SettingDto {
        const json = this.toJSON();
        let result = new SettingDto();
        result.init(json);
        return result;
    }
}

export interface ISettingDto {
    id: number;
    name: string | undefined;
    value: string | undefined;
}

export class StandardWeightDto implements IStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    unitOfMeasurementId: number | undefined;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IStandardWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.standardWeightBoxMasterId = _data["standardWeightBoxMasterId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["standardWeightBoxMasterId"] = this.standardWeightBoxMasterId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data;
    }

    clone(): StandardWeightDto {
        const json = this.toJSON();
        let result = new StandardWeightDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    unitOfMeasurementId: number | undefined;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class StandardWeightListDto implements IStandardWeightListDto {
    subPlantId: number;
    standardWeightId: string | undefined;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IStandardWeightListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.userEnteredAreaId = _data["userEnteredAreaId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["userEnteredAreaId"] = this.userEnteredAreaId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data;
    }

    clone(): StandardWeightListDto {
        const json = this.toJSON();
        let result = new StandardWeightListDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightListDto {
    subPlantId: number;
    standardWeightId: string | undefined;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class StandardWeightListDtoPagedResultDto implements IStandardWeightListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightListDto[] | undefined;

    constructor(data?: IStandardWeightListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(StandardWeightListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StandardWeightListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StandardWeightListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StandardWeightListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightListDto[] | undefined;
}

export class CreateStandardWeightDto implements ICreateStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    unitOfMeasurementId: number | undefined;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateStandardWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.departmentId = _data["departmentId"];
            this.standardWeightBoxMasterId = _data["standardWeightBoxMasterId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateStandardWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStandardWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["departmentId"] = this.departmentId;
        data["standardWeightBoxMasterId"] = this.standardWeightBoxMasterId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateStandardWeightDto {
        const json = this.toJSON();
        let result = new CreateStandardWeightDto();
        result.init(json);
        return result;
    }
}

export interface ICreateStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    unitOfMeasurementId: number | undefined;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    description: string | undefined;
}

export class StandardWeightStampingDueListDto implements IStandardWeightStampingDueListDto {
    standardWeightBoxId: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    department: string | undefined;
    area: string | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;

    constructor(data?: IStandardWeightStampingDueListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.department = _data["department"];
            this.area = _data["area"];
            this.dueDays = _data["dueDays"];
            this.plantId = _data["plantId"];
            this.subPlant = _data["subPlant"];
        }
    }

    static fromJS(data: any): StandardWeightStampingDueListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightStampingDueListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["department"] = this.department;
        data["area"] = this.area;
        data["dueDays"] = this.dueDays;
        data["plantId"] = this.plantId;
        data["subPlant"] = this.subPlant;
        return data;
    }

    clone(): StandardWeightStampingDueListDto {
        const json = this.toJSON();
        let result = new StandardWeightStampingDueListDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightStampingDueListDto {
    standardWeightBoxId: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    department: string | undefined;
    area: string | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    userId: number;
    isMultiplePlantExists: boolean;
    plantId: number | undefined;
    passwordStatus: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.refreshToken = _data["refreshToken"];
            this.userId = _data["userId"];
            this.isMultiplePlantExists = _data["isMultiplePlantExists"];
            this.plantId = _data["plantId"];
            this.passwordStatus = _data["passwordStatus"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["refreshToken"] = this.refreshToken;
        data["userId"] = this.userId;
        data["isMultiplePlantExists"] = this.isMultiplePlantExists;
        data["plantId"] = this.plantId;
        data["passwordStatus"] = this.passwordStatus;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    userId: number;
    isMultiplePlantExists: boolean;
    plantId: number | undefined;
    passwordStatus: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class UsersListDto implements IUsersListDto {
    userName: string | undefined;
    creationTime: moment.Moment;
    approvalStatusId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pswdResetDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.approvalStatusId = _data["approvalStatusId"];
            this.isActive = _data["isActive"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.pswdResetDate = _data["pswdResetDate"] ? moment(_data["pswdResetDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["approvalStatusId"] = this.approvalStatusId;
        data["isActive"] = this.isActive;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["pswdResetDate"] = this.pswdResetDate ? this.pswdResetDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UsersListDto {
        const json = this.toJSON();
        let result = new UsersListDto();
        result.init(json);
        return result;
    }
}

export interface IUsersListDto {
    userName: string | undefined;
    creationTime: moment.Moment;
    approvalStatusId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pswdResetDate: moment.Moment | undefined;
    id: number;
}

export class UsersListDtoPagedResultDto implements IUsersListDtoPagedResultDto {
    totalCount: number;
    items: UsersListDto[] | undefined;

    constructor(data?: IUsersListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UsersListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UsersListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UsersListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUsersListDtoPagedResultDto {
    totalCount: number;
    items: UsersListDto[] | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string | undefined;
    email: string | undefined;
    isDeleted: boolean;
    createdOn: moment.Moment;
    plants: number[] | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    designationId: number | undefined;
    employeeCode: string | undefined;
    roleNames: string[] | undefined;
    password: string;
    confirmPassword: string;
    isActive: boolean;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(item);
            }
            this.reportingManagerId = _data["reportingManagerId"];
            this.modeId = _data["modeId"];
            this.designationId = _data["designationId"];
            this.employeeCode = _data["employeeCode"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item);
        }
        data["reportingManagerId"] = this.reportingManagerId;
        data["modeId"] = this.modeId;
        data["designationId"] = this.designationId;
        data["employeeCode"] = this.employeeCode;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string | undefined;
    email: string | undefined;
    isDeleted: boolean;
    createdOn: moment.Moment;
    plants: number[] | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    designationId: number | undefined;
    employeeCode: string | undefined;
    roleNames: string[] | undefined;
    password: string;
    confirmPassword: string;
    isActive: boolean;
}

export class RoleCheckboxDto implements IRoleCheckboxDto {
    name: string | undefined;
    displayName: string | undefined;
    isSelected: boolean;
    userRoles: RoleCheckboxDto[] | undefined;

    constructor(data?: IRoleCheckboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isSelected = _data["isSelected"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(RoleCheckboxDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleCheckboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleCheckboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isSelected"] = this.isSelected;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleCheckboxDto {
        const json = this.toJSON();
        let result = new RoleCheckboxDto();
        result.init(json);
        return result;
    }
}

export interface IRoleCheckboxDto {
    name: string | undefined;
    displayName: string | undefined;
    isSelected: boolean;
    userRoles: RoleCheckboxDto[] | undefined;
}

export class CalibrationFrequencyDto implements ICalibrationFrequencyDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    id: number;

    constructor(data?: ICalibrationFrequencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.calibrationLevel = _data["calibrationLevel"];
            this.calibrationCriteria = _data["calibrationCriteria"];
            this.standardWeightValue = _data["standardWeightValue"];
            this.minimumValue = _data["minimumValue"];
            this.maximumValue = _data["maximumValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CalibrationFrequencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalibrationFrequencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["calibrationLevel"] = this.calibrationLevel;
        data["calibrationCriteria"] = this.calibrationCriteria;
        data["standardWeightValue"] = this.standardWeightValue;
        data["minimumValue"] = this.minimumValue;
        data["maximumValue"] = this.maximumValue;
        data["id"] = this.id;
        return data;
    }

    clone(): CalibrationFrequencyDto {
        const json = this.toJSON();
        let result = new CalibrationFrequencyDto();
        result.init(json);
        return result;
    }
}

export interface ICalibrationFrequencyDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    id: number;
}

export class WeighingMachineTestconfigurationDto implements IWeighingMachineTestconfigurationDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    id: number;

    constructor(data?: IWeighingMachineTestconfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.isEccentricityTestRequired = _data["isEccentricityTestRequired"];
            this.isLinearityTestRequired = _data["isLinearityTestRequired"];
            this.isRepeatabilityTestRequired = _data["isRepeatabilityTestRequired"];
            this.isUncertainityTestRequired = _data["isUncertainityTestRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineTestconfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineTestconfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["isEccentricityTestRequired"] = this.isEccentricityTestRequired;
        data["isLinearityTestRequired"] = this.isLinearityTestRequired;
        data["isRepeatabilityTestRequired"] = this.isRepeatabilityTestRequired;
        data["isUncertainityTestRequired"] = this.isUncertainityTestRequired;
        data["id"] = this.id;
        return data;
    }

    clone(): WeighingMachineTestconfigurationDto {
        const json = this.toJSON();
        let result = new WeighingMachineTestconfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineTestconfigurationDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    id: number;
}

export class WeighingMachineDto implements IWeighingMachineDto {
    weighingMachineCode: string | undefined;
    balancedTypeId: number | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    id: number;

    constructor(data?: IWeighingMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.balancedTypeId = _data["balancedTypeId"];
            this.subPlantId = _data["subPlantId"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.capacity = _data["capacity"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.minimumOperatingCapacity = _data["minimumOperatingCapacity"];
            this.maximumOperatingCapacity = _data["maximumOperatingCapacity"];
            this.leastCount = _data["leastCount"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.eccentricityAcceptanceValue = _data["eccentricityAcceptanceValue"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.linearityAcceptanceValue = _data["linearityAcceptanceValue"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityAcceptanceValue = _data["repeatabilityAcceptanceValue"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyAcceptanceValue = _data["uncertaintyAcceptanceValue"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.percentageRSDValue = _data["percentageRSDValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.meanValue = _data["meanValue"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.formula = _data["formula"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            if (Array.isArray(_data["calibrations"])) {
                this.calibrations = [] as any;
                for (let item of _data["calibrations"])
                    this.calibrations.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestconfigurationDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["balancedTypeId"] = this.balancedTypeId;
        data["subPlantId"] = this.subPlantId;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["capacity"] = this.capacity;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["minimumOperatingCapacity"] = this.minimumOperatingCapacity;
        data["maximumOperatingCapacity"] = this.maximumOperatingCapacity;
        data["leastCount"] = this.leastCount;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["eccentricityAcceptanceValue"] = this.eccentricityAcceptanceValue;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["linearityAcceptanceValue"] = this.linearityAcceptanceValue;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityAcceptanceValue"] = this.repeatabilityAcceptanceValue;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyAcceptanceValue"] = this.uncertaintyAcceptanceValue;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["percentageRSDValue"] = this.percentageRSDValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["meanValue"] = this.meanValue;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["formula"] = this.formula;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        if (Array.isArray(this.calibrations)) {
            data["calibrations"] = [];
            for (let item of this.calibrations)
                data["calibrations"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): WeighingMachineDto {
        const json = this.toJSON();
        let result = new WeighingMachineDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineDto {
    weighingMachineCode: string | undefined;
    balancedTypeId: number | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    id: number;
}

export class WeighingMachineListDto implements IWeighingMachineListDto {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    userEnteredPlantId: string | undefined;
    unitOfMeasurementId: number | undefined;
    userEnteredUOM: string | undefined;
    make: string | undefined;
    modal: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyInstruction: string | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IWeighingMachineListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.subPlantId = _data["subPlantId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.userEnteredUOM = _data["userEnteredUOM"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["subPlantId"] = this.subPlantId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["userEnteredUOM"] = this.userEnteredUOM;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data;
    }

    clone(): WeighingMachineListDto {
        const json = this.toJSON();
        let result = new WeighingMachineListDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineListDto {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    userEnteredPlantId: string | undefined;
    unitOfMeasurementId: number | undefined;
    userEnteredUOM: string | undefined;
    make: string | undefined;
    modal: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyInstruction: string | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class WeighingMachineListDtoPagedResultDto implements IWeighingMachineListDtoPagedResultDto {
    totalCount: number;
    items: WeighingMachineListDto[] | undefined;

    constructor(data?: IWeighingMachineListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WeighingMachineListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeighingMachineListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WeighingMachineListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WeighingMachineListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineListDtoPagedResultDto {
    totalCount: number;
    items: WeighingMachineListDto[] | undefined;
}

export class CreateWeighingMachineDto implements ICreateWeighingMachineDto {
    balancedTypeId: number | undefined;
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;

    constructor(data?: ICreateWeighingMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balancedTypeId = _data["balancedTypeId"];
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.subPlantId = _data["subPlantId"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.capacity = _data["capacity"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.minimumOperatingCapacity = _data["minimumOperatingCapacity"];
            this.maximumOperatingCapacity = _data["maximumOperatingCapacity"];
            this.leastCount = _data["leastCount"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.eccentricityAcceptanceValue = _data["eccentricityAcceptanceValue"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.linearityAcceptanceValue = _data["linearityAcceptanceValue"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityAcceptanceValue = _data["repeatabilityAcceptanceValue"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyAcceptanceValue = _data["uncertaintyAcceptanceValue"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.percentageRSDValue = _data["percentageRSDValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.meanValue = _data["meanValue"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.formula = _data["formula"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["calibrations"])) {
                this.calibrations = [] as any;
                for (let item of _data["calibrations"])
                    this.calibrations.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestconfigurationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWeighingMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeighingMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balancedTypeId"] = this.balancedTypeId;
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["subPlantId"] = this.subPlantId;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["capacity"] = this.capacity;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["minimumOperatingCapacity"] = this.minimumOperatingCapacity;
        data["maximumOperatingCapacity"] = this.maximumOperatingCapacity;
        data["leastCount"] = this.leastCount;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["eccentricityAcceptanceValue"] = this.eccentricityAcceptanceValue;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["linearityAcceptanceValue"] = this.linearityAcceptanceValue;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityAcceptanceValue"] = this.repeatabilityAcceptanceValue;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyAcceptanceValue"] = this.uncertaintyAcceptanceValue;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["percentageRSDValue"] = this.percentageRSDValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["meanValue"] = this.meanValue;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["formula"] = this.formula;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.calibrations)) {
            data["calibrations"] = [];
            for (let item of this.calibrations)
                data["calibrations"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateWeighingMachineDto {
        const json = this.toJSON();
        let result = new CreateWeighingMachineDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeighingMachineDto {
    balancedTypeId: number | undefined;
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
}

export class WeighingMachineStampingDueOnListDto implements IWeighingMachineStampingDueOnListDto {
    weighingMachineCode: string | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;

    constructor(data?: IWeighingMachineStampingDueOnListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.dueDays = _data["dueDays"];
            this.plantId = _data["plantId"];
            this.subPlant = _data["subPlant"];
        }
    }

    static fromJS(data: any): WeighingMachineStampingDueOnListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineStampingDueOnListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["dueDays"] = this.dueDays;
        data["plantId"] = this.plantId;
        data["subPlant"] = this.subPlant;
        return data;
    }

    clone(): WeighingMachineStampingDueOnListDto {
        const json = this.toJSON();
        let result = new WeighingMachineStampingDueOnListDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineStampingDueOnListDto {
    weighingMachineCode: string | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}