/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param isForgotPswd (optional) 
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(isForgotPswd: boolean | undefined, body: ForgotPasswordDto | undefined): Observable<ForgotPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ForgotPassword?";
        if (isForgotPswd === null)
            throw new Error("The parameter 'isForgotPswd' cannot be null.");
        else if (isForgotPswd !== undefined)
            url_ += "isForgotPswd=" + encodeURIComponent("" + isForgotPswd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ForgotPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForgotPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ForgotPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForgotPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForgotPasswordOutput>(<any>null);
    }
}

@Injectable()
export class ActivityMasterServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(<any>null);
    }

    /**
     * @param moduleId (optional) 
     * @param subModuleId (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(moduleId: number | null | undefined, subModuleId: number | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ActivityListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/GetAll?";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (subModuleId !== undefined && subModuleId !== null)
            url_ += "SubModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActivityListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateActivityDto | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ActivityDto | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectActivity(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityMasterService/ApproveOrRejectActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApprovalLevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(<any>null);
    }

    /**
     * @param levelCode (optional) 
     * @param levelName (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(levelCode: number | undefined, levelName: string | null | undefined, activeInactiveStatusId: number | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ApprovalLevelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/GetAll?";
        if (levelCode === null)
            throw new Error("The parameter 'levelCode' cannot be null.");
        else if (levelCode !== undefined)
            url_ += "LevelCode=" + encodeURIComponent("" + levelCode) + "&";
        if (levelName !== undefined && levelName !== null)
            url_ += "LevelName=" + encodeURIComponent("" + levelName) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLevelListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLevelListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalLevelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalLevelDto | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(<any>null);
    }

    /**
     * @param levelName (optional) 
     * @return Success
     */
    isLevelPresent(levelName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/IsLevelPresent?";
        if (levelName !== undefined && levelName !== null)
            url_ += "LevelName=" + encodeURIComponent("" + levelName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsLevelPresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsLevelPresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsLevelPresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ApprovalLevelDto | undefined): Observable<ApprovalLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<ApprovalLevelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalLevel/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLevelListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLevelListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ApprovalLevelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLevelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLevelListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class ApprovalUserModuleMappingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getActivitySubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetActivitySubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivitySubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivitySubModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivitySubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(<any>null);
    }

    /**
     * @param appLevelId (optional) 
     * @param userId (optional) 
     * @param moduleId (optional) 
     * @param subModuleId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(appLevelId: number | null | undefined, userId: number | null | undefined, moduleId: number | null | undefined, subModuleId: number | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ApprovalUserModuleMappingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/GetAll?";
        if (appLevelId !== undefined && appLevelId !== null)
            url_ += "AppLevelId=" + encodeURIComponent("" + appLevelId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (subModuleId !== undefined && subModuleId !== null)
            url_ += "SubModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalUserModuleMappingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalUserModuleMappingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalUserModuleMappingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalUserModuleMappingDto | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ApprovalUserModuleMappingDto | undefined): Observable<ApprovalUserModuleMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalUserModuleMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalUserModuleMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalUserModuleMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalUserModuleMappingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalUserModuleMappingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AreaDto> {
        let url_ = this.baseUrl + "/api/services/app/Area/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AreaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param departmentId (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, departmentId: number | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AreaListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Area/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AreaListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AreaListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAreaDto | undefined): Observable<AreaDto> {
        let url_ = this.baseUrl + "/api/services/app/Area/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AreaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AreaDto | undefined): Observable<AreaDto> {
        let url_ = this.baseUrl + "/api/services/app/Area/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AreaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Area/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectArea(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Area/ApproveOrRejectArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectArea(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectArea(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AreaUsageLogServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AreaUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AreaUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AreaUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaUsageLogDto>(<any>null);
    }

    /**
     * @param activityID (optional) 
     * @param cubicalId (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(activityID: number | null | undefined, cubicalId: number | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AreaUsageLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetAll?";
        if (activityID !== undefined && activityID !== null)
            url_ += "ActivityID=" + encodeURIComponent("" + activityID) + "&";
        if (cubicalId !== undefined && cubicalId !== null)
            url_ += "CubicalId=" + encodeURIComponent("" + cubicalId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AreaUsageLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaUsageLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AreaUsageLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaUsageLogListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaUsageLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param checklistId (optional) 
     * @param modeId (optional) 
     * @return Success
     */
    getCheckpointsByChecklistId(checklistId: number | undefined, modeId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetCheckpointsByChecklistId?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        if (modeId === null)
            throw new Error("The parameter 'modeId' cannot be null.");
        else if (modeId !== undefined)
            url_ += "modeId=" + encodeURIComponent("" + modeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsByChecklistId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsByChecklistId(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsByChecklistId(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAreaUsageLogDto | undefined): Observable<AreaUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AreaUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AreaUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaUsageLogDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAreaUsageLogDto | undefined): Observable<AreaUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AreaUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AreaUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaUsageLogDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllActivity(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetAllActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivity(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActivity(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param checklistId (optional) 
     * @return Success
     */
    getCheckpointsList(checklistId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetCheckpointsList?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsList(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsList(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @param status (optional) 
     * @return Success
     */
    getStatusByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined, status: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetStatusByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusByModuleSubModuleName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    geSubmoduleAllStatusList(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GeSubmoduleAllStatusList?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeSubmoduleAllStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeSubmoduleAllStatusList(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGeSubmoduleAllStatusList(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    getStatusListByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/GetStatusListByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusListByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusListByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusListByModuleSubModuleName(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param activityID (optional) 
     * @return Success
     */
    isCheckProcessOrderAlreadyUsed(activityID: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/IsCheckProcessOrderAlreadyUsed?";
        if (activityID === null)
            throw new Error("The parameter 'activityID' cannot be null.");
        else if (activityID !== undefined)
            url_ += "activityID=" + encodeURIComponent("" + activityID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsCheckProcessOrderAlreadyUsed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsCheckProcessOrderAlreadyUsed(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processIsCheckProcessOrderAlreadyUsed(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param areaUsageLogId (optional) 
     * @return Success
     */
    validateAreaUsageLog(areaUsageLogId: number | undefined): Observable<AreaUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/ValidateAreaUsageLog?";
        if (areaUsageLogId === null)
            throw new Error("The parameter 'areaUsageLogId' cannot be null.");
        else if (areaUsageLogId !== undefined)
            url_ += "areaUsageLogId=" + encodeURIComponent("" + areaUsageLogId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateAreaUsageLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateAreaUsageLog(<any>response_);
                } catch (e) {
                    return <Observable<AreaUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateAreaUsageLog(response: HttpResponseBase): Observable<AreaUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaUsageLogDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAreaUsageLogTransaction(body: AreaUsageLogDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AreaUsageLogService/UpdateAreaUsageLogTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAreaUsageLogTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAreaUsageLogTransaction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAreaUsageLogTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AtesttableMasterServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AtesttableMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/AtesttableMasterService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AtesttableMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AtesttableMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AtesttableMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtesttableMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AtesttableMasterDto>(<any>null);
    }
}

@Injectable()
export class BinToBinTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param materialToBinId (optional) 
     * @param palletToBinId (optional) 
     * @return Success
     */
    get(materialToBinId: string | null | undefined, palletToBinId: number | undefined): Observable<PutAwayBinToBinTransferDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BinToBinTransfer/Get?";
        if (materialToBinId !== undefined && materialToBinId !== null)
            url_ += "materialToBinId=" + encodeURIComponent("" + materialToBinId) + "&";
        if (palletToBinId === null)
            throw new Error("The parameter 'palletToBinId' cannot be null.");
        else if (palletToBinId !== undefined)
            url_ += "palletToBinId=" + encodeURIComponent("" + palletToBinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PutAwayBinToBinTransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PutAwayBinToBinTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param palletId (optional) 
     * @param materialId (optional) 
     * @param locationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, palletId: number | null | undefined, materialId: number | null | undefined, locationId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PutAwayBinToBinTransferListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BinToBinTransfer/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (palletId !== undefined && palletId !== null)
            url_ += "PalletId=" + encodeURIComponent("" + palletId) + "&";
        if (materialId !== undefined && materialId !== null)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PutAwayBinToBinTransferListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutAwayBinToBinTransferListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePutAwayBinToBinTransferDto | undefined): Observable<PutAwayBinToBinTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/BinToBinTransfer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PutAwayBinToBinTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutAwayBinToBinTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferDto>(<any>null);
    }

    /**
     * @param putAwayId (optional) 
     * @param transationId (optional) 
     * @return Success
     */
    unloadBin(putAwayId: number | undefined, transationId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BinToBinTransfer/UnloadBin?";
        if (putAwayId === null)
            throw new Error("The parameter 'putAwayId' cannot be null.");
        else if (putAwayId !== undefined)
            url_ += "putAwayId=" + encodeURIComponent("" + putAwayId) + "&";
        if (transationId !== undefined && transationId !== null)
            url_ += "transationId=" + encodeURIComponent("" + transationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnloadBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnloadBin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnloadBin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CageLabelPrintingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CageLabelPrintingDto | undefined): Observable<CageLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CageLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CageLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CageLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingDto>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<CageLabelPrintingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CageLabelPrintingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param productID (optional) 
     * @param processorderID (optional) 
     * @param cubicleID (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(productID: number | null | undefined, processorderID: number | null | undefined, cubicleID: number | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CageLabelPrintingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetAll?";
        if (productID !== undefined && productID !== null)
            url_ += "ProductID=" + encodeURIComponent("" + productID) + "&";
        if (processorderID !== undefined && processorderID !== null)
            url_ += "ProcessorderID=" + encodeURIComponent("" + processorderID) + "&";
        if (cubicleID !== undefined && cubicleID !== null)
            url_ += "CubicleID=" + encodeURIComponent("" + cubicleID) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CageLabelPrintingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CageLabelPrintingDto | undefined): Observable<CageLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CageLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllDispensedCode(input: string | null | undefined): Observable<CageLabelPrintingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetAllDispensedCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensedCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensedCode(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensedCode(response: HttpResponseBase): Observable<CageLabelPrintingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CageLabelPrintingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDispCode(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetAllDispCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispCode(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispCode(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<CageLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<CageLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CageLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<CageLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CageLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CageLabelPrintingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    print(body: CageLabelPrintingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CageLabelPrintingService/Print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CalenderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CalenderDto> {
        let url_ = this.baseUrl + "/api/services/app/Calender/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CalenderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CalenderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CalenderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalenderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CalenderDto>(<any>null);
    }

    /**
     * @param holidayTypeId (optional) 
     * @param approvalStatusId (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(holidayTypeId: number | null | undefined, approvalStatusId: number | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CalenderListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Calender/GetAll?";
        if (holidayTypeId !== undefined && holidayTypeId !== null)
            url_ += "HolidayTypeId=" + encodeURIComponent("" + holidayTypeId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CalenderListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CalenderListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CalenderListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalenderListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CalenderListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCalenderDto | undefined): Observable<CalenderDto> {
        let url_ = this.baseUrl + "/api/services/app/Calender/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CalenderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CalenderDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CalenderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalenderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CalenderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CalenderDto | undefined): Observable<CalenderDto> {
        let url_ = this.baseUrl + "/api/services/app/Calender/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CalenderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CalenderDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CalenderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalenderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CalenderDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Calender/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectCalender(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Calender/ApproveOrRejectCalender";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectCalender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectCalender(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectCalender(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChangePswdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<ChangePasswordDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordDto>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ChangePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordForSuperAdmin(body: ChangePasswordSuperAdminDto | undefined): Observable<ChangePasswordSuperAdminOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/ChangePasswordForSuperAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePasswordForSuperAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePasswordForSuperAdmin(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordSuperAdminOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordSuperAdminOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processChangePasswordForSuperAdmin(response: HttpResponseBase): Observable<ChangePasswordSuperAdminOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordSuperAdminOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordSuperAdminOutputDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPasswordManager(body: WMSPasswordManagerDto | undefined): Observable<WMSPasswordManagerDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/CreatePasswordManager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePasswordManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePasswordManager(<any>response_);
                } catch (e) {
                    return <Observable<WMSPasswordManagerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WMSPasswordManagerDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePasswordManager(response: HttpResponseBase): Observable<WMSPasswordManagerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WMSPasswordManagerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WMSPasswordManagerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPasswordManager(input: string | null | undefined): Observable<WMSPasswordManagerDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/GetPasswordManager?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordManager(<any>response_);
                } catch (e) {
                    return <Observable<WMSPasswordManagerDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WMSPasswordManagerDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordManager(response: HttpResponseBase): Observable<WMSPasswordManagerDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WMSPasswordManagerDetailsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WMSPasswordManagerDetailsDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    encryptPassword(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/EncryptPassword?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEncryptPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEncryptPassword(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processEncryptPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    decryptPassword(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/DecryptPassword?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecryptPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecryptPassword(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDecryptPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param currentUser (optional) 
     * @param keyword (optional) 
     * @param username (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(currentUser: number | undefined, keyword: string | null | undefined, username: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RequestedUsersListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangePswd/GetAll?";
        if (currentUser === null)
            throw new Error("The parameter 'currentUser' cannot be null.");
        else if (currentUser !== undefined)
            url_ += "CurrentUser=" + encodeURIComponent("" + currentUser) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (username !== undefined && username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RequestedUsersListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestedUsersListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RequestedUsersListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestedUsersListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestedUsersListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class ChecklistTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ChecklistTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ChecklistTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChecklistTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ChecklistTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChecklistTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChecklistTypeDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param subPlantId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, subPlantId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ChecklistTypeListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ChecklistTypeListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChecklistTypeListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ChecklistTypeListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChecklistTypeListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChecklistTypeListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateChecklistTypeDto | undefined): Observable<ChecklistTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ChecklistTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChecklistTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ChecklistTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChecklistTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChecklistTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ChecklistTypeDto | undefined): Observable<ChecklistTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ChecklistTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChecklistTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ChecklistTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChecklistTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChecklistTypeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectChecklistType(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChecklistType/ApproveOrRejectChecklistType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectChecklistType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectChecklistType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectChecklistType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClientFormsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ClientFormsDto | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ClientFormsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFormsDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ClientFormsDto | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ClientFormsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFormsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ClientFormsDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientFormsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFormsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientFormsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param clientId (optional) 
     * @param formName (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, clientId: number | null | undefined, formName: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientFormsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientFormsService/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (formName !== undefined && formName !== null)
            url_ += "FormName=" + encodeURIComponent("" + formName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ClientFormsDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFormsDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClientFormsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFormsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFormsDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConsumptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateConsumptionHeaderDto | undefined): Observable<ConsumptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ConsumptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ConsumptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumptionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ConsumptionDto | undefined): Observable<ConsumptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ConsumptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConsumptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumptionDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param processOrderId (optional) 
     * @param productId (optional) 
     * @param processBarcodeId (optional) 
     * @param equipmentBracodeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, processOrderId: number | null | undefined, productId: string | null | undefined, processBarcodeId: number | null | undefined, equipmentBracodeId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ConsumptionListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (processBarcodeId !== undefined && processBarcodeId !== null)
            url_ += "processBarcodeId=" + encodeURIComponent("" + processBarcodeId) + "&";
        if (equipmentBracodeId !== undefined && equipmentBracodeId !== null)
            url_ += "equipmentBracodeId=" + encodeURIComponent("" + equipmentBracodeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ConsumptionListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumptionListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ConsumptionListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumptionListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumptionListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCodeNew(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetAllProductCodeNew?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCodeNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCodeNew(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCodeNew(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getMaterialsOfProductCode(input: string | null | undefined, processOrderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetMaterialsOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialsOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialsOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialsOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param materialid (optional) 
     * @return Success
     */
    getBatchNosDetails(input: string | null | undefined, materialid: string | null | undefined): Observable<ConsumptionDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetBatchNosDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (materialid !== undefined && materialid !== null)
            url_ += "materialid=" + encodeURIComponent("" + materialid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosDetails(<any>response_);
                } catch (e) {
                    return <Observable<ConsumptionDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumptionDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosDetails(response: HttpResponseBase): Observable<ConsumptionDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ConsumptionDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumptionDetailDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ConsumptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ConsumptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ConsumptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProcessOrderByCubicleId(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Consumption/GetProcessOrderByCubicleId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderByCubicleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderByCubicleId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderByCubicleId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CubicleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CubicleDto> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CubicleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CubicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleDto>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @param cubicleCode (optional) 
     * @param sLOCId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(plantId: number | null | undefined, cubicleCode: string | null | undefined, sLOCId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CubicleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/GetAll?";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "CubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (sLOCId !== undefined && sLOCId !== null)
            url_ += "SLOCId=" + encodeURIComponent("" + sLOCId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CubicleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CubicleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCubicleDto | undefined): Observable<CubicleDto> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CubicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CubicleDto | undefined): Observable<CubicleDto> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CubicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectCubicle(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cubicle/ApproveOrRejectCubicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectCubicle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectCubicle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CubicleAssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSampling(id: number | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetSampling?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSampling(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param processOrderId (optional) 
     * @param inspectionLotId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, processOrderId: number | null | undefined, inspectionLotId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CubicleAssignmentListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (inspectionLotId !== undefined && inspectionLotId !== null)
            url_ += "InspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CubicleAssignmentListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param processOrderId (optional) 
     * @param inspectionLotId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSampling(keyword: string | null | undefined, processOrderId: number | null | undefined, inspectionLotId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CubicleAssignmentListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetAllSampling?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (inspectionLotId !== undefined && inspectionLotId !== null)
            url_ += "InspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSampling(response: HttpResponseBase): Observable<CubicleAssignmentListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyGrouping(body: CubicleAssignmentListDto[] | null | undefined): Observable<CubicleAssignmentListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/ApplyGrouping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyGrouping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyGrouping(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processApplyGrouping(response: HttpResponseBase): Observable<CubicleAssignmentListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubicleAssignmentListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCubicleAssignmentDto | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSampling(body: CreateCubicleAssignmentDto | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/CreateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSampling(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CubicleAssignmentDto | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSampling(body: CubicleAssignmentDto | undefined): Observable<CubicleAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/UpdateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSampling(response: HttpResponseBase): Observable<CubicleAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isSampling (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined, isSampling: boolean | undefined, processOrderId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getInspectionLotNoOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetInspectionLotNoOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInspectionLotNoOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInspectionLotNoOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInspectionLotNoOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getBatchNosOfProductCode(input: string | null | undefined, processOrderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetBatchNosOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getBatchNosOfProductCodeForSampling(input: string | null | undefined, processOrderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetBatchNosOfProductCodeForSampling?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosOfProductCodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosOfProductCodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosOfProductCodeForSampling(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @param isReservationNo (optional) 
     * @return Success
     */
    getBatchNosDetails(input: string | null | undefined, processOrderId: number | undefined, isReservationNo: boolean | undefined): Observable<CubicleAssignmentDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetBatchNosDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (isReservationNo === null)
            throw new Error("The parameter 'isReservationNo' cannot be null.");
        else if (isReservationNo !== undefined)
            url_ += "isReservationNo=" + encodeURIComponent("" + isReservationNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosDetails(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosDetails(response: HttpResponseBase): Observable<CubicleAssignmentDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubicleAssignmentDetailsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDetailsDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getBatchNosDetailsForSampling(input: string | null | undefined, processOrderId: number | undefined): Observable<CubicleAssignmentDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignment/GetBatchNosDetailsForSampling?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosDetailsForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosDetailsForSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosDetailsForSampling(response: HttpResponseBase): Observable<CubicleAssignmentDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubicleAssignmentDetailsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentDetailsDto[]>(<any>null);
    }
}

@Injectable()
export class CubicleAssignmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCubicleAssignmentsDto | undefined): Observable<CubicleAssignmentsDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CubicleAssignmentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CubicleAssignmentsDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CubicleAssignmentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentsDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param productId (optional) 
     * @param processOrderId (optional) 
     * @param cubicleBarcodeId (optional) 
     * @param equipmentBarcodeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, productId: number | null | undefined, processOrderId: number | null | undefined, cubicleBarcodeId: number | null | undefined, equipmentBarcodeId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CubicleAssignmentsListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (cubicleBarcodeId !== undefined && cubicleBarcodeId !== null)
            url_ += "CubicleBarcodeId=" + encodeURIComponent("" + cubicleBarcodeId) + "&";
        if (equipmentBarcodeId !== undefined && equipmentBarcodeId !== null)
            url_ += "EquipmentBarcodeId=" + encodeURIComponent("" + equipmentBarcodeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentsListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentsListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CubicleAssignmentsListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentsListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentsListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CubicleAssignmentsDto | undefined): Observable<CubicleAssignmentsDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CubicleAssignmentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<CubicleAssignmentsDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignmentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignmentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<CubicleAssignmentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleAssignmentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignmentsDto>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @return Success
     */
    getCubicleIsCleaned(cubicleId: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetCubicleIsCleaned?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleIsCleaned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleIsCleaned(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleIsCleaned(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param equipmentId (optional) 
     * @return Success
     */
    getEquipmentIsCleaned(equipmentId: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/GetEquipmentIsCleaned?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquipmentIsCleaned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquipmentIsCleaned(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEquipmentIsCleaned(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidationForProcessOrder(body: CreateCubicleAssignmentsDto | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleAssignments/CheckValidationForProcessOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidationForProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidationForProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckValidationForProcessOrder(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }
}

@Injectable()
export class CubicleCleaningServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCubicleCleaningTransactionDto | undefined): Observable<CubicleCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleCleaning/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CubicleCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleCleaningTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSampling(body: CreateCubicleCleaningTransactionDto | undefined): Observable<CubicleCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleCleaning/CreateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampling(<any>response_);
                } catch (e) {
                    return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSampling(response: HttpResponseBase): Observable<CubicleCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleCleaningTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CubicleCleaningTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CubicleCleaning/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSampling(body: CubicleCleaningTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CubicleCleaning/UpdateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampling(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSampling(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param type (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    validateCubicleStatus(cubicleId: number | undefined, type: number | undefined, isSampling: boolean | undefined): Observable<CubicleCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/CubicleCleaning/ValidateCubicleStatus?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCubicleStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCubicleStatus(<any>response_);
                } catch (e) {
                    return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCubicleStatus(response: HttpResponseBase): Observable<CubicleCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubicleCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleCleaningTransactionDto>(<any>null);
    }
}

@Injectable()
export class DepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param departmentCode (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, departmentCode: string | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DepartmentListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (departmentCode !== undefined && departmentCode !== null)
            url_ += "DepartmentCode=" + encodeURIComponent("" + departmentCode) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DepartmentListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDepartmentDto | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DepartmentDto | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Department/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectDepartment(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Department/ApproveOrRejectDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectDepartment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectDepartment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DestructionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialDetailToDestructionDtoByBarcode(body: DestructionDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Destruction/UpdateMaterialDetailToDestructionDtoByBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialDetailToDestructionDtoByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialDetailToDestructionDtoByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialDetailToDestructionDtoByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    postDestructionDetailToSAP(): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Destruction/PostDestructionDetailToSAP";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDestructionDetailToSAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDestructionDetailToSAP(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostDestructionDetailToSAP(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param deviceTypeId (optional) 
     * @param deviceId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, deviceTypeId: number | null | undefined, deviceId: string | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DeviceListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (deviceTypeId !== undefined && deviceTypeId !== null)
            url_ += "DeviceTypeId=" + encodeURIComponent("" + deviceTypeId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DeviceListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DeviceListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDeviceDto | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DeviceDto | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectDevice(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/ApproveOrRejectDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DispensingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllCubicleBarcode(input: string | null | undefined): Observable<CubicleBarcodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllCubicleBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCubicleBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCubicleBarcode(<any>response_);
                } catch (e) {
                    return <Observable<CubicleBarcodeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleBarcodeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCubicleBarcode(response: HttpResponseBase): Observable<CubicleBarcodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubicleBarcodeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleBarcodeDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getAllEquipmentBarcode(input: string | null | undefined, isSampling: boolean | undefined): Observable<EquipmentCleaningBarcodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllEquipmentBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentBarcode(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentBarcode(response: HttpResponseBase): Observable<EquipmentCleaningBarcodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EquipmentCleaningBarcodeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningBarcodeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCubicleCleaningType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllCubicleCleaningType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCubicleCleaningType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCubicleCleaningType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCubicleCleaningType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEquipmentCleaningType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllEquipmentCleaningType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentCleaningType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentCleaningType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentCleaningType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getAllGroupCode(cubicleId: number | undefined, isSampling: boolean | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllGroupCode?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroupCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroupCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGroupCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param subModuleName (optional) 
     * @param modeId (optional) 
     * @return Success
     */
    getCheckpointsBySubModuleIdId(subModuleName: string | null | undefined, modeId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetCheckpointsBySubModuleIdId?";
        if (subModuleName !== undefined && subModuleName !== null)
            url_ += "subModuleName=" + encodeURIComponent("" + subModuleName) + "&";
        if (modeId === null)
            throw new Error("The parameter 'modeId' cannot be null.");
        else if (modeId !== undefined)
            url_ += "modeId=" + encodeURIComponent("" + modeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsBySubModuleIdId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsBySubModuleIdId(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsBySubModuleIdId(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @param status (optional) 
     * @return Success
     */
    getStatusByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined, status: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetStatusByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusByModuleSubModuleName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    geSubmoduleAllStatusList(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GeSubmoduleAllStatusList?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeSubmoduleAllStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeSubmoduleAllStatusList(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGeSubmoduleAllStatusList(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    isCubicleCleaned(cubicleId: number | undefined, isSampling: boolean | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/IsCubicleCleaned?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsCubicleCleaned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsCubicleCleaned(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processIsCubicleCleaned(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param groupId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    rejectLineClearanceTransaction(cubicleId: number | null | undefined, groupId: number | null | undefined, isSampling: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/RejectLineClearanceTransaction?";
        if (cubicleId !== undefined && cubicleId !== null)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectLineClearanceTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectLineClearanceTransaction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRejectLineClearanceTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    getStatusListByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetStatusListByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusListByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusListByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusListByModuleSubModuleName(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param validationError (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateErrorResponse(validationError: string | null | undefined, body: HTTPResponseDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/UpdateErrorResponse?";
        if (validationError !== undefined && validationError !== null)
            url_ += "ValidationError=" + encodeURIComponent("" + validationError) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateErrorResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateErrorResponse(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateErrorResponse(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @param baseUOMId (optional) 
     * @param conversionUOMId (optional) 
     * @param quantity (optional) 
     * @return Success
     */
    getConvertedQuantityByUOM(materialCode: string | null | undefined, baseUOMId: number | undefined, conversionUOMId: number | undefined, quantity: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetConvertedQuantityByUOM?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (baseUOMId === null)
            throw new Error("The parameter 'baseUOMId' cannot be null.");
        else if (baseUOMId !== undefined)
            url_ += "baseUOMId=" + encodeURIComponent("" + baseUOMId) + "&";
        if (conversionUOMId === null)
            throw new Error("The parameter 'conversionUOMId' cannot be null.");
        else if (conversionUOMId !== undefined)
            url_ += "ConversionUOMId=" + encodeURIComponent("" + conversionUOMId) + "&";
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "quantity=" + encodeURIComponent("" + quantity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConvertedQuantityByUOM(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConvertedQuantityByUOM(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetConvertedQuantityByUOM(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllUOMByMaterialCode(input: string | null | undefined): Observable<MaterialDispensingInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllUOMByMaterialCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUOMByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUOMByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUOMByMaterialCode(response: HttpResponseBase): Observable<MaterialDispensingInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialDispensingInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDispensingInternalDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param uomId (optional) 
     * @return Success
     */
    getBalanceByBarcode(input: string | null | undefined, uomId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetBalanceByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalanceByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getAllSuggestedBalances(uomId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllSuggestedBalances?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestedBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestedBalances(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestedBalances(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @param sapBatchNumber (optional) 
     * @param inspectionLotId (optional) 
     * @return Success
     */
    getAllSamplingUOMByMaterialCode(materialCode: string | null | undefined, sapBatchNumber: string | null | undefined, inspectionLotId: number | undefined): Observable<MaterialDispensingInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetAllSamplingUOMByMaterialCode?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (sapBatchNumber !== undefined && sapBatchNumber !== null)
            url_ += "sapBatchNumber=" + encodeURIComponent("" + sapBatchNumber) + "&";
        if (inspectionLotId === null)
            throw new Error("The parameter 'inspectionLotId' cannot be null.");
        else if (inspectionLotId !== undefined)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSamplingUOMByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSamplingUOMByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSamplingUOMByMaterialCode(response: HttpResponseBase): Observable<MaterialDispensingInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialDispensingInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDispensingInternalDto[]>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @param inspectionLotId (optional) 
     * @param sAPBatchNo (optional) 
     * @return Success
     */
    getSamplingBaseUOM(materialCode: string | null | undefined, inspectionLotId: number | null | undefined, sAPBatchNo: string | null | undefined): Observable<DispensingUnitOfMeasurementDto> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetSamplingBaseUOM?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (inspectionLotId !== undefined && inspectionLotId !== null)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        if (sAPBatchNo !== undefined && sAPBatchNo !== null)
            url_ += "SAPBatchNo=" + encodeURIComponent("" + sAPBatchNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSamplingBaseUOM(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSamplingBaseUOM(<any>response_);
                } catch (e) {
                    return <Observable<DispensingUnitOfMeasurementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DispensingUnitOfMeasurementDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSamplingBaseUOM(response: HttpResponseBase): Observable<DispensingUnitOfMeasurementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DispensingUnitOfMeasurementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispensingUnitOfMeasurementDto>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getCubicleCleaningStatus(cubicleId: number | undefined, isSampling: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetCubicleCleaningStatus?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleCleaningStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleCleaningStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleCleaningStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getCubicleLineClearanceStatus(cubicleId: number | undefined, isSampling: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetCubicleLineClearanceStatus?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleLineClearanceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleLineClearanceStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleLineClearanceStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getCubicleOverallStatus(cubicleId: number | undefined, isSampling: boolean | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Dispensing/GetCubicleOverallStatus?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleOverallStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleOverallStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleOverallStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ElogApiServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    all_showAllTables(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/All_showAllTables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll_showAllTables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll_showAllTables(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAll_showAllTables(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tableName (optional) 
     * @param columnName (optional) 
     * @param values (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    formDataPush(tableName: string | null | undefined, columnName: string | null | undefined, values: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/FormDataPush?";
        if (tableName !== undefined && tableName !== null)
            url_ += "TableName=" + encodeURIComponent("" + tableName) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (values !== undefined && values !== null)
            url_ += "Values=" + encodeURIComponent("" + values) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormDataPush(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormDataPush(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFormDataPush(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param pagenumber (optional) 
     * @param pagesize (optional) 
     * @return Success
     */
    getcreateForms(tablename: string | null | undefined, pagenumber: number | undefined, pagesize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetcreateForms?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (pagenumber === null)
            throw new Error("The parameter 'pagenumber' cannot be null.");
        else if (pagenumber !== undefined)
            url_ += "pagenumber=" + encodeURIComponent("" + pagenumber) + "&";
        if (pagesize === null)
            throw new Error("The parameter 'pagesize' cannot be null.");
        else if (pagesize !== undefined)
            url_ += "pagesize=" + encodeURIComponent("" + pagesize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcreateForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcreateForms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetcreateForms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @return Success
     */
    showTableColumns(tablename: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/showTableColumns?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowTableColumns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowTableColumns(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShowTableColumns(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    getspTableStructureToBeCreate(tablename: string | null | undefined, columnName: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/GetspTableStructureToBeCreate?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetspTableStructureToBeCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetspTableStructureToBeCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetspTableStructureToBeCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param limit (optional) 
     * @param condition (optional) 
     * @param conditionText (optional) 
     * @return Success
     */
    fetchTableWiseData(tablename: string | null | undefined, columnName: string | null | undefined, limit: number | undefined, condition: string | null | undefined, conditionText: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElogApiService/FetchTableWiseData?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (condition !== undefined && condition !== null)
            url_ += "Condition=" + encodeURIComponent("" + condition) + "&";
        if (conditionText !== undefined && conditionText !== null)
            url_ += "ConditionText=" + encodeURIComponent("" + conditionText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTableWiseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTableWiseData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTableWiseData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ElogControlsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ElogControlsDto | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ElogControlsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElogControlsDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ElogControlsDto | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ElogControlsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElogControlsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ElogControlsDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ElogControlsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElogControlsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ElogControlsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param eLogId (optional) 
     * @param controlLabel (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(id: number | null | undefined, eLogId: number | null | undefined, controlLabel: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ElogControlsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ElogControlsService/GetAll?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (eLogId !== undefined && eLogId !== null)
            url_ += "ELogId=" + encodeURIComponent("" + eLogId) + "&";
        if (controlLabel !== undefined && controlLabel !== null)
            url_ += "ControlLabel=" + encodeURIComponent("" + controlLabel) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ElogControlsDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElogControlsDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ElogControlsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElogControlsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElogControlsDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class EquipmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EquipmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EquipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentDto>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @param sLOCId (optional) 
     * @param equipmentTypeId (optional) 
     * @param equipmentCode (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(plantId: number | null | undefined, sLOCId: number | null | undefined, equipmentTypeId: number | null | undefined, equipmentCode: string | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EquipmentListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/GetAll?";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (sLOCId !== undefined && sLOCId !== null)
            url_ += "SLOCId=" + encodeURIComponent("" + sLOCId) + "&";
        if (equipmentTypeId !== undefined && equipmentTypeId !== null)
            url_ += "EquipmentTypeId=" + encodeURIComponent("" + equipmentTypeId) + "&";
        if (equipmentCode !== undefined && equipmentCode !== null)
            url_ += "EquipmentCode=" + encodeURIComponent("" + equipmentCode) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EquipmentListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEquipmentDto | undefined): Observable<EquipmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EquipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EquipmentDto | undefined): Observable<EquipmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EquipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectEquipment(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Equipment/ApproveOrRejectEquipment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectEquipment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectEquipment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectEquipment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EquipmentAssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getCubicle(input: string | null | undefined): Observable<EquipmentAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/GetCubicle?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicle(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicle(response: HttpResponseBase): Observable<EquipmentAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentAssignmentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getCubicleForSampling(input: string | null | undefined): Observable<EquipmentAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/GetCubicleForSampling?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleForSampling(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentAssignmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentAssignmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleForSampling(response: HttpResponseBase): Observable<EquipmentAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentAssignmentDto>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param equipmentBarcode (optional) 
     * @param groupId (optional) 
     * @return Success
     */
    getAllEquipmentAssignmentBarcode(cubicleId: number | undefined, equipmentBarcode: string | null | undefined, groupId: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/GetAllEquipmentAssignmentBarcode?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "CubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (equipmentBarcode !== undefined && equipmentBarcode !== null)
            url_ += "EquipmentBarcode=" + encodeURIComponent("" + equipmentBarcode) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentAssignmentBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentAssignmentBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentAssignmentBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param equipmentBarcode (optional) 
     * @param groupId (optional) 
     * @return Success
     */
    getAllEquipmentAssignmentBarcodeForSampling(cubicleId: number | undefined, equipmentBarcode: string | null | undefined, groupId: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/GetAllEquipmentAssignmentBarcodeForSampling?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "CubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (equipmentBarcode !== undefined && equipmentBarcode !== null)
            url_ += "EquipmentBarcode=" + encodeURIComponent("" + equipmentBarcode) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentAssignmentBarcodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentAssignmentBarcodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentAssignmentBarcodeForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignEquipment(body: EquipmentAssignmentDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/AssignEquipment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignEquipment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignEquipment(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAssignEquipment(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignEquipmentForSampling(body: EquipmentAssignmentDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/AssignEquipmentForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignEquipmentForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignEquipmentForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAssignEquipmentForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deAssignEquipment(body: EquipmentAssignmentDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/DeAssignEquipment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeAssignEquipment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeAssignEquipment(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processDeAssignEquipment(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deAssignEquipmentForSampling(body: EquipmentAssignmentDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentAssignment/DeAssignEquipmentForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeAssignEquipmentForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeAssignEquipmentForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processDeAssignEquipmentForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class EquipmentCleaningServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEquipmentCleaningTransactionDto | undefined): Observable<EquipmentCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentCleaning/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EquipmentCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSampling(body: CreateEquipmentCleaningTransactionDto | undefined): Observable<EquipmentCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentCleaning/CreateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampling(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSampling(response: HttpResponseBase): Observable<EquipmentCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EquipmentCleaningTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentCleaning/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSampling(body: EquipmentCleaningTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentCleaning/UpdateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampling(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSampling(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param equipmentId (optional) 
     * @param type (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    validateEquipmentStatus(equipmentId: number | undefined, type: number | undefined, isSampling: boolean | undefined): Observable<EquipmentCleaningTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentCleaning/ValidateEquipmentStatus?";
        if (equipmentId === null)
            throw new Error("The parameter 'equipmentId' cannot be null.");
        else if (equipmentId !== undefined)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateEquipmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateEquipmentStatus(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateEquipmentStatus(response: HttpResponseBase): Observable<EquipmentCleaningTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentCleaningTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningTransactionDto>(<any>null);
    }
}

@Injectable()
export class EquipmentUsageLogServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param checklistId (optional) 
     * @param modeId (optional) 
     * @return Success
     */
    getCheckpointsByChecklistId(checklistId: number | undefined, modeId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetCheckpointsByChecklistId?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        if (modeId === null)
            throw new Error("The parameter 'modeId' cannot be null.");
        else if (modeId !== undefined)
            url_ += "modeId=" + encodeURIComponent("" + modeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsByChecklistId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsByChecklistId(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsByChecklistId(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEquipmentUsageLogDto | undefined): Observable<EquipmentUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EquipmentUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentUsageLogDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EquipmentUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EquipmentUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentUsageLogDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEquipmentUsageLogDto | undefined): Observable<EquipmentUsageLogDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentUsageLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentUsageLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EquipmentUsageLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentUsageLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentUsageLogDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param activityId (optional) 
     * @param equipmentBracodeId (optional) 
     * @param processBarcodeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, activityId: number | null | undefined, equipmentBracodeId: number | null | undefined, processBarcodeId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EquipmentUsageLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activityId !== undefined && activityId !== null)
            url_ += "ActivityId=" + encodeURIComponent("" + activityId) + "&";
        if (equipmentBracodeId !== undefined && equipmentBracodeId !== null)
            url_ += "equipmentBracodeId=" + encodeURIComponent("" + equipmentBracodeId) + "&";
        if (processBarcodeId !== undefined && processBarcodeId !== null)
            url_ += "processBarcodeId=" + encodeURIComponent("" + processBarcodeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentUsageLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentUsageLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EquipmentUsageLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentUsageLogListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentUsageLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param checklistId (optional) 
     * @return Success
     */
    getCheckpointsList(checklistId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetCheckpointsList?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsList(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsList(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isFxdPort (optional) 
     * @return Success
     */
    getAllEquipmentBarcode(input: string | null | undefined, isFxdPort: boolean | undefined): Observable<EquipmentCleaningBarcodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetAllEquipmentBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isFxdPort === null)
            throw new Error("The parameter 'isFxdPort' cannot be null.");
        else if (isFxdPort !== undefined)
            url_ += "isFxdPort=" + encodeURIComponent("" + isFxdPort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentBarcode(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentBarcode(response: HttpResponseBase): Observable<EquipmentCleaningBarcodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EquipmentCleaningBarcodeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningBarcodeDto[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @param status (optional) 
     * @return Success
     */
    getStatusByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined, status: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetStatusByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusByModuleSubModuleName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    geSubmoduleAllStatusList(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GeSubmoduleAllStatusList?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeSubmoduleAllStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeSubmoduleAllStatusList(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGeSubmoduleAllStatusList(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    getStatusListByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/EquipmentUsageLogService/GetStatusListByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusListByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusListByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusListByModuleSubModuleName(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }
}

@Injectable()
export class FgPickingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FgPickingDto | undefined): Observable<FgPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FgPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBulk(body: FgPickingDto[] | null | undefined): Observable<FgPickingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/CreateBulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulk(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBulk(response: HttpResponseBase): Observable<FgPickingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FgPickingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOBDCodeIfAlreadyExist(input: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetOBDCodeIfAlreadyExist?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDCodeIfAlreadyExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDCodeIfAlreadyExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDCodeIfAlreadyExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPickingOBDDetailsIfAlreadyExist(input: string | null | undefined): Observable<FgPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetPickingOBDDetailsIfAlreadyExist?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickingOBDDetailsIfAlreadyExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickingOBDDetailsIfAlreadyExist(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickingOBDDetailsIfAlreadyExist(response: HttpResponseBase): Observable<FgPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingDto>(<any>null);
    }

    /**
     * @return Success
     */
    getPendingList(): Observable<FgPickingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetPendingList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingList(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingList(response: HttpResponseBase): Observable<FgPickingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<FgPickingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FgPickingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<FgPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FgPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: FgPickingDto | undefined): Observable<FgPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FgPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOBDDetails(input: string | null | undefined): Observable<OBDDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetOBDDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDDetails(<any>response_);
                } catch (e) {
                    return <Observable<OBDDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OBDDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDDetails(response: HttpResponseBase): Observable<OBDDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OBDDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OBDDetailDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOBDDetailsList(): Observable<OBDDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetOBDDetailsList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDDetailsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDDetailsList(<any>response_);
                } catch (e) {
                    return <Observable<OBDDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OBDDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDDetailsList(response: HttpResponseBase): Observable<OBDDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OBDDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OBDDetailDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param oBD (optional) 
     * @param productId (optional) 
     * @param productBatchNo (optional) 
     * @param batch (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, oBD: string | null | undefined, productId: number | null | undefined, productBatchNo: string | null | undefined, batch: string | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FgPickingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPickingService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (oBD !== undefined && oBD !== null)
            url_ += "OBD=" + encodeURIComponent("" + oBD) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productBatchNo !== undefined && productBatchNo !== null)
            url_ += "ProductBatchNo=" + encodeURIComponent("" + productBatchNo) + "&";
        if (batch !== undefined && batch !== null)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPickingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FgPickingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPickingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPickingListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class FgPutAwayServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FgPutAwayDto | undefined): Observable<FgPutAwayDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FgPutAwayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param palletId (optional) 
     * @param palletBarcode (optional) 
     * @param palletCount (optional) 
     * @param locationId (optional) 
     * @param locationBarcode (optional) 
     * @param isActive (optional) 
     * @param isPicked (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, palletId: number | null | undefined, palletBarcode: string | null | undefined, palletCount: number | undefined, locationId: number | null | undefined, locationBarcode: string | null | undefined, isActive: boolean | null | undefined, isPicked: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FgPutAwayListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (palletId !== undefined && palletId !== null)
            url_ += "PalletId=" + encodeURIComponent("" + palletId) + "&";
        if (palletBarcode !== undefined && palletBarcode !== null)
            url_ += "PalletBarcode=" + encodeURIComponent("" + palletBarcode) + "&";
        if (palletCount === null)
            throw new Error("The parameter 'palletCount' cannot be null.");
        else if (palletCount !== undefined)
            url_ += "PalletCount=" + encodeURIComponent("" + palletCount) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (locationBarcode !== undefined && locationBarcode !== null)
            url_ += "LocationBarcode=" + encodeURIComponent("" + locationBarcode) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (isPicked !== undefined && isPicked !== null)
            url_ += "isPicked=" + encodeURIComponent("" + isPicked) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FgPutAwayListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param productBatchNo (optional) 
     * @return Success
     */
    getSuggestedLocation(productBatchNo: string | null | undefined): Observable<FgPutAwayListDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/GetSuggestedLocation?";
        if (productBatchNo !== undefined && productBatchNo !== null)
            url_ += "ProductBatchNo=" + encodeURIComponent("" + productBatchNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuggestedLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuggestedLocation(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSuggestedLocation(response: HttpResponseBase): Observable<FgPutAwayListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<FgPutAwayListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FgPutAwayListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getPendingList(): Observable<FgPutAwayListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/GetPendingList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingList(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingList(response: HttpResponseBase): Observable<FgPutAwayListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<FgPutAwayDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FgPutAwayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBulk(body: FgPutAwayDto[] | null | undefined): Observable<FgPutAwayDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/CreateBulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulk(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBulk(response: HttpResponseBase): Observable<FgPutAwayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FgPutAwayDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: FgPutAwayDto | undefined): Observable<FgPutAwayDto> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FgPutAwayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FgPutAwayDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FgPutAwayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FgPutAwayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FgPutAwayDto>(<any>null);
    }

    /**
     * @param putAwayId (optional) 
     * @param transactionId (optional) 
     * @return Success
     */
    unloadBin(putAwayId: number | undefined, transactionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FgPutAwayService/UnloadBin?";
        if (putAwayId === null)
            throw new Error("The parameter 'putAwayId' cannot be null.");
        else if (putAwayId !== undefined)
            url_ += "putAwayId=" + encodeURIComponent("" + putAwayId) + "&";
        if (transactionId !== undefined && transactionId !== null)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnloadBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnloadBin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnloadBin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GateDto> {
        let url_ = this.baseUrl + "/api/services/app/Gate/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateDto>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @param gateCode (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(plantId: number | null | undefined, gateCode: string | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GateListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Gate/GetAll?";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (gateCode !== undefined && gateCode !== null)
            url_ += "GateCode=" + encodeURIComponent("" + gateCode) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GateListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GateListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGateDto | undefined): Observable<GateDto> {
        let url_ = this.baseUrl + "/api/services/app/Gate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<GateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GateDto | undefined): Observable<GateDto> {
        let url_ = this.baseUrl + "/api/services/app/Gate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Gate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectGate(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Gate/ApproveOrRejectGate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectGate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectGate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectGate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GateEntryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GateEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/GateEntry/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GateEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param purchaseOrderId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, purchaseOrderId: number | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GateEntryListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GateEntry/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GateEntryListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateEntryListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGateEntryDto | undefined): Observable<GateEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/GateEntry/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GateEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGatePass(body: CreateGateEntryDto[] | null | undefined): Observable<GateEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/GateEntry/CreateGatePass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGatePass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGatePass(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGatePass(response: HttpResponseBase): Observable<GateEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateGateEntryDto | undefined): Observable<GateEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/GateEntry/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GateEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GateEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto>(<any>null);
    }
}

@Injectable()
export class GRNPostingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<GRNPostingDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GRNPostingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNPostingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GRNPostingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNPostingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNPostingDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param invoiceId (optional) 
     * @param purchaseOrderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, invoiceId: number | null | undefined, purchaseOrderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GRNPostingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<GRNPostingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNPostingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GRNPostingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNPostingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNPostingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGRNPostingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param validationError (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateErrorResponse(validationError: string | null | undefined, body: HTTPResponseDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/UpdateErrorResponse?";
        if (validationError !== undefined && validationError !== null)
            url_ += "ValidationError=" + encodeURIComponent("" + validationError) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateErrorResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateErrorResponse(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateErrorResponse(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllGRNHeaders(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/GetAllGRNHeaders?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGRNHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGRNHeaders(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGRNHeaders(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGRNDetailWithAllMaterialLabelPrinting(input: number | undefined): Observable<GRNMaterialLabelPrintingListDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/GetGRNDetailWithAllMaterialLabelPrinting?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGRNDetailWithAllMaterialLabelPrinting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGRNDetailWithAllMaterialLabelPrinting(<any>response_);
                } catch (e) {
                    return <Observable<GRNMaterialLabelPrintingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNMaterialLabelPrintingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGRNDetailWithAllMaterialLabelPrinting(response: HttpResponseBase): Observable<GRNMaterialLabelPrintingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNMaterialLabelPrintingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNMaterialLabelPrintingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGRNDetailWithAllMaterialLabelPrinting_material(input: number | undefined): Observable<GRNMaterialLabelPrintingListDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/GetGRNDetailWithAllMaterialLabelPrinting_material?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGRNDetailWithAllMaterialLabelPrinting_material(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGRNDetailWithAllMaterialLabelPrinting_material(<any>response_);
                } catch (e) {
                    return <Observable<GRNMaterialLabelPrintingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNMaterialLabelPrintingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGRNDetailWithAllMaterialLabelPrinting_material(response: HttpResponseBase): Observable<GRNMaterialLabelPrintingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNMaterialLabelPrintingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNMaterialLabelPrintingListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printMaterialLabels(body: GRNMaterialLabelPrintingDto | undefined): Observable<GRNMaterialLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/PrintMaterialLabels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintMaterialLabels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintMaterialLabels(<any>response_);
                } catch (e) {
                    return <Observable<GRNMaterialLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNMaterialLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrintMaterialLabels(response: HttpResponseBase): Observable<GRNMaterialLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNMaterialLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNMaterialLabelPrintingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printMaterialLabelRange(body: GRNMaterialLabelPrintingDto | undefined): Observable<GRNMaterialLabelPrintingDto> {
        let url_ = this.baseUrl + "/api/services/app/GRNPosting/PrintMaterialLabelRange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintMaterialLabelRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintMaterialLabelRange(<any>response_);
                } catch (e) {
                    return <Observable<GRNMaterialLabelPrintingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNMaterialLabelPrintingDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrintMaterialLabelRange(response: HttpResponseBase): Observable<GRNMaterialLabelPrintingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GRNMaterialLabelPrintingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNMaterialLabelPrintingDto>(<any>null);
    }
}

@Injectable()
export class HandlingUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<HandlingUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<HandlingUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandlingUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HandlingUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandlingUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandlingUnitDto>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @param keyword (optional) 
     * @param handlingUnitTypeId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(plantId: number | null | undefined, keyword: string | null | undefined, handlingUnitTypeId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HandlingUnitListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/GetAll?";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (handlingUnitTypeId !== undefined && handlingUnitTypeId !== null)
            url_ += "HandlingUnitTypeId=" + encodeURIComponent("" + handlingUnitTypeId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<HandlingUnitListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandlingUnitListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HandlingUnitListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandlingUnitListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandlingUnitListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHandlingUnitDto | undefined): Observable<HandlingUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<HandlingUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandlingUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HandlingUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandlingUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandlingUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: HandlingUnitDto | undefined): Observable<HandlingUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<HandlingUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandlingUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HandlingUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HandlingUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandlingUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectHandlingUnit(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HandlingUnit/ApproveOrRejectHandlingUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectHandlingUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectHandlingUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectHandlingUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HardwareConnectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printerAvailable(body: Connection | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HardwareConnection/PrinterAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrinterAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrinterAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPrinterAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    weighingMachineAvailable(body: Connection | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HardwareConnection/WeighingMachineAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeighingMachineAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeighingMachineAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processWeighingMachineAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class InspectionChecklistServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InspectionChecklistDto> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<InspectionChecklistDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InspectionChecklistDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InspectionChecklistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InspectionChecklistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InspectionChecklistDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param plantId (optional) 
     * @param moduleId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, plantId: number | null | undefined, moduleId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<InspectionChecklistListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<InspectionChecklistListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InspectionChecklistListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InspectionChecklistListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InspectionChecklistListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InspectionChecklistListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateInspectionChecklistDto | undefined): Observable<InspectionChecklistDto> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<InspectionChecklistDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InspectionChecklistDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InspectionChecklistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InspectionChecklistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InspectionChecklistDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: InspectionChecklistDto | undefined): Observable<InspectionChecklistDto> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<InspectionChecklistDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InspectionChecklistDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InspectionChecklistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InspectionChecklistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InspectionChecklistDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param checkpoints (optional) 
     * @return Success
     */
    deleteCheckpoints(checkpoints: CheckpointMaster[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/DeleteCheckpoints?";
        if (checkpoints !== undefined && checkpoints !== null)
            checkpoints && checkpoints.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "checkpoints[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCheckpoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCheckpoints(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCheckpoints(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectInspectionCheklist(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InspectionChecklist/ApproveOrRejectInspectionCheklist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectInspectionCheklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectInspectionCheklist(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectInspectionCheklist(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InwardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    getMaterialSelectListDto(purchaseOrderId: number | undefined): Observable<MaterialSelectWithDescriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetMaterialSelectListDto?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialSelectListDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialSelectListDto(<any>response_);
                } catch (e) {
                    return <Observable<MaterialSelectWithDescriptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialSelectWithDescriptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialSelectListDto(response: HttpResponseBase): Observable<MaterialSelectWithDescriptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialSelectWithDescriptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialSelectWithDescriptionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGateEntries(input: string | null | undefined): Observable<GateEntryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetGateEntries?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntries(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGateEntries(response: HttpResponseBase): Observable<GateEntryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GateEntryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    validateGateEntries(input: string | null | undefined): Observable<GateEntryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/validateGateEntries?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateGateEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateGateEntries(<any>response_);
                } catch (e) {
                    return <Observable<GateEntryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateEntryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processValidateGateEntries(response: HttpResponseBase): Observable<GateEntryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GateEntryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateEntryDto[]>(<any>null);
    }

    /**
     * @param checklistId (optional) 
     * @param modeId (optional) 
     * @return Success
     */
    getCheckpointsByChecklistId(checklistId: number | undefined, modeId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetCheckpointsByChecklistId?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        if (modeId === null)
            throw new Error("The parameter 'modeId' cannot be null.");
        else if (modeId !== undefined)
            url_ += "modeId=" + encodeURIComponent("" + modeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsByChecklistId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsByChecklistId(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsByChecklistId(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    getInvoiceByPurchaseOrderId(purchaseOrderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetInvoiceByPurchaseOrderId?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceByPurchaseOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceByPurchaseOrderId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceByPurchaseOrderId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @param input (optional) 
     * @return Success
     */
    getInvoiceByPurchaseOrderIdAutoComplete(purchaseOrderId: number | undefined, input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetInvoiceByPurchaseOrderIdAutoComplete?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceByPurchaseOrderIdAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceByPurchaseOrderIdAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceByPurchaseOrderIdAutoComplete(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getMaterialByInvoiceId(invoiceId: number | undefined): Observable<MaterialInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetMaterialByInvoiceId?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialByInvoiceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialByInvoiceId(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialByInvoiceId(response: HttpResponseBase): Observable<MaterialInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInternalDto[]>(<any>null);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getMaterialWithMIDoneandGRNPending(invoiceId: number | undefined): Observable<MaterialInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetMaterialWithMIDoneandGRNPending?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialWithMIDoneandGRNPending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialWithMIDoneandGRNPending(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialWithMIDoneandGRNPending(response: HttpResponseBase): Observable<MaterialInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInternalDto[]>(<any>null);
    }

    /**
     * @param materialId (optional) 
     * @param invoiceId (optional) 
     * @param materialIds (optional) 
     * @return Success
     */
    getMaterialDetailsWithMIDoneandGRNPending(materialId: number | undefined, invoiceId: number | undefined, materialIds: number[] | null | undefined): Observable<GRNPostingDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetMaterialDetailsWithMIDoneandGRNPending?";
        if (materialId === null)
            throw new Error("The parameter 'materialId' cannot be null.");
        else if (materialId !== undefined)
            url_ += "materialId=" + encodeURIComponent("" + materialId) + "&";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (materialIds !== undefined && materialIds !== null)
            materialIds && materialIds.forEach(item => { url_ += "materialIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialDetailsWithMIDoneandGRNPending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialDetailsWithMIDoneandGRNPending(<any>response_);
                } catch (e) {
                    return <Observable<GRNPostingDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GRNPostingDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialDetailsWithMIDoneandGRNPending(response: HttpResponseBase): Observable<GRNPostingDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GRNPostingDetailsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GRNPostingDetailsDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWeighingMachineAutoComplete(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetWeighingMachineAutoComplete?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeighingMachineAutoComplete(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isWeightUOM (optional) 
     * @return Success
     */
    getWeighingMachineDetails(input: string | null | undefined, isWeightUOM: boolean | undefined): Observable<WeighingMachineSelectWithDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetWeighingMachineDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isWeightUOM === null)
            throw new Error("The parameter 'isWeightUOM' cannot be null.");
        else if (isWeightUOM !== undefined)
            url_ += "isWeightUOM=" + encodeURIComponent("" + isWeightUOM) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineDetails(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineSelectWithDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineSelectWithDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeighingMachineDetails(response: HttpResponseBase): Observable<WeighingMachineSelectWithDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineSelectWithDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineSelectWithDetailsDto>(<any>null);
    }

    /**
     * @param materialId (optional) 
     * @return Success
     */
    getConsignmentByMaterialId(materialId: number | undefined): Observable<MaterialConsignmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetConsignmentByMaterialId?";
        if (materialId === null)
            throw new Error("The parameter 'materialId' cannot be null.");
        else if (materialId !== undefined)
            url_ += "materialId=" + encodeURIComponent("" + materialId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsignmentByMaterialId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsignmentByMaterialId(<any>response_);
                } catch (e) {
                    return <Observable<MaterialConsignmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialConsignmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsignmentByMaterialId(response: HttpResponseBase): Observable<MaterialConsignmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialConsignmentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialConsignmentDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllPalletsBarcode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetAllPalletsBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletsBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletsBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletsBarcode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param searchText (optional) 
     * @return Success
     */
    getAllMaterialSelectListDto(searchText: string | null | undefined): Observable<MaterialBarcodePrintingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetAllMaterialSelectListDto?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterialSelectListDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterialSelectListDto(<any>response_);
                } catch (e) {
                    return <Observable<MaterialBarcodePrintingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialBarcodePrintingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaterialSelectListDto(response: HttpResponseBase): Observable<MaterialBarcodePrintingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialBarcodePrintingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialBarcodePrintingDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllLocationsBarcode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetAllLocationsBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocationsBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocationsBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocationsBarcode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param locationId (optional) 
     * @param transferTypeId (optional) 
     * @return Success
     */
    validateBinBarocde(locationId: number | undefined, transferTypeId: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/Inward/ValidateBinBarocde?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (transferTypeId === null)
            throw new Error("The parameter 'transferTypeId' cannot be null.");
        else if (transferTypeId !== undefined)
            url_ += "transferTypeId=" + encodeURIComponent("" + transferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateBinBarocde(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateBinBarocde(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateBinBarocde(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param palletId (optional) 
     * @param transferTypeId (optional) 
     * @return Success
     */
    validatePalletBarocde(palletId: number | undefined, transferTypeId: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/Inward/ValidatePalletBarocde?";
        if (palletId === null)
            throw new Error("The parameter 'palletId' cannot be null.");
        else if (palletId !== undefined)
            url_ += "palletId=" + encodeURIComponent("" + palletId) + "&";
        if (transferTypeId === null)
            throw new Error("The parameter 'transferTypeId' cannot be null.");
        else if (transferTypeId !== undefined)
            url_ += "transferTypeId=" + encodeURIComponent("" + transferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatePalletBarocde(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatePalletBarocde(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidatePalletBarocde(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateMaterialBarocdeOnPalletization(body: MaterialBarcodePrintingDto | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/Inward/ValidateMaterialBarocdeOnPalletization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMaterialBarocdeOnPalletization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMaterialBarocdeOnPalletization(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateMaterialBarocdeOnPalletization(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param locationId (optional) 
     * @param transferTypeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateMaterialBarcode(locationId: number | undefined, transferTypeId: number | undefined, body: MaterialBarcodePrintingDto | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/Inward/ValidateMaterialBarcode?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (transferTypeId === null)
            throw new Error("The parameter 'transferTypeId' cannot be null.");
        else if (transferTypeId !== undefined)
            url_ += "transferTypeId=" + encodeURIComponent("" + transferTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMaterialBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMaterialBarcode(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateMaterialBarcode(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getUnitOfMeasurementDetailsById(uomId: number | undefined): Observable<UnitOfMeasurementListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetUnitOfMeasurementDetailsById?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurementDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurementDetailsById(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasurementListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasurementListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurementDetailsById(response: HttpResponseBase): Observable<UnitOfMeasurementListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UnitOfMeasurementListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasurementListDto[]>(<any>null);
    }

    /**
     * @param ipAddress (optional) 
     * @param portNumber (optional) 
     * @return Success
     */
    getWeightFromWeighingMachine(ipAddress: string | null | undefined, portNumber: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetWeightFromWeighingMachine?";
        if (ipAddress !== undefined && ipAddress !== null)
            url_ += "ipAddress=" + encodeURIComponent("" + ipAddress) + "&";
        if (portNumber !== undefined && portNumber !== null)
            url_ += "portNumber=" + encodeURIComponent("" + portNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightFromWeighingMachine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightFromWeighingMachine(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightFromWeighingMachine(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param ipAddress (optional) 
     * @param portNumber (optional) 
     * @return Success
     */
    getWeightForTesting(ipAddress: string | null | undefined, portNumber: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetWeightForTesting?";
        if (ipAddress !== undefined && ipAddress !== null)
            url_ += "ipAddress=" + encodeURIComponent("" + ipAddress) + "&";
        if (portNumber === null)
            throw new Error("The parameter 'portNumber' cannot be null.");
        else if (portNumber !== undefined)
            url_ += "portNumber=" + encodeURIComponent("" + portNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightForTesting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightForTesting(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightForTesting(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getVehicleInspectionPurchaseOrders(): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetVehicleInspectionPurchaseOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleInspectionPurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleInspectionPurchaseOrders(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehicleInspectionPurchaseOrders(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getGateEntryPurchaseOrders(): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Inward/GetGateEntryPurchaseOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntryPurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntryPurchaseOrders(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGateEntryPurchaseOrders(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }
}

@Injectable()
export class IssueToProductionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateIssueToProductionDto | undefined): Observable<IssueToProductionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IssueToProduction/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<IssueToProductionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IssueToProductionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IssueToProductionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IssueToProductionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IssueToProductionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDispensedProcessOrders(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/IssueToProduction/GetDispensedProcessOrders?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispensedProcessOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispensedProcessOrders(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispensedProcessOrders(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getDispensedProcessOrderMaterials(processOrderId: number | undefined): Observable<IssueToProductionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IssueToProduction/GetDispensedProcessOrderMaterials?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispensedProcessOrderMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispensedProcessOrderMaterials(<any>response_);
                } catch (e) {
                    return <Observable<IssueToProductionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IssueToProductionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispensedProcessOrderMaterials(response: HttpResponseBase): Observable<IssueToProductionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IssueToProductionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IssueToProductionDto[]>(<any>null);
    }
}

@Injectable()
export class LineClearanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLineClearanceTransactionDto | undefined): Observable<LineClearanceTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/LineClearance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LineClearanceTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineClearanceTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LineClearanceTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LineClearanceTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineClearanceTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSampling(body: CreateLineClearanceTransactionDto | undefined): Observable<LineClearanceTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/LineClearance/CreateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampling(<any>response_);
                } catch (e) {
                    return <Observable<LineClearanceTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineClearanceTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSampling(response: HttpResponseBase): Observable<LineClearanceTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LineClearanceTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineClearanceTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LineClearanceTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LineClearance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSampling(body: LineClearanceTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LineClearance/UpdateSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampling(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSampling(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param cubicleId (optional) 
     * @param groupId (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    validateLineClearance(cubicleId: number | undefined, groupId: number | undefined, isSampling: boolean | undefined): Observable<LineClearanceTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/LineClearance/ValidateLineClearance?";
        if (cubicleId === null)
            throw new Error("The parameter 'cubicleId' cannot be null.");
        else if (cubicleId !== undefined)
            url_ += "cubicleId=" + encodeURIComponent("" + cubicleId) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateLineClearance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateLineClearance(<any>response_);
                } catch (e) {
                    return <Observable<LineClearanceTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineClearanceTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateLineClearance(response: HttpResponseBase): Observable<LineClearanceTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LineClearanceTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineClearanceTransactionDto>(<any>null);
    }
}

@Injectable()
export class LoadingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LoadingDto | undefined): Observable<LoadingDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LoadingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LoadingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBulk(body: LoadingDto[] | null | undefined): Observable<LoadingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/CreateBulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulk(<any>response_);
                } catch (e) {
                    return <Observable<LoadingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBulk(response: HttpResponseBase): Observable<LoadingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LoadingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOBDCodeIfAlreadyExist(input: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetOBDCodeIfAlreadyExist?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDCodeIfAlreadyExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDCodeIfAlreadyExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDCodeIfAlreadyExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getPendingList(): Observable<LoadingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetPendingList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingList(<any>response_);
                } catch (e) {
                    return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingList(response: HttpResponseBase): Observable<LoadingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<LoadingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<LoadingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LoadingDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LoadingDto | undefined): Observable<LoadingDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LoadingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LoadingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOBDDetails(input: string | null | undefined): Observable<OBDDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetOBDDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDDetails(<any>response_);
                } catch (e) {
                    return <Observable<OBDDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OBDDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDDetails(response: HttpResponseBase): Observable<OBDDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OBDDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OBDDetailDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOBDDetailsList(): Observable<OBDDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetOBDDetailsList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDDetailsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDDetailsList(<any>response_);
                } catch (e) {
                    return <Observable<OBDDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OBDDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDDetailsList(response: HttpResponseBase): Observable<OBDDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OBDDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OBDDetailDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param oBD (optional) 
     * @param productId (optional) 
     * @param productBatchNo (optional) 
     * @param batch (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, oBD: string | null | undefined, productId: number | null | undefined, productBatchNo: string | null | undefined, batch: string | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LoadingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadingService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (oBD !== undefined && oBD !== null)
            url_ += "OBD=" + encodeURIComponent("" + oBD) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productBatchNo !== undefined && productBatchNo !== null)
            url_ += "ProductBatchNo=" + encodeURIComponent("" + productBatchNo) + "&";
        if (batch !== undefined && batch !== null)
            url_ += "Batch=" + encodeURIComponent("" + batch) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LoadingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoadingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }

    /**
     * @param locationCode (optional) 
     * @param plantId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(locationCode: string | null | undefined, plantId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LocationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/GetAll?";
        if (locationCode !== undefined && locationCode !== null)
            url_ += "LocationCode=" + encodeURIComponent("" + locationCode) + "&";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LocationListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LocationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLocationDto | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LocationDto | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectLocation(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/ApproveOrRejectLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectLocation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MaterialServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SAPMaterial | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Material/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    get(materialCode: string | null | undefined): Observable<SAPMaterial> {
        let url_ = this.baseUrl + "/api/services/app/Material/Get?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SAPMaterial>><any>_observableThrow(e);
                }
            } else
                return <Observable<SAPMaterial>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SAPMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SAPMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SAPMaterial>(<any>null);
    }
}

@Injectable()
export class MaterialDispensingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRLAFByBarcode(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetRLAFByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRLAFByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRLAFByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRLAFByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getMaterialByProcessOrderId(processOrderId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetMaterialByProcessOrderId?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialByProcessOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialByProcessOrderId(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialByProcessOrderId(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSAPBatchByMaterialCode(body: MaterialDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/UpdateSAPBatchByMaterialCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSAPBatchByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSAPBatchByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSAPBatchByMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRequiredQuantityToDispensingDto(body: MaterialDispensingDto | undefined): Observable<MaterialDispensingDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/UpdateRequiredQuantityToDispensingDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRequiredQuantityToDispensingDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRequiredQuantityToDispensingDto(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDispensingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDispensingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRequiredQuantityToDispensingDto(response: HttpResponseBase): Observable<MaterialDispensingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDispensingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDispensingDto>(<any>null);
    }

    /**
     * @param dispensingHeaderId (optional) 
     * @param sAPBatchNo (optional) 
     * @param containerMaterialBarcode (optional) 
     * @return Success
     */
    getDespensingDetailsStatus(dispensingHeaderId: number | undefined, sAPBatchNo: string | null | undefined, containerMaterialBarcode: string | null | undefined): Observable<GetDespensingDetailsStatus> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetDespensingDetailsStatus?";
        if (dispensingHeaderId === null)
            throw new Error("The parameter 'dispensingHeaderId' cannot be null.");
        else if (dispensingHeaderId !== undefined)
            url_ += "dispensingHeaderId=" + encodeURIComponent("" + dispensingHeaderId) + "&";
        if (sAPBatchNo !== undefined && sAPBatchNo !== null)
            url_ += "SAPBatchNo=" + encodeURIComponent("" + sAPBatchNo) + "&";
        if (containerMaterialBarcode !== undefined && containerMaterialBarcode !== null)
            url_ += "ContainerMaterialBarcode=" + encodeURIComponent("" + containerMaterialBarcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDespensingDetailsStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDespensingDetailsStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetDespensingDetailsStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDespensingDetailsStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetDespensingDetailsStatus(response: HttpResponseBase): Observable<GetDespensingDetailsStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDespensingDetailsStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDespensingDetailsStatus>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @param sapBatchNumber (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getAllUOMByMaterialCode(materialCode: string | null | undefined, sapBatchNumber: string | null | undefined, processOrderId: number | undefined): Observable<MaterialDispensingInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetAllUOMByMaterialCode?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (sapBatchNumber !== undefined && sapBatchNumber !== null)
            url_ += "sapBatchNumber=" + encodeURIComponent("" + sapBatchNumber) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUOMByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUOMByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDispensingInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUOMByMaterialCode(response: HttpResponseBase): Observable<MaterialDispensingInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialDispensingInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDispensingInternalDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param uomId (optional) 
     * @return Success
     */
    getBalanceByBarcode(input: string | null | undefined, uomId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetBalanceByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalanceByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialContainerByBarcode(body: MaterialDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/UpdateMaterialContainerByBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialContainerByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialContainerByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialContainerByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialBatchDispensingVerify(body: GetDespensingDetailsStatus | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/UpdateMaterialBatchDispensingVerify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialBatchDispensingVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialBatchDispensingVerify(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialBatchDispensingVerify(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getAllSuggestedCalibratedBalances(uomId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetAllSuggestedCalibratedBalances?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestedCalibratedBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestedCalibratedBalances(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestedCalibratedBalances(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @return Success
     */
    getWeightByWeighingMachineCode(weighingMachineId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/GetWeightByWeighingMachineCode?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightByWeighingMachineCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightByWeighingMachineCode(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightByWeighingMachineCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reprintDispensingDetail(body: MaterialDispensingDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/ReprintDispensingDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReprintDispensingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReprintDispensingDetail(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processReprintDispensingDetail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printDispensingBarcode(body: MaterialDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/PrintDispensingBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintDispensingBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintDispensingBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrintDispensingBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    varifyDispensingBarcode(body: MaterialDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/varifyDispensingBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVarifyDispensingBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVarifyDispensingBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processVarifyDispensingBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeDispensing(body: MaterialDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/CompleteDispensing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteDispensing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteDispensing(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteDispensing(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllMaterialDispensingDetailBySAPBatch(body: MaterialDispensingDto | undefined): Observable<MaterialDispensingDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialDispensing/UpdateAllMaterialDispensingDetailBySAPBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllMaterialDispensingDetailBySAPBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllMaterialDispensingDetailBySAPBatch(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDispensingDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDispensingDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllMaterialDispensingDetailBySAPBatch(response: HttpResponseBase): Observable<MaterialDispensingDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialDispensingDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDispensingDetailDto[]>(<any>null);
    }
}

@Injectable()
export class MaterialInspectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MaterialInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MaterialInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInspectionDto>(<any>null);
    }

    /**
     * @param materialId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getWithMaterial(materialId: number | undefined, id: number | undefined): Observable<MaterialInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/GetWithMaterial?";
        if (materialId === null)
            throw new Error("The parameter 'materialId' cannot be null.");
        else if (materialId !== undefined)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWithMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWithMaterial(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWithMaterial(response: HttpResponseBase): Observable<MaterialInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInspectionDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param transactionStatusId (optional) 
     * @param purchaseOrderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, transactionStatusId: number | null | undefined, purchaseOrderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MaterialInspectionListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (transactionStatusId !== undefined && transactionStatusId !== null)
            url_ += "TransactionStatusId=" + encodeURIComponent("" + transactionStatusId) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInspectionListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInspectionListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MaterialInspectionListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialInspectionListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInspectionListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMaterialInspectionDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MaterialInspectionDto | undefined): Observable<MaterialInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MaterialInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialInspectionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeInspection(body: CompleteInspectionEntityDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/CompleteInspection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteInspection(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteInspection(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptOrRejectInspection(body: AcceptRejectInspectionCheckpointDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/AcceptOrRejectInspection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptOrRejectInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptOrRejectInspection(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptOrRejectInspection(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param gateEntryId (optional) 
     * @param pO_Number (optional) 
     * @param invoice_Number (optional) 
     * @param invoiceId (optional) 
     * @return Success
     */
    isMaterialInspectionPresent(gateEntryId: number | null | undefined, pO_Number: string | null | undefined, invoice_Number: string | null | undefined, invoiceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/IsMaterialInspectionPresent?";
        if (gateEntryId !== undefined && gateEntryId !== null)
            url_ += "GateEntryId=" + encodeURIComponent("" + gateEntryId) + "&";
        if (pO_Number !== undefined && pO_Number !== null)
            url_ += "PO_Number=" + encodeURIComponent("" + pO_Number) + "&";
        if (invoice_Number !== undefined && invoice_Number !== null)
            url_ += "invoice_Number=" + encodeURIComponent("" + invoice_Number) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsMaterialInspectionPresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsMaterialInspectionPresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsMaterialInspectionPresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param gateEntryId (optional) 
     * @param pO_Number (optional) 
     * @param invoice_Number (optional) 
     * @param invoiceId (optional) 
     * @return Success
     */
    isVehicleInspectionIsInProgress(gateEntryId: number | null | undefined, pO_Number: string | null | undefined, invoice_Number: string | null | undefined, invoiceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInspection/IsVehicleInspectionIsInProgress?";
        if (gateEntryId !== undefined && gateEntryId !== null)
            url_ += "GateEntryId=" + encodeURIComponent("" + gateEntryId) + "&";
        if (pO_Number !== undefined && pO_Number !== null)
            url_ += "PO_Number=" + encodeURIComponent("" + pO_Number) + "&";
        if (invoice_Number !== undefined && invoice_Number !== null)
            url_ += "invoice_Number=" + encodeURIComponent("" + invoice_Number) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsVehicleInspectionIsInProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsVehicleInspectionIsInProgress(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsVehicleInspectionIsInProgress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class MaterialIStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMaterilStatusList(): Observable<MaterialStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetAllMaterilStatusList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterilStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterilStatusList(<any>response_);
                } catch (e) {
                    return <Observable<MaterialStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaterilStatusList(response: HttpResponseBase): Observable<MaterialStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialStatusDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sapBatchNumber (optional) 
     * @return Success
     */
    getMaterilDetailById(id: number | undefined, sapBatchNumber: string | null | undefined): Observable<MaterialDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetMaterilDetailById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (sapBatchNumber !== undefined && sapBatchNumber !== null)
            url_ += "sapBatchNumber=" + encodeURIComponent("" + sapBatchNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterilDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterilDetailById(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterilDetailById(response: HttpResponseBase): Observable<MaterialDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDetailDto>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    getMaterilDetailByIdOnly(materialCode: string | null | undefined): Observable<MaterialDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetMaterilDetailByIdOnly?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterilDetailByIdOnly(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterilDetailByIdOnly(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterilDetailByIdOnly(response: HttpResponseBase): Observable<MaterialDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDetailDto>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    getMaterilDetailByIdOnlyMfgDetails(materialCode: string | null | undefined): Observable<MaterialDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetMaterilDetailByIdOnlyMfgDetails?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterilDetailByIdOnlyMfgDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterilDetailByIdOnlyMfgDetails(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterilDetailByIdOnlyMfgDetails(response: HttpResponseBase): Observable<MaterialDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDetailDto>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    getMaterilDetailByIdOnlyPO(materialCode: string | null | undefined): Observable<MaterialDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetMaterilDetailByIdOnlyPO?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterilDetailByIdOnlyPO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterilDetailByIdOnlyPO(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterilDetailByIdOnlyPO(response: HttpResponseBase): Observable<MaterialDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDetailDto>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    getMaterilDetailByIdOnlySampling(materialCode: string | null | undefined): Observable<MaterialDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialIStatus/GetMaterilDetailByIdOnlySampling?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterilDetailByIdOnlySampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterilDetailByIdOnlySampling(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterilDetailByIdOnlySampling(response: HttpResponseBase): Observable<MaterialDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDetailDto>(<any>null);
    }
}

@Injectable()
export class MaterialReturnSapServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertMaterialReturn(body: MaterialRteturnDetailsSAPDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnSapService/InsertMaterialReturn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertMaterialReturn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertMaterialReturn(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertMaterialReturn(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnSapService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterialReturnSAPDetailsList(): Observable<MaterialRteturnDetailsSAP[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnSapService/GetMaterialReturnSAPDetailsList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialReturnSAPDetailsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialReturnSAPDetailsList(<any>response_);
                } catch (e) {
                    return <Observable<MaterialRteturnDetailsSAP[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialRteturnDetailsSAP[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialReturnSAPDetailsList(response: HttpResponseBase): Observable<MaterialRteturnDetailsSAP[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialRteturnDetailsSAP.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialRteturnDetailsSAP[]>(<any>null);
    }
}

@Injectable()
export class MaterialReturnServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMaterialReturnDto | undefined): Observable<MaterialReturnDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MaterialReturnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialReturnDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MaterialReturnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialReturnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialReturnDto>(<any>null);
    }

    /**
     * @param containerId (optional) 
     * @return Success
     */
    isContainerBarcodePresent(containerId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/IsContainerBarcodePresent?";
        if (containerId !== undefined && containerId !== null)
            url_ += "ContainerId=" + encodeURIComponent("" + containerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsContainerBarcodePresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsContainerBarcodePresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsContainerBarcodePresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param productNo (optional) 
     * @param batchNo (optional) 
     * @param documentNo (optional) 
     * @param containerId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, productNo: string | null | undefined, batchNo: string | null | undefined, documentNo: string | null | undefined, containerId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MaterialReturnListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (productNo !== undefined && productNo !== null)
            url_ += "ProductNo=" + encodeURIComponent("" + productNo) + "&";
        if (batchNo !== undefined && batchNo !== null)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&";
        if (documentNo !== undefined && documentNo !== null)
            url_ += "DocumentNo=" + encodeURIComponent("" + documentNo) + "&";
        if (containerId !== undefined && containerId !== null)
            url_ += "ContainerId=" + encodeURIComponent("" + containerId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MaterialReturnListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialReturnListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MaterialReturnListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialReturnListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialReturnListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MaterialReturnDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MaterialReturnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialReturnDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MaterialReturnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialReturnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialReturnDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MaterialReturnDto | undefined): Observable<MaterialReturnDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MaterialReturnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialReturnDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MaterialReturnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialReturnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialReturnDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    print(body: MaterialReturnDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialReturnService/Print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MaterialSampleDispensingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRLAFByBarcode(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/GetRLAFByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRLAFByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRLAFByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRLAFByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param inspectionLotId (optional) 
     * @return Success
     */
    getMaterialByInspectionLotId(inspectionLotId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/GetMaterialByInspectionLotId?";
        if (inspectionLotId === null)
            throw new Error("The parameter 'inspectionLotId' cannot be null.");
        else if (inspectionLotId !== undefined)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialByInspectionLotId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialByInspectionLotId(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialByInspectionLotId(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSAPBatchByMaterialCode(body: MaterialSampleDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/UpdateSAPBatchByMaterialCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSAPBatchByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSAPBatchByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSAPBatchByMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRequiredQuantityToSampleDto(body: MaterialSampleDispensingDto | undefined): Observable<MaterialSampleDispensingDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/UpdateRequiredQuantityToSampleDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRequiredQuantityToSampleDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRequiredQuantityToSampleDto(<any>response_);
                } catch (e) {
                    return <Observable<MaterialSampleDispensingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialSampleDispensingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRequiredQuantityToSampleDto(response: HttpResponseBase): Observable<MaterialSampleDispensingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialSampleDispensingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialSampleDispensingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialContainerByBarcode(body: MaterialSampleDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/UpdateMaterialContainerByBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialContainerByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialContainerByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialContainerByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getAllSuggestedBalances(uomId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/GetAllSuggestedBalances?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuggestedBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuggestedBalances(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuggestedBalances(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printSamplingBarcode(body: MaterialSampleDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/PrintSamplingBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintSamplingBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintSamplingBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrintSamplingBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeSampling(body: MaterialSampleDispensingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/CompleteSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllMaterialDispensingDetailBySAPBatch(body: MaterialSampleDispensingDto | undefined): Observable<MaterialSampleDispensingDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/UpdateAllMaterialDispensingDetailBySAPBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllMaterialDispensingDetailBySAPBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllMaterialDispensingDetailBySAPBatch(<any>response_);
                } catch (e) {
                    return <Observable<MaterialSampleDispensingDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialSampleDispensingDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllMaterialDispensingDetailBySAPBatch(response: HttpResponseBase): Observable<MaterialSampleDispensingDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialSampleDispensingDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialSampleDispensingDetailDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSamplingTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/GetSamplingTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSamplingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSamplingTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSamplingTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reprintSamplingDetail(body: MaterialSampleDispensingDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialSampleDispensing/ReprintSamplingDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReprintSamplingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReprintSamplingDetail(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processReprintSamplingDetail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class MaterialStatusLabelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param materialContainerBarCode (optional) 
     * @return Success
     */
    getMaterialStatusLabelByMaterialBarcode(materialContainerBarCode: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStatusLabel/GetMaterialStatusLabelByMaterialBarcode?";
        if (materialContainerBarCode !== undefined && materialContainerBarCode !== null)
            url_ += "materialContainerBarCode=" + encodeURIComponent("" + materialContainerBarCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStatusLabelByMaterialBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStatusLabelByMaterialBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStatusLabelByMaterialBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param grnMaterilLabelprintingId (optional) 
     * @return Success
     */
    getCommonMaterilDetailById(grnMaterilLabelprintingId: number | undefined): Observable<MaterialStatusLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStatusLabel/GetCommonMaterilDetailById?";
        if (grnMaterilLabelprintingId === null)
            throw new Error("The parameter 'grnMaterilLabelprintingId' cannot be null.");
        else if (grnMaterilLabelprintingId !== undefined)
            url_ += "grnMaterilLabelprintingId=" + encodeURIComponent("" + grnMaterilLabelprintingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommonMaterilDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonMaterilDetailById(<any>response_);
                } catch (e) {
                    return <Observable<MaterialStatusLabelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialStatusLabelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommonMaterilDetailById(response: HttpResponseBase): Observable<MaterialStatusLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialStatusLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialStatusLabelDto>(<any>null);
    }
}

@Injectable()
export class MaterialVerificationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMaterialVerificationDto | undefined): Observable<MaterialVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MaterialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationDto>(<any>null);
    }

    /**
     * @param productID (optional) 
     * @param cageBarcodeId (optional) 
     * @return Success
     */
    isMaterialVerificationPresent(productID: number | null | undefined, cageBarcodeId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/IsMaterialVerificationPresent?";
        if (productID !== undefined && productID !== null)
            url_ += "ProductID=" + encodeURIComponent("" + productID) + "&";
        if (cageBarcodeId !== undefined && cageBarcodeId !== null)
            url_ += "CageBarcodeId=" + encodeURIComponent("" + cageBarcodeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsMaterialVerificationPresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsMaterialVerificationPresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsMaterialVerificationPresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MaterialVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MaterialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param productID (optional) 
     * @param processOrderId (optional) 
     * @param cubicleBarcodeId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, productID: number | null | undefined, processOrderId: number | null | undefined, cubicleBarcodeId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MaterialVerificationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (productID !== undefined && productID !== null)
            url_ += "ProductID=" + encodeURIComponent("" + productID) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (cubicleBarcodeId !== undefined && cubicleBarcodeId !== null)
            url_ += "CubicleBarcodeId=" + encodeURIComponent("" + cubicleBarcodeId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MaterialVerificationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialVerificationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MaterialVerificationDto | undefined): Observable<MaterialVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MaterialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMaterialDetails(input: number | undefined): Observable<ProcessOrderMaterialAfterRelease[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetMaterialDetails?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialDetails(<any>response_);
                } catch (e) {
                    return <Observable<ProcessOrderMaterialAfterRelease[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessOrderMaterialAfterRelease[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialDetails(response: HttpResponseBase): Observable<ProcessOrderMaterialAfterRelease[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcessOrderMaterialAfterRelease.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessOrderMaterialAfterRelease[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<MaterialVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<MaterialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllCageBarcode(input: string | null | undefined): Observable<MaterialVerificationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MaterialVerificationService/GetAllCageBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCageBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCageBarcode(<any>response_);
                } catch (e) {
                    return <Observable<MaterialVerificationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialVerificationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCageBarcode(response: HttpResponseBase): Observable<MaterialVerificationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialVerificationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialVerificationDto[]>(<any>null);
    }
}

@Injectable()
export class ModuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllModule(keyword: string | null | undefined, status: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ModuleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllModule?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModule(<any>response_);
                } catch (e) {
                    return <Observable<ModuleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllModule(response: HttpResponseBase): Observable<ModuleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param status (optional) 
     * @param moduleId (optional) 
     * @param approvalRequired (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSubModule(keyword: string | null | undefined, status: number | null | undefined, moduleId: number | null | undefined, approvalRequired: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SubModuleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllSubModule?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (approvalRequired !== undefined && approvalRequired !== null)
            url_ += "ApprovalRequired=" + encodeURIComponent("" + approvalRequired) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModule(<any>response_);
                } catch (e) {
                    return <Observable<SubModuleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubModuleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubModule(response: HttpResponseBase): Observable<SubModuleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubModuleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ModuleDto | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSubModules(id: number | undefined): Observable<SubModuleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubModules?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(<any>response_);
                } catch (e) {
                    return <Observable<SubModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SubModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubModuleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSubModule(id: number | undefined): Observable<SubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubModule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModule(<any>response_);
                } catch (e) {
                    return <Observable<SubModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubModule(response: HttpResponseBase): Observable<SubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubModuleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubModule(body: UpdateSubModuleDto | undefined): Observable<UpdateSubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/UpdateSubModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubModule(<any>response_);
                } catch (e) {
                    return <Observable<UpdateSubModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateSubModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubModule(response: HttpResponseBase): Observable<UpdateSubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateSubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateSubModuleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignSubModules(body: ModuleSubModuleDto | undefined): Observable<ModuleSubModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/AssignSubModules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignSubModules(<any>response_);
                } catch (e) {
                    return <Observable<ModuleSubModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleSubModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processAssignSubModules(response: HttpResponseBase): Observable<ModuleSubModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleSubModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSubModuleDto>(<any>null);
    }

    /**
     * @param moduleName (optional) 
     * @return Success
     */
    getModuleByName(moduleName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModuleByName?";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleByName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetModuleByName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param submoduleName (optional) 
     * @return Success
     */
    getSubmoduleByName(submoduleName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetSubmoduleByName?";
        if (submoduleName !== undefined && submoduleName !== null)
            url_ += "submoduleName=" + encodeURIComponent("" + submoduleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubmoduleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubmoduleByName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubmoduleByName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class OBDDetailsServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateOBDDetails(body: OBDDetailDto[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/OBDDetailsService/InsertOrUpdateOBDDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateOBDDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateOBDDetails(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateOBDDetails(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param oBD (optional) 
     * @param lineItemNo (optional) 
     * @param productCode (optional) 
     * @param productDesc (optional) 
     * @param productBatchNo (optional) 
     * @param aRNo (optional) 
     * @param sAPBatchNo (optional) 
     * @param qty (optional) 
     * @param uOM (optional) 
     * @param customerName (optional) 
     * @param customerAddress (optional) 
     * @return Success
     */
    getOBDCodeIfAlradyExist(oBD: string | null | undefined, lineItemNo: string | null | undefined, productCode: string | null | undefined, productDesc: string | null | undefined, productBatchNo: string | null | undefined, aRNo: string | null | undefined, sAPBatchNo: string | null | undefined, qty: number | null | undefined, uOM: number | null | undefined, customerName: string | null | undefined, customerAddress: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/OBDDetailsService/GetOBDCodeIfAlradyExist?";
        if (oBD !== undefined && oBD !== null)
            url_ += "OBD=" + encodeURIComponent("" + oBD) + "&";
        if (lineItemNo !== undefined && lineItemNo !== null)
            url_ += "LineItemNo=" + encodeURIComponent("" + lineItemNo) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (productDesc !== undefined && productDesc !== null)
            url_ += "ProductDesc=" + encodeURIComponent("" + productDesc) + "&";
        if (productBatchNo !== undefined && productBatchNo !== null)
            url_ += "ProductBatchNo=" + encodeURIComponent("" + productBatchNo) + "&";
        if (aRNo !== undefined && aRNo !== null)
            url_ += "ARNo=" + encodeURIComponent("" + aRNo) + "&";
        if (sAPBatchNo !== undefined && sAPBatchNo !== null)
            url_ += "SAPBatchNo=" + encodeURIComponent("" + sAPBatchNo) + "&";
        if (qty !== undefined && qty !== null)
            url_ += "Qty=" + encodeURIComponent("" + qty) + "&";
        if (uOM !== undefined && uOM !== null)
            url_ += "UOM=" + encodeURIComponent("" + uOM) + "&";
        if (customerName !== undefined && customerName !== null)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (customerAddress !== undefined && customerAddress !== null)
            url_ += "CustomerAddress=" + encodeURIComponent("" + customerAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOBDCodeIfAlradyExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOBDCodeIfAlradyExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOBDCodeIfAlradyExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class PackingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePackingDto | undefined): Observable<PackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PackingDto | undefined): Observable<PackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param containerCode (optional) 
     * @param productId (optional) 
     * @param processOrderId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, containerCode: string | null | undefined, productId: string | null | undefined, processOrderId: number | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PackingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (containerCode !== undefined && containerCode !== null)
            url_ += "ContainerCode=" + encodeURIComponent("" + containerCode) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PackingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PackingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProcessLabelCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetAllProcessLabelCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProcessLabelCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProcessLabelCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProcessLabelCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param locId (optional) 
     * @return Success
     */
    getAllDetails(input: string | null | undefined, locId: number | undefined): Observable<PackingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetAllDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDetails(<any>response_);
                } catch (e) {
                    return <Observable<PackingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDetails(response: HttpResponseBase): Observable<PackingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PackingListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    checkDuplicate(input: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/CheckDuplicate?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDuplicate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDuplicate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDuplicate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processorderId (optional) 
     * @return Success
     */
    checkProcessORderOfCOntainer(input: string | null | undefined, processorderId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/CheckProcessORderOfCOntainer?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processorderId === null)
            throw new Error("The parameter 'processorderId' cannot be null.");
        else if (processorderId !== undefined)
            url_ += "ProcessorderId=" + encodeURIComponent("" + processorderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckProcessORderOfCOntainer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckProcessORderOfCOntainer(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckProcessORderOfCOntainer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getLabelBCDetails(input: string | null | undefined): Observable<PackingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetLabelBCDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLabelBCDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLabelBCDetails(<any>response_);
                } catch (e) {
                    return <Observable<PackingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLabelBCDetails(response: HttpResponseBase): Observable<PackingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PackingListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(processOrderId: number | undefined): Observable<PackingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetProcessOrderDetails?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<PackingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<PackingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PackingListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<PackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PackingService/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<PackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<PackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackingDto>(<any>null);
    }
}

@Injectable()
export class PalletizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PalletizationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PalletizationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletizationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PalletizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PalletizationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletizationDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param palletId (optional) 
     * @param materialId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, palletId: number | null | undefined, materialId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PalletizationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (palletId !== undefined && palletId !== null)
            url_ += "PalletId=" + encodeURIComponent("" + palletId) + "&";
        if (materialId !== undefined && materialId !== null)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PalletizationListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletizationListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PalletizationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletizationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletizationListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePalletizationDto | undefined): Observable<PalletizationDto> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PalletizationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletizationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PalletizationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletizationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletizationDto>(<any>null);
    }

    /**
     * @param transactionId (optional) 
     * @param body (optional) 
     * @return Success
     */
    unloadPallets(transactionId: string | undefined, body: PalletizationDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/UnloadPallets?";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnloadPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnloadPallets(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnloadPallets(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPallets(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/GetAllPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPallets(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllPalletsBarcode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/Palletization/GetAllPalletsBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletsBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletsBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletsBarcode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }
}

@Injectable()
export class PalletMasterServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PalletMasterDto | undefined): Observable<PalletMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PalletMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PalletMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PalletMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getShipperCount(input: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/GetShipperCount?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShipperCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShipperCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetShipperCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param palletCodeId (optional) 
     * @param cartonBarcodeId (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(palletCodeId: number | null | undefined, cartonBarcodeId: number | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PalletMasterListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/GetAll?";
        if (palletCodeId !== undefined && palletCodeId !== null)
            url_ += "PalletCodeId=" + encodeURIComponent("" + palletCodeId) + "&";
        if (cartonBarcodeId !== undefined && cartonBarcodeId !== null)
            url_ += "CartonBarcodeId=" + encodeURIComponent("" + cartonBarcodeId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PalletMasterListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletMasterListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PalletMasterDto | undefined): Observable<PalletMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PalletMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PalletMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto>(<any>null);
    }

    /**
     * @return Success
     */
    getGridShipperCode(): Observable<PalletMasterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/GetGridShipperCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGridShipperCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGridShipperCode(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGridShipperCode(response: HttpResponseBase): Observable<PalletMasterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PalletMasterDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllPalletBarcode(input: string | null | undefined): Observable<PalletMasterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/GetAllPalletBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletBarcode(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletBarcode(response: HttpResponseBase): Observable<PalletMasterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PalletMasterDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllShipperBarcode(input: string | null | undefined): Observable<PalletMasterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PalletMasterService/GetAllShipperBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShipperBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShipperBarcode(<any>response_);
                } catch (e) {
                    return <Observable<PalletMasterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PalletMasterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllShipperBarcode(response: HttpResponseBase): Observable<PalletMasterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PalletMasterDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PalletMasterDto[]>(<any>null);
    }
}

@Injectable()
export class PickingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getCubicleByBarcode(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/GetCubicleByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getCubicleForSampling(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/GetCubicleForSampling?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePickingDtoByBinBarcode(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/UpdatePickingDtoByBinBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePickingDtoByBinBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePickingDtoByBinBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePickingDtoByBinBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleAssignmentHeaderId (optional) 
     * @return Success
     */
    getMaterialCodeByGroupId(cubicleAssignmentHeaderId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/GetMaterialCodeByGroupId?";
        if (cubicleAssignmentHeaderId === null)
            throw new Error("The parameter 'cubicleAssignmentHeaderId' cannot be null.");
        else if (cubicleAssignmentHeaderId !== undefined)
            url_ += "cubicleAssignmentHeaderId=" + encodeURIComponent("" + cubicleAssignmentHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialCodeByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialCodeByGroupId(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialCodeByGroupId(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSAPBatchNoByMaterialCode(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/UpdateSAPBatchNoByMaterialCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSAPBatchNoByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSAPBatchNoByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSAPBatchNoByMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSAPBatchNoByMaterialCodeForSampling(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/UpdateSAPBatchNoByMaterialCodeForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSAPBatchNoByMaterialCodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSAPBatchNoByMaterialCodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSAPBatchNoByMaterialCodeForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePickingDetail(body: PickingDto | undefined): Observable<PickingDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/UpdatePickingDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePickingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePickingDetail(<any>response_);
                } catch (e) {
                    return <Observable<PickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePickingDetail(response: HttpResponseBase): Observable<PickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PickingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePickingDetailForSampling(body: PickingDto | undefined): Observable<PickingDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/UpdatePickingDetailForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePickingDetailForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePickingDetailForSampling(<any>response_);
                } catch (e) {
                    return <Observable<PickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePickingDetailForSampling(response: HttpResponseBase): Observable<PickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PickingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveMaterialContainerFromBin(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/SaveMaterialContainerFromBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMaterialContainerFromBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMaterialContainerFromBin(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMaterialContainerFromBin(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveMaterialContainerFromBinForSampling(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/SaveMaterialContainerFromBinForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMaterialContainerFromBinForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMaterialContainerFromBinForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMaterialContainerFromBinForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completePicking(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/CompletePicking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePicking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePicking(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompletePicking(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completePickingForSampling(body: PickingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Picking/CompletePickingForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePickingForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePickingForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompletePickingForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class PlantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PlantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param plantTypeId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param countryId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, plantTypeId: number | null | undefined, activeInactiveStatusId: number | null | undefined, countryId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PlantListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (plantTypeId !== undefined && plantTypeId !== null)
            url_ += "PlantTypeId=" + encodeURIComponent("" + plantTypeId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PlantListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PlantListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePlantDto | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PlantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PlantDto | undefined): Observable<PlantDto> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PlantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PlantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Plant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectPlant(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Plant/ApproveOrRejectPlant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectPlant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectPlant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PostToSAPServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePostToSAPDto | undefined): Observable<PostToSAPDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PostToSAPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPDto>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    isProductCodePresent(processOrderId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/IsProductCodePresent?";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsProductCodePresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsProductCodePresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsProductCodePresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PostToSAPDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PostToSAPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PostToSAPDto | undefined): Observable<PostToSAPDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PostToSAPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPDto>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<PostToSAPListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PostToSAPListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PostToSAPListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PostToSAPListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<PostToSAPDto> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<PostToSAPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostToSAPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(processOrderId: number | undefined): Observable<PostToSAPListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PostToSAP/GetProcessOrderDetails?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<PostToSAPListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostToSAPListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<PostToSAPListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PostToSAPListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostToSAPListDto[]>(<any>null);
    }
}

@Injectable()
export class PreStageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getCubicleByBarcode(input: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/GetCubicleByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completePreStage(body: PreStageDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/CompletePreStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePreStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePreStage(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompletePreStage(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completePreStageForSampling(body: PreStageDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/CompletePreStageForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePreStageForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePreStageForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompletePreStageForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleCode (optional) 
     * @param groupCode (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getPickedMaterialCode(cubicleCode: string | null | undefined, groupCode: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/GetPickedMaterialCode?";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "cubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (groupCode !== undefined && groupCode !== null)
            url_ += "groupCode=" + encodeURIComponent("" + groupCode) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickedMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickedMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickedMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleCode (optional) 
     * @param groupCode (optional) 
     * @param materialCode (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getPickedSAPBatchNos(cubicleCode: string | null | undefined, groupCode: string | null | undefined, materialCode: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/GetPickedSAPBatchNos?";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "cubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (groupCode !== undefined && groupCode !== null)
            url_ += "groupCode=" + encodeURIComponent("" + groupCode) + "&";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickedSAPBatchNos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickedSAPBatchNos(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickedSAPBatchNos(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param isSampling (optional) 
     * @param body (optional) 
     * @return Success
     */
    updatePreStageDetail(isSampling: boolean | undefined, body: PreStageDto | undefined): Observable<PreStageDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/UpdatePreStageDetail?";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePreStageDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePreStageDetail(<any>response_);
                } catch (e) {
                    return <Observable<PreStageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PreStageDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePreStageDetail(response: HttpResponseBase): Observable<PreStageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreStageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreStageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePickedMaterialContainerDetails(body: PreStageDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/SavePickedMaterialContainerDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePickedMaterialContainerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePickedMaterialContainerDetails(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSavePickedMaterialContainerDetails(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePickedMaterialContainerDetailsForSampling(body: PreStageDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/PreStage/SavePickedMaterialContainerDetailsForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePickedMaterialContainerDetailsForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePickedMaterialContainerDetailsForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSavePickedMaterialContainerDetailsForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class PrintPackingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePrintPackingDto | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    print(body: PrintPackingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/Print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getList(id: number | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductNamebyProductcode(id: string | null | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetProductNamebyProductcode?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductNamebyProductcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductNamebyProductcode(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductNamebyProductcode(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessMaterialDetailsbyProcessOrder(input: number | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetProcessMaterialDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessMaterialDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessMaterialDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessMaterialDetailsbyProcessOrder(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PrintPackingDto | undefined): Observable<PrintPackingDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PrintPackingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProcessLabelCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetAllProcessLabelCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProcessLabelCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProcessLabelCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProcessLabelCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param processOrderNo (optional) 
     * @param productCode (optional) 
     * @param batchNo (optional) 
     * @param containerBarcode (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, processOrderNo: string | null | undefined, productCode: string | null | undefined, batchNo: string | null | undefined, containerBarcode: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PrintPackingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (processOrderNo !== undefined && processOrderNo !== null)
            url_ += "ProcessOrderNo=" + encodeURIComponent("" + processOrderNo) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (batchNo !== undefined && batchNo !== null)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&";
        if (containerBarcode !== undefined && containerBarcode !== null)
            url_ += "ContainerBarcode=" + encodeURIComponent("" + containerBarcode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PrintPackingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrintPackingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllContainerBarcode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetAllContainerBarcode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContainerBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContainerBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContainerBarcode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(processOrderId: number | undefined): Observable<PrintPackingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrintPackingService/GetProcessOrderDetails?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<PrintPackingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintPackingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<PrintPackingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrintPackingListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintPackingListDto[]>(<any>null);
    }
}

@Injectable()
export class PRNEntryServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PRNEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PRNEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PRNEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PRNEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PRNEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PRNEntryDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param moduleId (optional) 
     * @param subModuleId (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, moduleId: number | null | undefined, subModuleId: number | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PRNEntryListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (moduleId !== undefined && moduleId !== null)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (subModuleId !== undefined && subModuleId !== null)
            url_ += "SubModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PRNEntryListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PRNEntryListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PRNEntryListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PRNEntryListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PRNEntryListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePRNEntryDto | undefined): Observable<PRNEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PRNEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PRNEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PRNEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PRNEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PRNEntryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PRNEntryDto | undefined): Observable<PRNEntryDto> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PRNEntryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PRNEntryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PRNEntryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PRNEntryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PRNEntryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectActivity(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PRNEntryService/ApproveOrRejectActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectActivity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProcessLabelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProcessLabelDto | undefined): Observable<ProcessLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProcessLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    print(body: ProcessLabelDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/Print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ProcessLabelDto | undefined): Observable<ProcessLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProcessLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProcessLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProcessLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param processOrderId (optional) 
     * @param processOrderNo (optional) 
     * @param productCode (optional) 
     * @param cubicleCode (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, processOrderId: number | null | undefined, processOrderNo: string | null | undefined, productCode: string | null | undefined, cubicleCode: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ProcessLabelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (processOrderNo !== undefined && processOrderNo !== null)
            url_ += "ProcessOrderNo=" + encodeURIComponent("" + processOrderNo) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "CubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProcessLabelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getProductCode(): Observable<ProcessLabelListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetProductCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCode(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCode(response: HttpResponseBase): Observable<ProcessLabelListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param processOrderId (optional) 
     * @return Success
     */
    getMaterialsOfProductCode(input: string | null | undefined, processOrderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetMaterialsOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialsOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialsOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialsOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(processOrderId: number | undefined): Observable<ProcessLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetProcessOrderDetails?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<ProcessLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcessLabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBatchNosDetails(input: string | null | undefined): Observable<ProcessLabelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetBatchNosDetails?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosDetails(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosDetails(response: HttpResponseBase): Observable<ProcessLabelDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcessLabelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessDetailsbyProcessOrder(input: number | undefined): Observable<ProcessLabelDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessLabel/GetProcessDetailsbyProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessDetailsbyProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessDetailsbyProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<ProcessLabelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessLabelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessDetailsbyProcessOrder(response: HttpResponseBase): Observable<ProcessLabelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessLabelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessLabelDto>(<any>null);
    }
}

@Injectable()
export class ProcessOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ProcessOrderDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ProcessOrder/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(purchaseOrderId: number | undefined): Observable<ProcessOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessOrder/GetProcessOrderDetails?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<ProcessOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<ProcessOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProcessOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessOrderInternalDto[]>(<any>null);
    }
}

@Injectable()
export class ProcessOrderAfterReleasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateProcessOrderAfterRelease(body: ProcessOrderAfterReleasDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ProcessOrderAfterReleas/InsertUpdateProcessOrderAfterRelease";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateProcessOrderAfterRelease(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateProcessOrderAfterRelease(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateProcessOrderAfterRelease(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProcessOrderAfterReleasDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessOrderAfterReleas/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProcessOrderAfterReleasDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessOrderAfterReleasDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProcessOrderAfterReleasDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessOrderAfterReleasDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessOrderAfterReleasDto>(<any>null);
    }
}

@Injectable()
export class PurchaseOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PurchaseOrderDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrder/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    getPurchsaeOrderDetails(purchaseOrderId: number | undefined): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrder/GetPurchsaeOrderDetails?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchsaeOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchsaeOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPurchsaeOrderDetails(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }
}

@Injectable()
export class PutAwaysServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param materialToBinId (optional) 
     * @param palletToBinId (optional) 
     * @return Success
     */
    get(materialToBinId: string | null | undefined, palletToBinId: number | undefined): Observable<PutAwayBinToBinTransferDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PutAways/Get?";
        if (materialToBinId !== undefined && materialToBinId !== null)
            url_ += "materialToBinId=" + encodeURIComponent("" + materialToBinId) + "&";
        if (palletToBinId === null)
            throw new Error("The parameter 'palletToBinId' cannot be null.");
        else if (palletToBinId !== undefined)
            url_ += "palletToBinId=" + encodeURIComponent("" + palletToBinId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PutAwayBinToBinTransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PutAwayBinToBinTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param palletId (optional) 
     * @param materialId (optional) 
     * @param locationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, palletId: number | null | undefined, materialId: number | null | undefined, locationId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PutAwayBinToBinTransferListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PutAways/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (palletId !== undefined && palletId !== null)
            url_ += "PalletId=" + encodeURIComponent("" + palletId) + "&";
        if (materialId !== undefined && materialId !== null)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PutAwayBinToBinTransferListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutAwayBinToBinTransferListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePutAwayBinToBinTransferDto | undefined): Observable<PutAwayBinToBinTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/PutAways/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PutAwayBinToBinTransferDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutAwayBinToBinTransferDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PutAwayBinToBinTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutAwayBinToBinTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutAwayBinToBinTransferDto>(<any>null);
    }

    /**
     * @param putAwayId (optional) 
     * @param transationId (optional) 
     * @return Success
     */
    unloadBin(putAwayId: number | undefined, transationId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutAways/UnloadBin?";
        if (putAwayId === null)
            throw new Error("The parameter 'putAwayId' cannot be null.");
        else if (putAwayId !== undefined)
            url_ += "putAwayId=" + encodeURIComponent("" + putAwayId) + "&";
        if (transationId !== undefined && transationId !== null)
            url_ += "transationId=" + encodeURIComponent("" + transationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnloadBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnloadBin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnloadBin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PutawayServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePutawayDto | undefined): Observable<PutawayDto> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PutawayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutawayDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PutawayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutawayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutawayDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PutawayDto> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PutawayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutawayDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PutawayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutawayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutawayDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PutawayDto | undefined): Observable<PutawayDto> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PutawayDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutawayDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PutawayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutawayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutawayDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param containerCode (optional) 
     * @param locationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, containerCode: string | null | undefined, locationId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PutawayListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (containerCode !== undefined && containerCode !== null)
            url_ += "ContainerCode=" + encodeURIComponent("" + containerCode) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PutawayListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutawayListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PutawayListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutawayListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutawayListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<PutawayListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PutawayService/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<PutawayListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PutawayListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PutawayListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PutawayListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PutawayListDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class RecipeIntegrationSAPServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateRecipe(body: CreateRecipeMasterDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecipeIntegrationSAP/InsertOrUpdateRecipe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateRecipe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateRecipe(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateRecipe(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class RecipeMasterServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param productId (optional) 
     * @param productCode (optional) 
     * @param documentVersion (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(productId: number | undefined, productCode: string | null | undefined, documentVersion: string | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RecipeMasterListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetAll?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (documentVersion !== undefined && documentVersion !== null)
            url_ += "DocumentVersion=" + encodeURIComponent("" + documentVersion) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RecipeMasterListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeMasterListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RecipeMasterListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeMasterListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeMasterListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMaterial(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetMaterial?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterial(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterial(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param productCode (optional) 
     * @param documentVersion (optional) 
     * @param keyword (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRecipeApproval(productId: number | undefined, productCode: string | null | undefined, documentVersion: string | null | undefined, keyword: string | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RecipeMasterListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetAllRecipeApproval?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (documentVersion !== undefined && documentVersion !== null)
            url_ += "DocumentVersion=" + encodeURIComponent("" + documentVersion) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRecipeApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRecipeApproval(<any>response_);
                } catch (e) {
                    return <Observable<RecipeMasterListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeMasterListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRecipeApproval(response: HttpResponseBase): Observable<RecipeMasterListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeMasterListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeMasterListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecipeDetailsByHdrId(id: number | undefined): Observable<CreayeRecipeMasterdetail[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetRecipeDetailsByHdrId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeDetailsByHdrId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeDetailsByHdrId(<any>response_);
                } catch (e) {
                    return <Observable<CreayeRecipeMasterdetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreayeRecipeMasterdetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeDetailsByHdrId(response: HttpResponseBase): Observable<CreayeRecipeMasterdetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CreayeRecipeMasterdetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreayeRecipeMasterdetail[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecipeHeaderByHdrId(id: number | undefined): Observable<CreateRecipeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetRecipeHeaderByHdrId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeHeaderByHdrId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeHeaderByHdrId(<any>response_);
                } catch (e) {
                    return <Observable<CreateRecipeMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRecipeMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeHeaderByHdrId(response: HttpResponseBase): Observable<CreateRecipeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRecipeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRecipeMasterDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRecipeHeaderByProductCode(input: string | null | undefined): Observable<CreateRecipeMasterDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/GetRecipeHeaderByProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeHeaderByProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeHeaderByProductCode(<any>response_);
                } catch (e) {
                    return <Observable<CreateRecipeMasterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRecipeMasterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeHeaderByProductCode(response: HttpResponseBase): Observable<CreateRecipeMasterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRecipeMasterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRecipeMasterDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateRecipeMasterDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    checkRecipeIdIfAlreadyExist(input: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/CheckRecipeIdIfAlreadyExist?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRecipeIdIfAlreadyExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRecipeIdIfAlreadyExist(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckRecipeIdIfAlreadyExist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveRecipeMaster(body: CreateRecipeMasterDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/ApproveRecipeMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveRecipeMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveRecipeMaster(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processApproveRecipeMaster(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectRecipeMaster(body: CreateRecipeMasterDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/RejectRecipeMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectRecipeMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectRecipeMaster(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRejectRecipeMaster(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    delete(input: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RecipeMasterService/Delete?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RecipePOMappingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRecipeToPOLinkDto | undefined): Observable<RecipeToPOLinkDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RecipeToPOLinkDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeToPOLinkDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RecipeToPOLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeToPOLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeToPOLinkDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecipe(id: number | undefined): Observable<RecipeToPOLinkDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetRecipe?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipe(<any>response_);
                } catch (e) {
                    return <Observable<RecipeToPOLinkDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeToPOLinkDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipe(response: HttpResponseBase): Observable<RecipeToPOLinkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeToPOLinkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeToPOLinkDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRecipeHeaderByHdrId(input: string | null | undefined): Observable<CreateRecipeDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetRecipeHeaderByHdrId?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeHeaderByHdrId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeHeaderByHdrId(<any>response_);
                } catch (e) {
                    return <Observable<CreateRecipeDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRecipeDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeHeaderByHdrId(response: HttpResponseBase): Observable<CreateRecipeDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRecipeDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRecipeDetailsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRecipeHeaderByHdrCodeId(input: number | undefined): Observable<CreateRecipeDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetRecipeHeaderByHdrCodeId?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeHeaderByHdrCodeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeHeaderByHdrCodeId(<any>response_);
                } catch (e) {
                    return <Observable<CreateRecipeDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRecipeDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeHeaderByHdrCodeId(response: HttpResponseBase): Observable<CreateRecipeDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRecipeDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRecipeDetailsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProcessOrderNo(id: number | undefined): Observable<RecipeToPODto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetProcessOrderNo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderNo(<any>response_);
                } catch (e) {
                    return <Observable<RecipeToPODto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeToPODto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderNo(response: HttpResponseBase): Observable<RecipeToPODto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeToPODto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeToPODto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialByProcessOrder(id: number | undefined): Observable<MaterialListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetMaterialByProcessOrder?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialByProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialByProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<MaterialListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialByProcessOrder(response: HttpResponseBase): Observable<MaterialListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialListDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param productCode (optional) 
     * @param recipeNo (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRecipe(keyword: string | null | undefined, productCode: string | null | undefined, recipeNo: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RecipePOMappingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetAllRecipe?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (recipeNo !== undefined && recipeNo !== null)
            url_ += "RecipeNo=" + encodeURIComponent("" + recipeNo) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRecipe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRecipe(<any>response_);
                } catch (e) {
                    return <Observable<RecipePOMappingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipePOMappingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRecipe(response: HttpResponseBase): Observable<RecipePOMappingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipePOMappingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipePOMappingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecipeDetailsByHdrId(id: number | undefined): Observable<RecipeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetRecipeDetailsByHdrId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecipeDetailsByHdrId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecipeDetailsByHdrId(<any>response_);
                } catch (e) {
                    return <Observable<RecipeListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipeListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecipeDetailsByHdrId(response: HttpResponseBase): Observable<RecipeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RecipeListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipeListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetProcessOrdersOfProductCode?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    getProcessOrderDetails(processOrderId: number | undefined): Observable<RecipePOMappingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RecipePOMappingService/GetProcessOrderDetails?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<RecipePOMappingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecipePOMappingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderDetails(response: HttpResponseBase): Observable<RecipePOMappingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RecipePOMappingListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipePOMappingListDto[]>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subPlantId (optional) 
     * @param purchaseOrderId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param transactionStatusId (optional) 
     * @param materialListId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getVehicleInspectionReportDetails(subPlantId: number | null | undefined, purchaseOrderId: number[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, transactionStatusId: number[] | null | undefined, materialListId: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VehicleInspectionReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetVehicleInspectionReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            purchaseOrderId && purchaseOrderId.forEach(item => { url_ += "PurchaseOrderId=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (transactionStatusId !== undefined && transactionStatusId !== null)
            transactionStatusId && transactionStatusId.forEach(item => { url_ += "TransactionStatusId=" + encodeURIComponent("" + item) + "&"; });
        if (materialListId !== undefined && materialListId !== null)
            materialListId && materialListId.forEach(item => { url_ += "MaterialListId=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleInspectionReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleInspectionReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehicleInspectionReportDetails(response: HttpResponseBase): Observable<VehicleInspectionReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VehicleInspectionReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionReportResultDto[]>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param purchaseOrderId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param transactionStatusId (optional) 
     * @param materialListId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMaterialInspectionReportDetails(subPlantId: number | null | undefined, purchaseOrderId: number[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, transactionStatusId: number[] | null | undefined, materialListId: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VehicleInspectionReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetMaterialInspectionReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            purchaseOrderId && purchaseOrderId.forEach(item => { url_ += "PurchaseOrderId=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (transactionStatusId !== undefined && transactionStatusId !== null)
            transactionStatusId && transactionStatusId.forEach(item => { url_ += "TransactionStatusId=" + encodeURIComponent("" + item) + "&"; });
        if (materialListId !== undefined && materialListId !== null)
            materialListId && materialListId.forEach(item => { url_ += "MaterialListId=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialInspectionReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInspectionReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialInspectionReportDetails(response: HttpResponseBase): Observable<VehicleInspectionReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(VehicleInspectionReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionReportResultDto[]>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param areaIds (optional) 
     * @param materialCodes (optional) 
     * @param sapBatchNos (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param stockStatus (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllocationReportDetails(subPlantId: number | null | undefined, areaIds: number[] | null | undefined, materialCodes: string[] | null | undefined, sapBatchNos: string[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, stockStatus: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AllocationReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetAllocationReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (areaIds !== undefined && areaIds !== null)
            areaIds && areaIds.forEach(item => { url_ += "AreaIds=" + encodeURIComponent("" + item) + "&"; });
        if (materialCodes !== undefined && materialCodes !== null)
            materialCodes && materialCodes.forEach(item => { url_ += "MaterialCodes=" + encodeURIComponent("" + item) + "&"; });
        if (sapBatchNos !== undefined && sapBatchNos !== null)
            sapBatchNos && sapBatchNos.forEach(item => { url_ += "SapBatchNos=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (stockStatus !== undefined && stockStatus !== null)
            stockStatus && stockStatus.forEach(item => { url_ += "StockStatus=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllocationReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllocationReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<AllocationReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AllocationReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllocationReportDetails(response: HttpResponseBase): Observable<AllocationReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AllocationReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AllocationReportResultDto[]>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param param (optional) 
     * @return Success
     */
    getAuditTrail(tablename: string | null | undefined, param: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetAuditTrail?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (param !== undefined && param !== null)
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditTrail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditTrail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditTrail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tableName (optional) 
     * @param param (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDynamicAuditTrail(tableName: string | null | undefined, param: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDynamicAuditTrail?";
        if (tableName !== undefined && tableName !== null)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        if (param !== undefined && param !== null)
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicAuditTrail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicAuditTrail(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicAuditTrail(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @return Success
     */
    showAllTables(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/showAllTables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowAllTables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowAllTables(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShowAllTables(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param columnName (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    getspTableStructureToBeCreate(tablename: string | null | undefined, columnName: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetspTableStructureToBeCreate?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetspTableStructureToBeCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetspTableStructureToBeCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetspTableStructureToBeCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @param pagenumber (optional) 
     * @param pagesize (optional) 
     * @return Success
     */
    createForms(tablename: string | null | undefined, pagenumber: number | undefined, pagesize: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/createForms?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        if (pagenumber === null)
            throw new Error("The parameter 'pagenumber' cannot be null.");
        else if (pagenumber !== undefined)
            url_ += "pagenumber=" + encodeURIComponent("" + pagenumber) + "&";
        if (pagesize === null)
            throw new Error("The parameter 'pagesize' cannot be null.");
        else if (pagesize !== undefined)
            url_ += "pagesize=" + encodeURIComponent("" + pagesize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tablename (optional) 
     * @return Success
     */
    showTableColumns(tablename: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/showTableColumns?";
        if (tablename !== undefined && tablename !== null)
            url_ += "tablename=" + encodeURIComponent("" + tablename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowTableColumns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowTableColumns(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShowTableColumns(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tableName (optional) 
     * @param columnName (optional) 
     * @param values (optional) 
     * @param actionType (optional) 
     * @return Success
     */
    formDataPush(tableName: string | null | undefined, columnName: string | null | undefined, values: string | null | undefined, actionType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/FormDataPush?";
        if (tableName !== undefined && tableName !== null)
            url_ += "TableName=" + encodeURIComponent("" + tableName) + "&";
        if (columnName !== undefined && columnName !== null)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (values !== undefined && values !== null)
            url_ += "Values=" + encodeURIComponent("" + values) + "&";
        if (actionType !== undefined && actionType !== null)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormDataPush(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormDataPush(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFormDataPush(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subPlantIds (optional) 
     * @param cubicleIds (optional) 
     * @param productCodes (optional) 
     * @param batchNos (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param groupStatusIds (optional) 
     * @param isSampling (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCubicleAssginedReportDetails(subPlantIds: number | null | undefined, cubicleIds: number[] | null | undefined, productCodes: string[] | null | undefined, batchNos: string[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, groupStatusIds: number[] | null | undefined, isSampling: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CubicleAssignedReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCubicleAssginedReportDetails?";
        if (subPlantIds !== undefined && subPlantIds !== null)
            url_ += "SubPlantIds=" + encodeURIComponent("" + subPlantIds) + "&";
        if (cubicleIds !== undefined && cubicleIds !== null)
            cubicleIds && cubicleIds.forEach(item => { url_ += "CubicleIds=" + encodeURIComponent("" + item) + "&"; });
        if (productCodes !== undefined && productCodes !== null)
            productCodes && productCodes.forEach(item => { url_ += "ProductCodes=" + encodeURIComponent("" + item) + "&"; });
        if (batchNos !== undefined && batchNos !== null)
            batchNos && batchNos.forEach(item => { url_ += "BatchNos=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (groupStatusIds !== undefined && groupStatusIds !== null)
            groupStatusIds && groupStatusIds.forEach(item => { url_ += "GroupStatusIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSampling !== undefined && isSampling !== null)
            url_ += "IsSampling=" + encodeURIComponent("" + isSampling) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleAssginedReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleAssginedReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<CubicleAssignedReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubicleAssignedReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleAssginedReportDetails(response: HttpResponseBase): Observable<CubicleAssignedReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubicleAssignedReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubicleAssignedReportResultDto[]>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param processOrderIds (optional) 
     * @param inspectionLotIds (optional) 
     * @param materialCodes (optional) 
     * @param productCodes (optional) 
     * @param sapBatchNos (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param statusIds (optional) 
     * @param isSampling (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getPickingReportDetails(subPlantId: number | null | undefined, processOrderIds: number[] | null | undefined, inspectionLotIds: number[] | null | undefined, materialCodes: string[] | null | undefined, productCodes: string[] | null | undefined, sapBatchNos: string[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, statusIds: number[] | null | undefined, isSampling: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PickingReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPickingReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (processOrderIds !== undefined && processOrderIds !== null)
            processOrderIds && processOrderIds.forEach(item => { url_ += "ProcessOrderIds=" + encodeURIComponent("" + item) + "&"; });
        if (inspectionLotIds !== undefined && inspectionLotIds !== null)
            inspectionLotIds && inspectionLotIds.forEach(item => { url_ += "InspectionLotIds=" + encodeURIComponent("" + item) + "&"; });
        if (materialCodes !== undefined && materialCodes !== null)
            materialCodes && materialCodes.forEach(item => { url_ += "MaterialCodes=" + encodeURIComponent("" + item) + "&"; });
        if (productCodes !== undefined && productCodes !== null)
            productCodes && productCodes.forEach(item => { url_ += "ProductCodes=" + encodeURIComponent("" + item) + "&"; });
        if (sapBatchNos !== undefined && sapBatchNos !== null)
            sapBatchNos && sapBatchNos.forEach(item => { url_ += "SapBatchNos=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (statusIds !== undefined && statusIds !== null)
            statusIds && statusIds.forEach(item => { url_ += "StatusIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSampling !== undefined && isSampling !== null)
            url_ += "IsSampling=" + encodeURIComponent("" + isSampling) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickingReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickingReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<PickingReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PickingReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickingReportDetails(response: HttpResponseBase): Observable<PickingReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PickingReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PickingReportDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    geLineClearanceReportDetails(body: LineClearanceReportRequestDto | undefined): Observable<LineClearanceReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GeLineClearanceReportDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeLineClearanceReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeLineClearanceReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<LineClearanceReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineClearanceReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGeLineClearanceReportDetails(response: HttpResponseBase): Observable<LineClearanceReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LineClearanceReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineClearanceReportResultDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dispensingReportGetDetails(body: DispensingReportRequestDto | undefined): Observable<DispensingReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/DispensingReportGetDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispensingReportGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispensingReportGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<DispensingReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DispensingReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDispensingReportGetDetails(response: HttpResponseBase): Observable<DispensingReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DispensingReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispensingReportDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dispatchReportGetDetails(body: DispatchReportRequestDto | undefined): Observable<DispatchReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/DispatchReportGetDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispatchReportGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispatchReportGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<DispatchReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DispatchReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDispatchReportGetDetails(response: HttpResponseBase): Observable<DispatchReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DispatchReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispatchReportDto[]>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param equipmentListIds (optional) 
     * @param cubicleListIds (optional) 
     * @param cleaningTypeIds (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param isSampling (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getcubicleCleaningReportDetails(subPlantId: number | null | undefined, equipmentListIds: number[] | null | undefined, cubicleListIds: number[] | null | undefined, cleaningTypeIds: number[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, isSampling: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CleaningLogReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetcubicleCleaningReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (equipmentListIds !== undefined && equipmentListIds !== null)
            equipmentListIds && equipmentListIds.forEach(item => { url_ += "EquipmentListIds=" + encodeURIComponent("" + item) + "&"; });
        if (cubicleListIds !== undefined && cubicleListIds !== null)
            cubicleListIds && cubicleListIds.forEach(item => { url_ += "CubicleListIds=" + encodeURIComponent("" + item) + "&"; });
        if (cleaningTypeIds !== undefined && cleaningTypeIds !== null)
            cleaningTypeIds && cleaningTypeIds.forEach(item => { url_ += "cleaningTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (isSampling !== undefined && isSampling !== null)
            url_ += "IsSampling=" + encodeURIComponent("" + isSampling) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcubicleCleaningReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcubicleCleaningReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<CleaningLogReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningLogReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetcubicleCleaningReportDetails(response: HttpResponseBase): Observable<CleaningLogReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CleaningLogReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningLogReportResultDto[]>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param equipmentListIds (optional) 
     * @param cubicleListIds (optional) 
     * @param cleaningTypeIds (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param isSampling (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getEquipmentCleaningReportDetails(subPlantId: number | null | undefined, equipmentListIds: number[] | null | undefined, cubicleListIds: number[] | null | undefined, cleaningTypeIds: number[] | null | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, isSampling: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CleaningLogReportResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetEquipmentCleaningReportDetails?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (equipmentListIds !== undefined && equipmentListIds !== null)
            equipmentListIds && equipmentListIds.forEach(item => { url_ += "EquipmentListIds=" + encodeURIComponent("" + item) + "&"; });
        if (cubicleListIds !== undefined && cubicleListIds !== null)
            cubicleListIds && cubicleListIds.forEach(item => { url_ += "CubicleListIds=" + encodeURIComponent("" + item) + "&"; });
        if (cleaningTypeIds !== undefined && cleaningTypeIds !== null)
            cleaningTypeIds && cleaningTypeIds.forEach(item => { url_ += "cleaningTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (isSampling !== undefined && isSampling !== null)
            url_ += "IsSampling=" + encodeURIComponent("" + isSampling) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquipmentCleaningReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquipmentCleaningReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<CleaningLogReportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningLogReportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEquipmentCleaningReportDetails(response: HttpResponseBase): Observable<CleaningLogReportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CleaningLogReportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningLogReportResultDto[]>(<any>null);
    }

    /**
     * @param submoduleName (optional) 
     * @return Success
     */
    getReportConfiguration(submoduleName: string | null | undefined): Observable<ReportConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReportConfiguration?";
        if (submoduleName !== undefined && submoduleName !== null)
            url_ += "submoduleName=" + encodeURIComponent("" + submoduleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<ReportConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportConfiguration(response: HttpResponseBase): Observable<ReportConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigurationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateReportConfiguration(body: ReportConfigurationDto | undefined): Observable<ReportConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/InsertUpdateReportConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateReportConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateReportConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<ReportConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateReportConfiguration(response: HttpResponseBase): Observable<ReportConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigurationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dispensingTrackingReportGetDetails(body: DispensingTrackingReportRequestDto | undefined): Observable<DispensingTrackingReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/DispensingTrackingReportGetDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispensingTrackingReportGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispensingTrackingReportGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<DispensingTrackingReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DispensingTrackingReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDispensingTrackingReportGetDetails(response: HttpResponseBase): Observable<DispensingTrackingReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DispensingTrackingReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispensingTrackingReportDto[]>(<any>null);
    }

    /**
     * @param calibrationStartDate (optional) 
     * @param calibrationEndDate (optional) 
     * @param calibrationDate (optional) 
     * @param weighingMachineId (optional) 
     * @param subPlantId (optional) 
     * @param frequencyModeld (optional) 
     * @param id (optional) 
     * @return Success
     */
    getWMCalibrationReportDetails(calibrationStartDate: moment.Moment | undefined, calibrationEndDate: moment.Moment | undefined, calibrationDate: moment.Moment | undefined, weighingMachineId: number | null | undefined, subPlantId: number | null | undefined, frequencyModeld: number | null | undefined, id: number | undefined): Observable<WeighingCalibrationDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetWMCalibrationReportDetails?";
        if (calibrationStartDate === null)
            throw new Error("The parameter 'calibrationStartDate' cannot be null.");
        else if (calibrationStartDate !== undefined)
            url_ += "CalibrationStartDate=" + encodeURIComponent(calibrationStartDate ? "" + calibrationStartDate.toJSON() : "") + "&";
        if (calibrationEndDate === null)
            throw new Error("The parameter 'calibrationEndDate' cannot be null.");
        else if (calibrationEndDate !== undefined)
            url_ += "CalibrationEndDate=" + encodeURIComponent(calibrationEndDate ? "" + calibrationEndDate.toJSON() : "") + "&";
        if (calibrationDate === null)
            throw new Error("The parameter 'calibrationDate' cannot be null.");
        else if (calibrationDate !== undefined)
            url_ += "CalibrationDate=" + encodeURIComponent(calibrationDate ? "" + calibrationDate.toJSON() : "") + "&";
        if (weighingMachineId !== undefined && weighingMachineId !== null)
            url_ += "WeighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (frequencyModeld !== undefined && frequencyModeld !== null)
            url_ += "FrequencyModeld=" + encodeURIComponent("" + frequencyModeld) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWMCalibrationReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWMCalibrationReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<WeighingCalibrationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingCalibrationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWMCalibrationReportDetails(response: HttpResponseBase): Observable<WeighingCalibrationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingCalibrationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingCalibrationDto>(<any>null);
    }

    /**
     * @param reportType (optional) 
     * @return Success
     */
    validateUserMode(reportType: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Report/ValidateUserMode?";
        if (reportType === null)
            throw new Error("The parameter 'reportType' cannot be null.");
        else if (reportType !== undefined)
            url_ += "reportType=" + encodeURIComponent("" + reportType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateUserMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateUserMode(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateUserMode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ReportFiltersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAssignCubiclesByPlantId(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAssignCubiclesByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignCubiclesByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignCubiclesByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssignCubiclesByPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getCubiclesAssignProducts(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetCubiclesAssignProducts?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubiclesAssignProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubiclesAssignProducts(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubiclesAssignProducts(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getCubiclesAssignSAPBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetCubiclesAssignSAPBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubiclesAssignSAPBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubiclesAssignSAPBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubiclesAssignSAPBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllLineClearanceMaterial(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllLineClearanceMaterial?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLineClearanceMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLineClearanceMaterial(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLineClearanceMaterial(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getLineClearanceSAPBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetLineClearanceSAPBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineClearanceSAPBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineClearanceSAPBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineClearanceSAPBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getLineClearanceCubicleByPlantId(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetLineClearanceCubicleByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineClearanceCubicleByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineClearanceCubicleByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineClearanceCubicleByPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getLineClearanceProducts(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetLineClearanceProducts?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineClearanceProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineClearanceProducts(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineClearanceProducts(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getProcessOrderAndInspectionLotNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetProcessOrderAndInspectionLotNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrderAndInspectionLotNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrderAndInspectionLotNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrderAndInspectionLotNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getPickedCubiclesMaterialCodesByPlantId(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetPickedCubiclesMaterialCodesByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickedCubiclesMaterialCodesByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickedCubiclesMaterialCodesByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickedCubiclesMaterialCodesByPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getPickedCubiclesBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetPickedCubiclesBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickedCubiclesBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickedCubiclesBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickedCubiclesBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getPickedCubiclesSAPBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetPickedCubiclesSAPBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPickedCubiclesSAPBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPickedCubiclesSAPBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPickedCubiclesSAPBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllocatedAreas(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllocatedAreas?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllocatedAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllocatedAreas(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllocatedAreas(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllocatedMaterialCodesByPlantId(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllocatedMaterialCodesByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllocatedMaterialCodesByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllocatedMaterialCodesByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllocatedMaterialCodesByPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllocatedSAPBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllocatedSAPBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllocatedSAPBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllocatedSAPBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllocatedSAPBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllDispensingMaterial(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllDispensingMaterial?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensingMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensingMaterial(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensingMaterial(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllDispensingSAPBatchNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllDispensingSAPBatchNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensingSAPBatchNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensingSAPBatchNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensingSAPBatchNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllDispensingProducts(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllDispensingProducts?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensingProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensingProducts(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensingProducts(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllDispensingProcessOrderNo(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllDispensingProcessOrderNo?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensingProcessOrderNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensingProcessOrderNo(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensingProcessOrderNo(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllDispensingProductBatch(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllDispensingProductBatch?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDispensingProductBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDispensingProductBatch(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDispensingProductBatch(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllCleanCubicleByPlant(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllCleanCubicleByPlant?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCleanCubicleByPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCleanCubicleByPlant(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCleanCubicleByPlant(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllCleanEquipmentByPlant(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetAllCleanEquipmentByPlant?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCleanEquipmentByPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCleanEquipmentByPlant(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCleanEquipmentByPlant(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCalibrationMode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetCalibrationMode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibrationMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibrationMode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalibrationMode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param calibrationDate (optional) 
     * @param weighingMachineId (optional) 
     * @param calibrationHeaderId (optional) 
     * @return Success
     */
    getLastCalibrationStatus(calibrationDate: moment.Moment | undefined, weighingMachineId: number | null | undefined, calibrationHeaderId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilters/GetLastCalibrationStatus?";
        if (calibrationDate === null)
            throw new Error("The parameter 'calibrationDate' cannot be null.");
        else if (calibrationDate !== undefined)
            url_ += "calibrationDate=" + encodeURIComponent(calibrationDate ? "" + calibrationDate.toJSON() : "") + "&";
        if (weighingMachineId !== undefined && weighingMachineId !== null)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        if (calibrationHeaderId === null)
            throw new Error("The parameter 'calibrationHeaderId' cannot be null.");
        else if (calibrationHeaderId !== undefined)
            url_ += "calibrationHeaderId=" + encodeURIComponent("" + calibrationHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCalibrationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCalibrationStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCalibrationStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ReturnToVendorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMaterialDocumentNoAutoComplete(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/GetMaterialDocumentNoAutoComplete?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialDocumentNoAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialDocumentNoAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialDocumentNoAutoComplete(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMaterialCodeByDocumentNo(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/GetMaterialCodeByDocumentNo?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialCodeByDocumentNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialCodeByDocumentNo(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialCodeByDocumentNo(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getSapBatchNumberByMaterialCode(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/GetSapBatchNumberByMaterialCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSapBatchNumberByMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSapBatchNumberByMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSapBatchNumberByMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReturnToVendorDto(body: ReturnToVendorDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/UpdateReturnToVendorDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReturnToVendorDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReturnToVendorDto(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReturnToVendorDto(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveReturnToVendor(body: ReturnToVendorDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/SaveReturnToVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReturnToVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReturnToVendor(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveReturnToVendor(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postReturnToVendor(body: ReturnToVendorDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/ReturnToVendor/PostReturnToVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReturnToVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReturnToVendor(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostReturnToVendor(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param approvalStatusId (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, approvalStatusId: number | null | undefined, status: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectRole(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/ApproveOrRejectRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSubModulesWithPermissions(): Observable<RolePermissionsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllSubModulesWithPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModulesWithPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModulesWithPermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubModulesWithPermissions(response: HttpResponseBase): Observable<RolePermissionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RolePermissionsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionsDto[]>(<any>null);
    }
}

@Injectable()
export class SampleDestructionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSampleInspectionLotNos(): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/SampleDestruction/GetAllSampleInspectionLotNos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSampleInspectionLotNos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSampleInspectionLotNos(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSampleInspectionLotNos(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param inspectionLotId (optional) 
     * @return Success
     */
    getMaterialByInspectionLotId(inspectionLotId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/SampleDestruction/GetMaterialByInspectionLotId?";
        if (inspectionLotId === null)
            throw new Error("The parameter 'inspectionLotId' cannot be null.");
        else if (inspectionLotId !== undefined)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialByInspectionLotId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialByInspectionLotId(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialByInspectionLotId(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param inspectionLotId (optional) 
     * @param materialCode (optional) 
     * @return Success
     */
    getSamplingSapBatchNumbers(inspectionLotId: number | null | undefined, materialCode: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/SampleDestruction/GetSamplingSapBatchNumbers?";
        if (inspectionLotId !== undefined && inspectionLotId !== null)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSamplingSapBatchNumbers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSamplingSapBatchNumbers(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSamplingSapBatchNumbers(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSampleDestructionByContainerBarcode(body: SampleDestructionDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/SampleDestruction/UpdateSampleDestructionByContainerBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampleDestructionByContainerBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampleDestructionByContainerBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSampleDestructionByContainerBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SampleDestructionDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/SampleDestruction/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class SAPIntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateMaterial(body: SAPMaterial | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateMaterial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateMaterials(body: SAPMaterials | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateMaterials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateMaterials(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateMaterials(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param materialCode (optional) 
     * @return Success
     */
    getMaterial(materialCode: string | null | undefined): Observable<SAPMaterial> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/GetMaterial?";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterial(<any>response_);
                } catch (e) {
                    return <Observable<SAPMaterial>><any>_observableThrow(e);
                }
            } else
                return <Observable<SAPMaterial>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterial(response: HttpResponseBase): Observable<SAPMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SAPMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SAPMaterial>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdatePlantMaster(body: SAPPlantMasterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdatePlantMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdatePlantMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdatePlantMaster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdatePlantMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateUomMaster(body: SAPUOMMasterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateUomMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateUomMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateUomMaster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateUomMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateProcessOrder(body: SAPProcessOrderDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateProcessOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateProcessOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateReturnMaterial(body: SAPReturntoMaterialDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateReturnMaterial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateReturnMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateReturnMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateReturnMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdatePurchaseOrderMaterial(body: SAPProcessOrderReceivedMaterialDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdatePurchaseOrderMaterial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdatePurchaseOrderMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdatePurchaseOrderMaterial(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdatePurchaseOrderMaterial(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateQualityControlDetail(body: SAPQualityControlDetailDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SAPIntegration/InsertUpdateQualityControlDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateQualityControlDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateQualityControlDetail(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateQualityControlDetail(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SelectListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getModes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCheckpointTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCheckpointTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @param subModuleId (optional) 
     * @return Success
     */
    getChecklistTypes(plantId: number | null | undefined, subModuleId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklistTypes?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        if (subModuleId === null)
            throw new Error("The parameter 'subModuleId' cannot be null.");
        else if (subModuleId !== undefined)
            url_ += "subModuleId=" + encodeURIComponent("" + subModuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklistTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklistTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChecklistTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param subModuleName (optional) 
     * @return Success
     */
    getChecklistTypesBySubModuleName(subModuleName: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklistTypesBySubModuleName?";
        if (subModuleName !== undefined && subModuleName !== null)
            url_ += "subModuleName=" + encodeURIComponent("" + subModuleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklistTypesBySubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklistTypesBySubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChecklistTypesBySubModuleName(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param includeIsControllerModes (optional) 
     * @return Success
     */
    getModesBySetting(userId: number | undefined, includeIsControllerModes: boolean | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModesBySetting?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (includeIsControllerModes === null)
            throw new Error("The parameter 'includeIsControllerModes' cannot be null.");
        else if (includeIsControllerModes !== undefined)
            url_ += "includeIsControllerModes=" + encodeURIComponent("" + includeIsControllerModes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModesBySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModesBySetting(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModesBySetting(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDesignation(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDesignation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDesignation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDesignation(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDesignation(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getApprovalStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetApprovalStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalStatus(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByUser(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPlant(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlant(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlant(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPlantsOnUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlantsOnUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantsOnUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantsOnUser(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlantsOnUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getPlantByUserId(userId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPlantByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantByUserId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlantByUserId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getReportingManagerUser(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetReportingManagerUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportingManagerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportingManagerUser(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportingManagerUser(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByRole(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByRole(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByRole(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByModule(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByModule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByModule(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByModule(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByPlant(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPlant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPlant(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByPlant(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    getStates(countryId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStates?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByGate(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByGate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByGate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByGate(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByGate(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByLocation(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByLocation(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByLocation(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMasterPlants(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllMasterPlants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterPlants(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMasterPlants(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSubPlants(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllSubPlants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubPlants(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubPlants(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStorageLocations(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStorageLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocations(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageLocations(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStorageLocationsWithPlantId(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStorageLocationsWithPlantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocationsWithPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocationsWithPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageLocationsWithPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartments(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getDepartmentsByPlantId(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDepartmentsByPlantId?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentsByPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByCubicle(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCubicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCubicle(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByCubicle(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByEquipment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByEquipment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByEquipment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByEquipment(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByEquipment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEquipmentTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetEquipmentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquipmentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquipmentTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEquipmentTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByHandlingUnit(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByHandlingUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByHandlingUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByHandlingUnit(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByHandlingUnit(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getHandlingUnitTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetHandlingUnitTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHandlingUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHandlingUnitTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHandlingUnitTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortBySubModule(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortBySubModule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortBySubModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortBySubModule(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortBySubModule(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByStandardWeightBox(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByStandardWeightBox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByStandardWeightBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByStandardWeightBox(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByStandardWeightBox(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSubModuleType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSubModuleType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModuleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModuleType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubModuleType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByStandardWeights(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByStandardWeights";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByStandardWeights(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByStandardWeights(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByStandardWeights(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByDepartment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByDepartment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByDepartment(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByDepartment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByUnitOfMeasurement(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByUnitOfMeasurement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByUnitOfMeasurement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByUnitOfMeasurement(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByUnitOfMeasurement(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUnitOfMeasurementTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetUnitOfMeasurementTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurementTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurementTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurementTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getConversionUOMMasters(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetConversionUOMMasters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConversionUOMMasters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversionUOMMasters(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConversionUOMMasters(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByArea(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByArea";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByArea(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByArea(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByInspectionChecklist(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByInspectionChecklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByInspectionChecklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByInspectionChecklist(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByInspectionChecklist(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByWeighingMachine(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeighingMachine";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeighingMachine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeighingMachine(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByWeighingMachine(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByDevice(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByDevice";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByDevice(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByDevice(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAreas(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAreasByPlantId(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreasByPlantId?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreasByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreasByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreasByPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param departmentId (optional) 
     * @return Success
     */
    getAreasByDepartmentId(departmentId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAreasByDepartmentId?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreasByDepartmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreasByDepartmentId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreasByDepartmentId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCubicles(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubicles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicles(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicles(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param areaId (optional) 
     * @return Success
     */
    getCubiclesByAreaId(areaId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubiclesByAreaId?";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubiclesByAreaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubiclesByAreaId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubiclesByAreaId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDeviceTypes(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetDeviceTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceTypes(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceTypes(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTemperatureUnit(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetTemperatureUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemperatureUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemperatureUnit(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemperatureUnit(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getGateEntrysortBy(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetGateEntrysortBy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntrysortBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntrysortBy(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGateEntrysortBy(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getWeighingMachineFrequencyType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetWeighingMachineFrequencyType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineFrequencyType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineFrequencyType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeighingMachineFrequencyType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getWeighingMachineBalancedType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetWeighingMachineBalancedType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineBalancedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineBalancedType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeighingMachineBalancedType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByChecklistType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByChecklistType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByChecklistType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByChecklistType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByChecklistType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAssociatedPlantByUserId(userId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAssociatedPlantByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociatedPlantByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociatedPlantByUserId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssociatedPlantByUserId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getHolidayType(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetHolidayType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayType(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayType(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByCalender(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCalender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCalender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCalender(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByCalender(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPrinters(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPrinters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrinters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrinters(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrinters(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPurchaseOrders(): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPurchaseOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrders(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPurchaseOrders(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getPurchaseOrdersAutoComplete(input: string | null | undefined): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPurchaseOrdersAutoComplete?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPurchaseOrdersAutoComplete(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactionStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetTransactionStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatus(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getGateEntryStatus(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetGateEntryStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGateEntryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGateEntryStatus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetGateEntryStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByVehicleInspection(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByVehicleInspection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByVehicleInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByVehicleInspection(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByVehicleInspection(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByMaterialInspection(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByMaterialInspection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByMaterialInspection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByMaterialInspection(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByMaterialInspection(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param checklistTypeId (optional) 
     * @return Success
     */
    getChecklists(checklistTypeId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetChecklists?";
        if (checklistTypeId === null)
            throw new Error("The parameter 'checklistTypeId' cannot be null.");
        else if (checklistTypeId !== undefined)
            url_ += "checklistTypeId=" + encodeURIComponent("" + checklistTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChecklists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklists(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChecklists(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByWeightCapture(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeightCapture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeightCapture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeightCapture(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByWeightCapture(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByGRNPosting(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByGRNPosting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByGRNPosting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByGRNPosting(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByGRNPosting(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getStandardWeightBox(plantId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStandardWeightBox?";
        if (plantId === null)
            throw new Error("The parameter 'plantId' cannot be null.");
        else if (plantId !== undefined)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStandardWeightBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardWeightBox(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStandardWeightBox(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param purchaseorderId (optional) 
     * @return Success
     */
    getInvoiceByPurchaseOrderId(purchaseorderId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetInvoiceByPurchaseOrderId?";
        if (purchaseorderId === null)
            throw new Error("The parameter 'purchaseorderId' cannot be null.");
        else if (purchaseorderId !== undefined)
            url_ += "purchaseorderId=" + encodeURIComponent("" + purchaseorderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceByPurchaseOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceByPurchaseOrderId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceByPurchaseOrderId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param uomId (optional) 
     * @return Success
     */
    getUnitOfMeasurementById(uomId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetUnitOfMeasurementById?";
        if (uomId === null)
            throw new Error("The parameter 'uomId' cannot be null.");
        else if (uomId !== undefined)
            url_ += "uomId=" + encodeURIComponent("" + uomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurementById(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurementById(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByPalletization(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPalletization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPalletization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPalletization(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByPalletization(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMaterialSelectList(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllMaterialSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterialSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterialSelectList(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaterialSelectList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPallets(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPallets(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPalletizationPallets(): Observable<SelectListDtoWithPlantIdPalletization[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletizationPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletizationPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletizationPallets(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantIdPalletization[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantIdPalletization[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletizationPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantIdPalletization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantIdPalletization.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantIdPalletization[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPalletMasterPallets(): Observable<SelectListDtoWithPlantIdPalletization[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletMasterPallets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletMasterPallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletMasterPallets(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantIdPalletization[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantIdPalletization[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletMasterPallets(response: HttpResponseBase): Observable<SelectListDtoWithPlantIdPalletization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantIdPalletization.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantIdPalletization[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByPutAway(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPutAway";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPutAway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPutAway(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByPutAway(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByCubicleAssignment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByCubicleAssignment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByCubicleAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByCubicleAssignment(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByCubicleAssignment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortBySamplingCubicleAssignment(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortBySamplingCubicleAssignment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortBySamplingCubicleAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortBySamplingCubicleAssignment(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortBySamplingCubicleAssignment(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCubicleBarcode(): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllCubicleBarcode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCubicleBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCubicleBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCubicleBarcode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCubicleAssignmentGroupStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCubicleAssignmentGroupStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleAssignmentGroupStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleAssignmentGroupStatus(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleAssignmentGroupStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCalibrationStatusTest(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCalibrationStatusTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibrationStatusTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibrationStatusTest(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalibrationStatusTest(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCalibrationStatus(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetCalibrationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibrationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibrationStatus(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalibrationStatus(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByWeighingCalibration(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByWeighingCalibration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByWeighingCalibration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByWeighingCalibration(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByWeighingCalibration(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param purchaseorderIdList (optional) 
     * @param plantId (optional) 
     * @return Success
     */
    getmaterialsByPurchaseOrder(purchaseorderIdList: number[] | null | undefined, plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetmaterialsByPurchaseOrder?";
        if (purchaseorderIdList !== undefined && purchaseorderIdList !== null)
            purchaseorderIdList && purchaseorderIdList.forEach(item => { url_ += "purchaseorderIdList=" + encodeURIComponent("" + item) + "&"; });
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmaterialsByPurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmaterialsByPurchaseOrder(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetmaterialsByPurchaseOrder(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getPurchaseOrdersByPlantId(plantId: number | null | undefined): Observable<PurchaseOrderInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetPurchaseOrdersByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderInternalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPurchaseOrdersByPlantId(response: HttpResponseBase): Observable<PurchaseOrderInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrderInternalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderInternalDto[]>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @param isWeightUOMType (optional) 
     * @return Success
     */
    getWeightByWeighingMachineId(weighingMachineId: number | undefined, isWeightUOMType: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetWeightByWeighingMachineId?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        if (isWeightUOMType === null)
            throw new Error("The parameter 'isWeightUOMType' cannot be null.");
        else if (isWeightUOMType !== undefined)
            url_ += "isWeightUOMType=" + encodeURIComponent("" + isWeightUOMType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightByWeighingMachineId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightByWeighingMachineId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightByWeighingMachineId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @return Success
     */
    getStampingDueOnInfoById(weighingMachineId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetStampingDueOnInfoById?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStampingDueOnInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStampingDueOnInfoById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetStampingDueOnInfoById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param plantId (optional) 
     * @return Success
     */
    getAllWeighingMachineByPlantId(plantId: number | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllWeighingMachineByPlantId?";
        if (plantId !== undefined && plantId !== null)
            url_ += "plantId=" + encodeURIComponent("" + plantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWeighingMachineByPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWeighingMachineByPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWeighingMachineByPlantId(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllApprovelLevels(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllApprovelLevels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApprovelLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApprovelLevels(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllApprovelLevels(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSubModules(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllSubModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubModules(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubModules(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllcubicals(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllcubicals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllcubicals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllcubicals(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllcubicals(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllcubicalsOfCurrentPlantId(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllcubicalsOfCurrentPlantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllcubicalsOfCurrentPlantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllcubicalsOfCurrentPlantId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllcubicalsOfCurrentPlantId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllActivity(subModule: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllActivity?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivity(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActivity(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEquipments(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllEquipments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipments(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipments(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterialMaster(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetMaterialMaster";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialMaster(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialMaster(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSortByPasswordRequestedUsers(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetSortByPasswordRequestedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortByPasswordRequestedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortByPasswordRequestedUsers(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortByPasswordRequestedUsers(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllCheckList(subModule: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllCheckList?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCheckList(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCheckList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param subModule (optional) 
     * @return Success
     */
    getAllInspectionCheckList(subModule: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllInspectionCheckList?";
        if (subModule !== undefined && subModule !== null)
            url_ += "subModule=" + encodeURIComponent("" + subModule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInspectionCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInspectionCheckList(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInspectionCheckList(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPalletCode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllPalletCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPalletCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPalletCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPalletCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllShipperCode(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetAllShipperCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShipperCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShipperCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllShipperCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProcessOrdersAssignedToCubicle(): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SelectList/GetProcessOrdersAssignedToCubicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersAssignedToCubicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersAssignedToCubicle(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersAssignedToCubicle(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<SettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SettingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Setting/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadLogo(file: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Setting/UploadLogo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLogo(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUploadLogo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getLogo(): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogo(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogo(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(<any>null);
    }
}

@Injectable()
export class StageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getCubicleByBarcode(input: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/GetCubicleByBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubicleByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubicleByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubicleByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeStaging(body: StagingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/CompleteStaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteStaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteStaging(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteStaging(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeStagingForSampling(body: StagingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/CompleteStagingForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteStagingForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteStagingForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteStagingForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleCode (optional) 
     * @param groupCode (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getPreStageMaterialCode(cubicleCode: string | null | undefined, groupCode: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/GetPreStageMaterialCode?";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "cubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (groupCode !== undefined && groupCode !== null)
            url_ += "groupCode=" + encodeURIComponent("" + groupCode) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreStageMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreStageMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPreStageMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleCode (optional) 
     * @param groupCode (optional) 
     * @param materialCode (optional) 
     * @param isSampling (optional) 
     * @return Success
     */
    getPreStageSAPBatchNos(cubicleCode: string | null | undefined, groupCode: string | null | undefined, materialCode: string | null | undefined, isSampling: boolean | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/GetPreStageSAPBatchNos?";
        if (cubicleCode !== undefined && cubicleCode !== null)
            url_ += "cubicleCode=" + encodeURIComponent("" + cubicleCode) + "&";
        if (groupCode !== undefined && groupCode !== null)
            url_ += "groupCode=" + encodeURIComponent("" + groupCode) + "&";
        if (materialCode !== undefined && materialCode !== null)
            url_ += "materialCode=" + encodeURIComponent("" + materialCode) + "&";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreStageSAPBatchNos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreStageSAPBatchNos(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPreStageSAPBatchNos(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param isSampling (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateStagingDetail(isSampling: boolean | undefined, body: StagingDto | undefined): Observable<StagingDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/UpdateStagingDetail?";
        if (isSampling === null)
            throw new Error("The parameter 'isSampling' cannot be null.");
        else if (isSampling !== undefined)
            url_ += "isSampling=" + encodeURIComponent("" + isSampling) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStagingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStagingDetail(<any>response_);
                } catch (e) {
                    return <Observable<StagingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StagingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStagingDetail(response: HttpResponseBase): Observable<StagingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StagingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StagingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveStagingMaterialContainerDetails(body: StagingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/SaveStagingMaterialContainerDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStagingMaterialContainerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStagingMaterialContainerDetails(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStagingMaterialContainerDetails(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveStagingMaterialContainerDetailsForSampling(body: StagingDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Stage/SaveStagingMaterialContainerDetailsForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStagingMaterialContainerDetailsForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStagingMaterialContainerDetailsForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStagingMaterialContainerDetailsForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class StageOutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGroupIdByCubicleBarcode(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/GetGroupIdByCubicleBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupIdByCubicleBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupIdByCubicleBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupIdByCubicleBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGroupIdByCubicleBarcodeForSampling(input: string | null | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/GetGroupIdByCubicleBarcodeForSampling?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupIdByCubicleBarcodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupIdByCubicleBarcodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupIdByCubicleBarcodeForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param cubicleAssignmentHeaderId (optional) 
     * @return Success
     */
    getMaterialCodeByGroupId(cubicleAssignmentHeaderId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/GetMaterialCodeByGroupId?";
        if (cubicleAssignmentHeaderId === null)
            throw new Error("The parameter 'cubicleAssignmentHeaderId' cannot be null.");
        else if (cubicleAssignmentHeaderId !== undefined)
            url_ += "cubicleAssignmentHeaderId=" + encodeURIComponent("" + cubicleAssignmentHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialCodeByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialCodeByGroupId(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialCodeByGroupId(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param inspectionLotId (optional) 
     * @return Success
     */
    getMaterialCodeByGroupIdForSampling(inspectionLotId: number | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/GetMaterialCodeByGroupIdForSampling?";
        if (inspectionLotId === null)
            throw new Error("The parameter 'inspectionLotId' cannot be null.");
        else if (inspectionLotId !== undefined)
            url_ += "inspectionLotId=" + encodeURIComponent("" + inspectionLotId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialCodeByGroupIdForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialCodeByGroupIdForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialCodeByGroupIdForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStageOutSAPBatchNoMaterialCode(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/UpdateStageOutSAPBatchNoMaterialCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageOutSAPBatchNoMaterialCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageOutSAPBatchNoMaterialCode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStageOutSAPBatchNoMaterialCode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStageOutSAPBatchNoMaterialCodeForSampling(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/UpdateStageOutSAPBatchNoMaterialCodeForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageOutSAPBatchNoMaterialCodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageOutSAPBatchNoMaterialCodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStageOutSAPBatchNoMaterialCodeForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialContainerByBarcode(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/UpdateMaterialContainerByBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialContainerByBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialContainerByBarcode(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialContainerByBarcode(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStageOutContainerCountAndBalanceQuantity(body: StagingOutDto | undefined): Observable<StagingOutDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/UpdateStageOutContainerCountAndBalanceQuantity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageOutContainerCountAndBalanceQuantity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageOutContainerCountAndBalanceQuantity(<any>response_);
                } catch (e) {
                    return <Observable<StagingOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StagingOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStageOutContainerCountAndBalanceQuantity(response: HttpResponseBase): Observable<StagingOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StagingOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StagingOutDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterialContainerByBarcodeForSampling(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/UpdateMaterialContainerByBarcodeForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterialContainerByBarcodeForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterialContainerByBarcodeForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterialContainerByBarcodeForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeStageOut(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/CompleteStageOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteStageOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteStageOut(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteStageOut(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeStageOutForSampling(body: StagingOutDto | undefined): Observable<HTTPResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/StageOut/CompleteStageOutForSampling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteStageOutForSampling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteStageOutForSampling(<any>response_);
                } catch (e) {
                    return <Observable<HTTPResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HTTPResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteStageOutForSampling(response: HttpResponseBase): Observable<HTTPResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HTTPResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HTTPResponseDto>(<any>null);
    }
}

@Injectable()
export class StandardWeightServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param capacity (optional) 
     * @param departmentId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param keyword (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, capacity: number | null | undefined, departmentId: number | null | undefined, activeInactiveStatusId: number | null | undefined, keyword: string | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<StandardWeightListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (capacity !== undefined && capacity !== null)
            url_ += "Capacity=" + encodeURIComponent("" + capacity) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StandardWeightListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateStandardWeightDto | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StandardWeightDto | undefined): Observable<StandardWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StandardWeightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getStandardWeightStampingDueList(): Observable<StandardWeightStampingDueListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/GetStandardWeightStampingDueList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStandardWeightStampingDueList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardWeightStampingDueList(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightStampingDueListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightStampingDueListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStandardWeightStampingDueList(response: HttpResponseBase): Observable<StandardWeightStampingDueListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StandardWeightStampingDueListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightStampingDueListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectStandardWeight(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeight/ApproveOrRejectStandardWeight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectStandardWeight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectStandardWeight(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectStandardWeight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StandardWeightBoxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<StandardWeightBoxDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightBoxDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightBoxDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StandardWeightBoxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightBoxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightBoxDto>(<any>null);
    }

    /**
     * @param subPlantId (optional) 
     * @param keyword (optional) 
     * @param departmentId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(subPlantId: number | null | undefined, keyword: string | null | undefined, departmentId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<StandardWeightBoxListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/GetAll?";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightBoxListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightBoxListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StandardWeightBoxListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightBoxListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightBoxListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateStandardWeightBoxDto | undefined): Observable<StandardWeightBoxDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightBoxDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightBoxDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StandardWeightBoxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightBoxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightBoxDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: StandardWeightBoxDto | undefined): Observable<StandardWeightBoxDto> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<StandardWeightBoxDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardWeightBoxDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StandardWeightBoxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StandardWeightBoxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardWeightBoxDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectStandardWeightBox(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandardWeightBox/ApproveOrRejectStandardWeightBox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectStandardWeightBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectStandardWeightBox(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectStandardWeightBox(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateUsingActiveDirectory(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateUsingActiveDirectory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateUsingActiveDirectory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateUsingActiveDirectory(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateUsingActiveDirectory(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UnitOfMeasurementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UnitOfMeasurementDto> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasurementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasurementDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UnitOfMeasurementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasurementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasurementDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param unitOfMeasurementTypeId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, unitOfMeasurementTypeId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UnitOfMeasurementListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (unitOfMeasurementTypeId !== undefined && unitOfMeasurementTypeId !== null)
            url_ += "UnitOfMeasurementTypeId=" + encodeURIComponent("" + unitOfMeasurementTypeId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasurementListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasurementListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UnitOfMeasurementListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasurementListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasurementListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUnitOfMeasurementDto | undefined): Observable<UnitOfMeasurementDto> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasurementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasurementDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UnitOfMeasurementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasurementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasurementDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UnitOfMeasurementDto | undefined): Observable<UnitOfMeasurementDto> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasurementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasurementDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UnitOfMeasurementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasurementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasurementDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectUnitOfMeasurement(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UnitOfMeasurement/ApproveOrRejectUnitOfMeasurement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectUnitOfMeasurement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectUnitOfMeasurement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectUnitOfMeasurement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserProfile(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param plantId (optional) 
     * @param modeId (optional) 
     * @param designationId (optional) 
     * @param approvalStatusId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param creationFromTime (optional) 
     * @param creationToTime (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(userName: string | null | undefined, plantId: number | null | undefined, modeId: number | null | undefined, designationId: number | null | undefined, approvalStatusId: number | null | undefined, activeInactiveStatusId: number | null | undefined, creationFromTime: moment.Moment | null | undefined, creationToTime: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UsersListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (plantId !== undefined && plantId !== null)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&";
        if (modeId !== undefined && modeId !== null)
            url_ += "ModeId=" + encodeURIComponent("" + modeId) + "&";
        if (designationId !== undefined && designationId !== null)
            url_ += "DesignationId=" + encodeURIComponent("" + designationId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (creationFromTime !== undefined && creationFromTime !== null)
            url_ += "CreationFromTime=" + encodeURIComponent(creationFromTime ? "" + creationFromTime.toJSON() : "") + "&";
        if (creationToTime !== undefined && creationToTime !== null)
            url_ += "CreationToTime=" + encodeURIComponent(creationToTime ? "" + creationToTime.toJSON() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UsersListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UsersListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserProfile(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectUser(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ApproveOrRejectUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRoles(): Observable<RoleCheckboxDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleCheckboxDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleCheckboxDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleCheckboxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleCheckboxDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleCheckboxDto>(<any>null);
    }

    /**
     * @param noOfUsers (optional) 
     * @return Success
     */
    addOrUpdateUserCreationLimit(noOfUsers: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/AddOrUpdateUserCreationLimit?";
        if (noOfUsers === null)
            throw new Error("The parameter 'noOfUsers' cannot be null.");
        else if (noOfUsers !== undefined)
            url_ += "noOfUsers=" + encodeURIComponent("" + noOfUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateUserCreationLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateUserCreationLimit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateUserCreationLimit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class VehicleInspectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<VehicleInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/VehicleInspection/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VehicleInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param transactionStatusId (optional) 
     * @param purchaseOrderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, transactionStatusId: number | null | undefined, purchaseOrderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VehicleInspectionListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/VehicleInspection/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (transactionStatusId !== undefined && transactionStatusId !== null)
            url_ += "TransactionStatusId=" + encodeURIComponent("" + transactionStatusId) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VehicleInspectionListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleInspectionListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param gateEntryId (optional) 
     * @param pO_Number (optional) 
     * @param invoice_Number (optional) 
     * @param invoiceId (optional) 
     * @return Success
     */
    isVehicleInspectionPresent(gateEntryId: number | null | undefined, pO_Number: string | null | undefined, invoice_Number: string | null | undefined, invoiceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/VehicleInspection/IsVehicleInspectionPresent?";
        if (gateEntryId !== undefined && gateEntryId !== null)
            url_ += "gateEntryId=" + encodeURIComponent("" + gateEntryId) + "&";
        if (pO_Number !== undefined && pO_Number !== null)
            url_ += "PO_Number=" + encodeURIComponent("" + pO_Number) + "&";
        if (invoice_Number !== undefined && invoice_Number !== null)
            url_ += "invoice_Number=" + encodeURIComponent("" + invoice_Number) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsVehicleInspectionPresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsVehicleInspectionPresent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsVehicleInspectionPresent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateVehicleInspectionDto | undefined): Observable<VehicleInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/VehicleInspection/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VehicleInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateVehicleInspectionDto | undefined): Observable<VehicleInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/VehicleInspection/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<VehicleInspectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VehicleInspectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VehicleInspectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleInspectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleInspectionDto>(<any>null);
    }
}

@Injectable()
export class WeighingCalibrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param weighingMachineId (optional) 
     * @return Success
     */
    get(weighingMachineId: number | undefined): Observable<WeighingCalibrationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/Get?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeighingCalibrationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingCalibrationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeighingCalibrationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingCalibrationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingCalibrationDto>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @param frequencyId (optional) 
     * @return Success
     */
    isNewCalibration(weighingMachineId: number | undefined, frequencyId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/isNewCalibration?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        if (frequencyId !== undefined && frequencyId !== null)
            url_ += "frequencyId=" + encodeURIComponent("" + frequencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsNewCalibration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsNewCalibration(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsNewCalibration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param weighingCalibrationHeaderId (optional) 
     * @return Success
     */
    getCalibration(weighingCalibrationHeaderId: number | undefined): Observable<WeighingCalibrationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetCalibration?";
        if (weighingCalibrationHeaderId === null)
            throw new Error("The parameter 'weighingCalibrationHeaderId' cannot be null.");
        else if (weighingCalibrationHeaderId !== undefined)
            url_ += "WeighingCalibrationHeaderId=" + encodeURIComponent("" + weighingCalibrationHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalibration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalibration(<any>response_);
                } catch (e) {
                    return <Observable<WeighingCalibrationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingCalibrationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalibration(response: HttpResponseBase): Observable<WeighingCalibrationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingCalibrationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingCalibrationDto>(<any>null);
    }

    /**
     * @param weighingMachineCode (optional) 
     * @return Success
     */
    getWeighingMachineSelectListAutoComplete(weighingMachineCode: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetWeighingMachineSelectListAutoComplete?";
        if (weighingMachineCode !== undefined && weighingMachineCode !== null)
            url_ += "weighingMachineCode=" + encodeURIComponent("" + weighingMachineCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeighingMachineSelectListAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeighingMachineSelectListAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeighingMachineSelectListAutoComplete(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param standardWeightBoxId (optional) 
     * @return Success
     */
    getAllStandardWeightBoxAutoComplete(standardWeightBoxId: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetAllStandardWeightBoxAutoComplete?";
        if (standardWeightBoxId !== undefined && standardWeightBoxId !== null)
            url_ += "standardWeightBoxId=" + encodeURIComponent("" + standardWeightBoxId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStandardWeightBoxAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStandardWeightBoxAutoComplete(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStandardWeightBoxAutoComplete(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param standardWeightBoxId (optional) 
     * @return Success
     */
    getAllStandardWeightByBoxId(standardWeightBoxId: number | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetAllStandardWeightByBoxId?";
        if (standardWeightBoxId === null)
            throw new Error("The parameter 'standardWeightBoxId' cannot be null.");
        else if (standardWeightBoxId !== undefined)
            url_ += "standardWeightBoxId=" + encodeURIComponent("" + standardWeightBoxId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStandardWeightByBoxId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStandardWeightByBoxId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStandardWeightByBoxId(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param calibrationStatusId (optional) 
     * @param calibrationDate (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(calibrationStatusId: number | null | undefined, calibrationDate: moment.Moment | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WeighingCalibrationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetAll?";
        if (calibrationStatusId !== undefined && calibrationStatusId !== null)
            url_ += "CalibrationStatusId=" + encodeURIComponent("" + calibrationStatusId) + "&";
        if (calibrationDate !== undefined && calibrationDate !== null)
            url_ += "CalibrationDate=" + encodeURIComponent(calibrationDate ? "" + calibrationDate.toJSON() : "") + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WeighingCalibrationListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingCalibrationListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WeighingCalibrationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingCalibrationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingCalibrationListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWeighingCalibrationDto | undefined): Observable<CreateWeighingCalibrationResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateWeighingCalibrationResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateWeighingCalibrationResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateWeighingCalibrationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateWeighingCalibrationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateWeighingCalibrationResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WeighingCalibrationDto | undefined): Observable<WeighingCalibrationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WeighingCalibrationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingCalibrationDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WeighingCalibrationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingCalibrationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingCalibrationDto>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @param testWeight (optional) 
     * @return Success
     */
    getWeightByWeighingMachineCode(weighingMachineId: number | undefined, testWeight: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/GetWeightByWeighingMachineCode?";
        if (weighingMachineId === null)
            throw new Error("The parameter 'weighingMachineId' cannot be null.");
        else if (weighingMachineId !== undefined)
            url_ += "weighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        if (testWeight !== undefined && testWeight !== null)
            url_ += "testWeight=" + encodeURIComponent("" + testWeight) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightByWeighingMachineCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightByWeighingMachineCode(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightByWeighingMachineCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param weighingMachineId (optional) 
     * @return Success
     */
    isWeighingMachineCalibrated(weighingMachineId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WeighingCalibration/IsWeighingMachineCalibrated?";
        if (weighingMachineId !== undefined && weighingMachineId !== null)
            url_ += "WeighingMachineId=" + encodeURIComponent("" + weighingMachineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsWeighingMachineCalibrated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsWeighingMachineCalibrated(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsWeighingMachineCalibrated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class WeighingMachineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param subPlantId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param approvalStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, subPlantId: number | null | undefined, activeInactiveStatusId: number | null | undefined, approvalStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WeighingMachineListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (subPlantId !== undefined && subPlantId !== null)
            url_ += "SubPlantId=" + encodeURIComponent("" + subPlantId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (approvalStatusId !== undefined && approvalStatusId !== null)
            url_ += "ApprovalStatusId=" + encodeURIComponent("" + approvalStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WeighingMachineListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWeighingMachineDto | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WeighingMachineDto | undefined): Observable<WeighingMachineDto> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WeighingMachineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeighingMachineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectWeighingMachine(body: ApprovalStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/ApproveOrRejectWeighingMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectWeighingMachine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectWeighingMachine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectWeighingMachine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getStampingDueOnWMList(): Observable<WeighingMachineStampingDueOnListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeighingMachine/GetStampingDueOnWMList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStampingDueOnWMList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStampingDueOnWMList(<any>response_);
                } catch (e) {
                    return <Observable<WeighingMachineStampingDueOnListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeighingMachineStampingDueOnListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStampingDueOnWMList(response: HttpResponseBase): Observable<WeighingMachineStampingDueOnListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WeighingMachineStampingDueOnListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeighingMachineStampingDueOnListDto[]>(<any>null);
    }
}

@Injectable()
export class WeightCaptureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WeightCaptureDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeightCaptureDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightCaptureDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeightCaptureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightCaptureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightCaptureDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param purchaseOrderId (optional) 
     * @param materialId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, purchaseOrderId: number | null | undefined, materialId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WeightCaptureListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (materialId !== undefined && materialId !== null)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WeightCaptureListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightCaptureListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WeightCaptureListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightCaptureListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightCaptureListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWeightCaptureDto | undefined): Observable<WeightCaptureDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WeightCaptureDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightCaptureDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WeightCaptureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightCaptureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightCaptureDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertWeightCaptureDetail(body: WeightCaptureDetailsDto | undefined): Observable<WeightCaptureDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/InsertWeightCaptureDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertWeightCaptureDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertWeightCaptureDetail(<any>response_);
                } catch (e) {
                    return <Observable<WeightCaptureDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightCaptureDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processInsertWeightCaptureDetail(response: HttpResponseBase): Observable<WeightCaptureDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightCaptureDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightCaptureDetailsDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWeightCaptureDetails(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/DeleteWeightCaptureDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWeightCaptureDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWeightCaptureDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWeightCaptureDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @param invoiceId (optional) 
     * @param materialId (optional) 
     * @param mfgBatchNoId (optional) 
     * @return Success
     */
    isWeightCapturePresent(purchaseOrderId: number | null | undefined, invoiceId: number | null | undefined, materialId: number | null | undefined, mfgBatchNoId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WeightCapture/IsWeightCapturePresent?";
        if (purchaseOrderId !== undefined && purchaseOrderId !== null)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (materialId !== undefined && materialId !== null)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&";
        if (mfgBatchNoId !== undefined && mfgBatchNoId !== null)
            url_ += "MfgBatchNoId=" + encodeURIComponent("" + mfgBatchNoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsWeightCapturePresent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsWeightCapturePresent(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processIsWeightCapturePresent(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class WeightVerificationServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDispenseBarcode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetDispenseBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispenseBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispenseBarcode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispenseBarcode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDispenseDetailsr(input: number | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetDispenseDetailsr?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispenseDetailsr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispenseDetailsr(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispenseDetailsr(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWeightVerificationfromDispenseId(input: number | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetWeightVerificationfromDispenseId?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightVerificationfromDispenseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightVerificationfromDispenseId(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightVerificationfromDispenseId(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDispenseBarcodefromId(input: number | undefined): Observable<SelectListDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetDispenseBarcodefromId?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDispenseBarcodefromId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDispenseBarcodefromId(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDispenseBarcodefromId(response: HttpResponseBase): Observable<SelectListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBatchDetailsOfProcessOrder(input: number | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetBatchDetailsOfProcessOrder?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchDetailsOfProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchDetailsOfProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchDetailsOfProcessOrder(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWeightVerificationDto | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param productCode (optional) 
     * @param processOrderNo (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, productCode: string | null | undefined, processOrderNo: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WeightVerificationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (processOrderNo !== undefined && processOrderNo !== null)
            url_ += "ProcessOrderNo=" + encodeURIComponent("" + processOrderNo) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WeightVerificationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WeightVerificationDto | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WeightVerificationDto> {
        let url_ = this.baseUrl + "/api/services/app/WeightVerificationService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeightVerificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightVerificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeightVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeightVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightVerificationDto>(<any>null);
    }
}

@Injectable()
export class WIPLineClearanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWIPLineClearanceDto | undefined): Observable<WIPLineClearanceTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WIPLineClearanceTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WIPLineClearanceTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WIPLineClearanceTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WIPLineClearanceTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WIPLineClearanceTransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WIPLineClearanceTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param processOrderId (optional) 
     * @return Success
     */
    validateLineClearance(processOrderId: number | undefined): Observable<WIPLineClearanceTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/ValidateLineClearance?";
        if (processOrderId === null)
            throw new Error("The parameter 'processOrderId' cannot be null.");
        else if (processOrderId !== undefined)
            url_ += "processOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateLineClearance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateLineClearance(<any>response_);
                } catch (e) {
                    return <Observable<WIPLineClearanceTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WIPLineClearanceTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateLineClearance(response: HttpResponseBase): Observable<WIPLineClearanceTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WIPLineClearanceTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WIPLineClearanceTransactionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProductDesc(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetProductDesc?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductDesc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductDesc(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductDesc(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param checklistId (optional) 
     * @param modeId (optional) 
     * @return Success
     */
    getCheckpointsByChecklistId(checklistId: number | undefined, modeId: number | undefined): Observable<CheckpointDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetCheckpointsByChecklistId?";
        if (checklistId === null)
            throw new Error("The parameter 'checklistId' cannot be null.");
        else if (checklistId !== undefined)
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&";
        if (modeId === null)
            throw new Error("The parameter 'modeId' cannot be null.");
        else if (modeId !== undefined)
            url_ += "modeId=" + encodeURIComponent("" + modeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckpointsByChecklistId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckpointsByChecklistId(<any>response_);
                } catch (e) {
                    return <Observable<CheckpointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckpointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckpointsByChecklistId(response: HttpResponseBase): Observable<CheckpointDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CheckpointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckpointDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isAssignedProcessOrder(body: WIPLineClearanceTransactionDto | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/IsAssignedProcessOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAssignedProcessOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAssignedProcessOrder(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processIsAssignedProcessOrder(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param processOderId (optional) 
     * @return Success
     */
    isCheckProcessOrderAlreadyUsed(processOderId: number | undefined): Observable<BarcodeValidationDto> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/IsCheckProcessOrderAlreadyUsed?";
        if (processOderId === null)
            throw new Error("The parameter 'processOderId' cannot be null.");
        else if (processOderId !== undefined)
            url_ += "processOderId=" + encodeURIComponent("" + processOderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsCheckProcessOrderAlreadyUsed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsCheckProcessOrderAlreadyUsed(<any>response_);
                } catch (e) {
                    return <Observable<BarcodeValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BarcodeValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processIsCheckProcessOrderAlreadyUsed(response: HttpResponseBase): Observable<BarcodeValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BarcodeValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BarcodeValidationDto>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @return Success
     */
    getStatusListByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined): Observable<StatusMaster[]> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetStatusListByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusListByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusListByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<StatusMaster[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusMaster[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusListByModuleSubModuleName(response: HttpResponseBase): Observable<StatusMaster[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusMaster.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusMaster[]>(<any>null);
    }

    /**
     * @param module (optional) 
     * @param submodule (optional) 
     * @param status (optional) 
     * @return Success
     */
    getStatusByModuleSubModuleName(module: string | null | undefined, submodule: string | null | undefined, status: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetStatusByModuleSubModuleName?";
        if (module !== undefined && module !== null)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        if (submodule !== undefined && submodule !== null)
            url_ += "submodule=" + encodeURIComponent("" + submodule) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusByModuleSubModuleName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModuleSubModuleName(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusByModuleSubModuleName(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllEquipmentBarcode(input: string | null | undefined): Observable<EquipmentCleaningBarcodeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WIPLineClearance/GetAllEquipmentBarcode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquipmentBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquipmentBarcode(<any>response_);
                } catch (e) {
                    return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EquipmentCleaningBarcodeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquipmentBarcode(response: HttpResponseBase): Observable<EquipmentCleaningBarcodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EquipmentCleaningBarcodeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EquipmentCleaningBarcodeDto[]>(<any>null);
    }
}

@Injectable()
export class WipPickingServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWipPickingDto | undefined): Observable<WipPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WipPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WipPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WipPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WipPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WipPickingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param containerCode (optional) 
     * @param productId (optional) 
     * @param processOrderId (optional) 
     * @param activeInactiveStatusId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, containerCode: string | null | undefined, productId: string | null | undefined, processOrderId: number | null | undefined, activeInactiveStatusId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WipPickingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (containerCode !== undefined && containerCode !== null)
            url_ += "ContainerCode=" + encodeURIComponent("" + containerCode) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (processOrderId !== undefined && processOrderId !== null)
            url_ += "ProcessOrderId=" + encodeURIComponent("" + processOrderId) + "&";
        if (activeInactiveStatusId !== undefined && activeInactiveStatusId !== null)
            url_ += "ActiveInactiveStatusId=" + encodeURIComponent("" + activeInactiveStatusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WipPickingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WipPickingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WipPickingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WipPickingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WipPickingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WipPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WipPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WipPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WipPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WipPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WipPickingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WipPickingDto | undefined): Observable<WipPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WipPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WipPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WipPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WipPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WipPickingDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllProductCode(input: string | null | undefined): Observable<SelectListDtoWithPlantId[]> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/GetAllProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDtoWithPlantId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductCode(response: HttpResponseBase): Observable<SelectListDtoWithPlantId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDtoWithPlantId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDtoWithPlantId[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProcessOrdersOfProductCode(input: string | null | undefined): Observable<SelectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/GetProcessOrdersOfProductCode?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessOrdersOfProductCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessOrdersOfProductCode(<any>response_);
                } catch (e) {
                    return <Observable<SelectListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessOrdersOfProductCode(response: HttpResponseBase): Observable<SelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SelectListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectListDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBatchNosStage(input: number | undefined): Observable<WipPickingDto> {
        let url_ = this.baseUrl + "/api/services/app/WipPickingService/GetBatchNosStage?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchNosStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchNosStage(<any>response_);
                } catch (e) {
                    return <Observable<WipPickingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WipPickingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchNosStage(response: HttpResponseBase): Observable<WipPickingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WipPickingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WipPickingDto>(<any>null);
    }
}

@Injectable()
export class ZServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ZDto> {
        let url_ = this.baseUrl + "/api/services/app/Z/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ZDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ZDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ForgotPasswordDto implements IForgotPasswordDto {
    employeeCode: string;
    passwordStatus: number;

    constructor(data?: IForgotPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeCode = _data["employeeCode"];
            this.passwordStatus = _data["passwordStatus"];
        }
    }

    static fromJS(data: any): ForgotPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeCode"] = this.employeeCode;
        data["passwordStatus"] = this.passwordStatus;
        return data; 
    }

    clone(): ForgotPasswordDto {
        const json = this.toJSON();
        let result = new ForgotPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordDto {
    employeeCode: string;
    passwordStatus: number;
}

export class ForgotPasswordOutput implements IForgotPasswordOutput {
    result: boolean;
    userRole: string | undefined;

    constructor(data?: IForgotPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.userRole = _data["userRole"];
        }
    }

    static fromJS(data: any): ForgotPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["userRole"] = this.userRole;
        return data; 
    }

    clone(): ForgotPasswordOutput {
        const json = this.toJSON();
        let result = new ForgotPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordOutput {
    result: boolean;
    userRole: string | undefined;
}

export class ActivityDto implements IActivityDto {
    activityName: string;
    activityCode: string;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.activityCode = _data["activityCode"];
            this.description = _data["description"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["activityCode"] = this.activityCode;
        data["description"] = this.description;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityDto {
        const json = this.toJSON();
        let result = new ActivityDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDto {
    activityName: string;
    activityCode: string;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class ActivityListDto implements IActivityListDto {
    activityName: string | undefined;
    activityCode: string | undefined;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    userEnteredModuleId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IActivityListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.activityCode = _data["activityCode"];
            this.description = _data["description"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.userEnteredModuleId = _data["userEnteredModuleId"];
            this.userEnteredSubModuleId = _data["userEnteredSubModuleId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["activityCode"] = this.activityCode;
        data["description"] = this.description;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["userEnteredModuleId"] = this.userEnteredModuleId;
        data["userEnteredSubModuleId"] = this.userEnteredSubModuleId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityListDto {
        const json = this.toJSON();
        let result = new ActivityListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityListDto {
    activityName: string | undefined;
    activityCode: string | undefined;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    userEnteredModuleId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class ActivityListDtoPagedResultDto implements IActivityListDtoPagedResultDto {
    totalCount: number;
    items: ActivityListDto[] | undefined;

    constructor(data?: IActivityListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActivityListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ActivityListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ActivityListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IActivityListDtoPagedResultDto {
    totalCount: number;
    items: ActivityListDto[] | undefined;
}

export class CreateActivityDto implements ICreateActivityDto {
    activityName: string;
    activityCode: string;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.activityCode = _data["activityCode"];
            this.description = _data["description"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["activityCode"] = this.activityCode;
        data["description"] = this.description;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateActivityDto {
        const json = this.toJSON();
        let result = new CreateActivityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityDto {
    activityName: string;
    activityCode: string;
    description: string | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
}

export class ApprovalStatusDto implements IApprovalStatusDto {
    approvalStatusId: number;
    description: string | undefined;
    id: number;

    constructor(data?: IApprovalStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalStatusId = _data["approvalStatusId"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalStatusId"] = this.approvalStatusId;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalStatusDto {
        const json = this.toJSON();
        let result = new ApprovalStatusDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalStatusDto {
    approvalStatusId: number;
    description: string | undefined;
    id: number;
}

export class ApprovalLevelDto implements IApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalLevelDto {
        const json = this.toJSON();
        let result = new ApprovalLevelDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ApprovalLevelListDto implements IApprovalLevelListDto {
    levelCode: number;
    levelName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalLevelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalLevelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalLevelListDto {
        const json = this.toJSON();
        let result = new ApprovalLevelListDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelListDto {
    levelCode: number;
    levelName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ApprovalLevelListDtoPagedResultDto implements IApprovalLevelListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalLevelListDto[] | undefined;

    constructor(data?: IApprovalLevelListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalLevelListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalLevelListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLevelListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApprovalLevelListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalLevelListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalLevelListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalLevelListDto[] | undefined;
}

export class CreateApprovalLevelDto implements ICreateApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateApprovalLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelCode = _data["levelCode"];
            this.levelName = _data["levelName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateApprovalLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateApprovalLevelDto {
        const json = this.toJSON();
        let result = new CreateApprovalLevelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalLevelDto {
    levelCode: number;
    levelName: string;
    description: string | undefined;
    isActive: boolean;
}

export class SelectListDto implements ISelectListDto {
    value: string | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone(): SelectListDto {
        const json = this.toJSON();
        let result = new SelectListDto();
        result.init(json);
        return result;
    }
}

export interface ISelectListDto {
    value: string | undefined;
    id: any | undefined;
}

export class ApprovalUserModuleMappingDto implements IApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    id: number;

    constructor(data?: IApprovalUserModuleMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalUserModuleMappingDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    id: number;
}

export class ApprovalUserModuleMappingListDto implements IApprovalUserModuleMappingListDto {
    userEnteredAppLevelId: string | undefined;
    userEnteredUserId: string | undefined;
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    id: number;

    constructor(data?: IApprovalUserModuleMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEnteredAppLevelId = _data["userEnteredAppLevelId"];
            this.userEnteredUserId = _data["userEnteredUserId"];
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.moduleName = _data["moduleName"];
            this.subModuleName = _data["subModuleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEnteredAppLevelId"] = this.userEnteredAppLevelId;
        data["userEnteredUserId"] = this.userEnteredUserId;
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["moduleName"] = this.moduleName;
        data["subModuleName"] = this.subModuleName;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalUserModuleMappingListDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingListDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingListDto {
    userEnteredAppLevelId: string | undefined;
    userEnteredUserId: string | undefined;
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    id: number;
}

export class ApprovalUserModuleMappingListDtoPagedResultDto implements IApprovalUserModuleMappingListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalUserModuleMappingListDto[] | undefined;

    constructor(data?: IApprovalUserModuleMappingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalUserModuleMappingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalUserModuleMappingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserModuleMappingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApprovalUserModuleMappingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalUserModuleMappingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalUserModuleMappingListDtoPagedResultDto {
    totalCount: number;
    items: ApprovalUserModuleMappingListDto[] | undefined;
}

export class CreateApprovalUserModuleMappingDto implements ICreateApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;

    constructor(data?: ICreateApprovalUserModuleMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appLevelId = _data["appLevelId"];
            this.userId = _data["userId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateApprovalUserModuleMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalUserModuleMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appLevelId"] = this.appLevelId;
        data["userId"] = this.userId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateApprovalUserModuleMappingDto {
        const json = this.toJSON();
        let result = new CreateApprovalUserModuleMappingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalUserModuleMappingDto {
    appLevelId: number;
    userId: number;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
}

export class AreaDto implements IAreaDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentId = _data["departmentId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.zone = _data["zone"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentId"] = this.departmentId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["zone"] = this.zone;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaDto {
        const json = this.toJSON();
        let result = new AreaDto();
        result.init(json);
        return result;
    }
}

export interface IAreaDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class AreaListDto implements IAreaListDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string | undefined;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IAreaListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentId = _data["departmentId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentId"] = this.departmentId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaListDto {
        const json = this.toJSON();
        let result = new AreaListDto();
        result.init(json);
        return result;
    }
}

export interface IAreaListDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string | undefined;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class AreaListDtoPagedResultDto implements IAreaListDtoPagedResultDto {
    totalCount: number;
    items: AreaListDto[] | undefined;

    constructor(data?: IAreaListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AreaListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AreaListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AreaListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AreaListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAreaListDtoPagedResultDto {
    totalCount: number;
    items: AreaListDto[] | undefined;
}

export class CreateAreaDto implements ICreateAreaDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;

    constructor(data?: ICreateAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentId = _data["departmentId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.zone = _data["zone"];
        }
    }

    static fromJS(data: any): CreateAreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentId"] = this.departmentId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["zone"] = this.zone;
        return data; 
    }

    clone(): CreateAreaDto {
        const json = this.toJSON();
        let result = new CreateAreaDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAreaDto {
    subPlantId: number;
    departmentId: number;
    areaCode: string | undefined;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;
}

export class CheckpointDto implements ICheckpointDto {
    inspectionChecklistId: number | undefined;
    checkpointName: string;
    checkpointTypeId: number;
    checkpointTypeName: string | undefined;
    groupIndex: number;
    modeId: number;
    isControllerMode: boolean;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    checkPointId: number | undefined;
    plantId: number | undefined;
    checkListTypeId: number | undefined;
    id: number;

    constructor(data?: ICheckpointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.checkpointName = _data["checkpointName"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.checkpointTypeName = _data["checkpointTypeName"];
            this.groupIndex = _data["groupIndex"];
            this.modeId = _data["modeId"];
            this.isControllerMode = _data["isControllerMode"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.checkPointId = _data["checkPointId"];
            this.plantId = _data["plantId"];
            this.checkListTypeId = _data["checkListTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CheckpointDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["checkpointName"] = this.checkpointName;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["checkpointTypeName"] = this.checkpointTypeName;
        data["groupIndex"] = this.groupIndex;
        data["modeId"] = this.modeId;
        data["isControllerMode"] = this.isControllerMode;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["checkPointId"] = this.checkPointId;
        data["plantId"] = this.plantId;
        data["checkListTypeId"] = this.checkListTypeId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CheckpointDto {
        const json = this.toJSON();
        let result = new CheckpointDto();
        result.init(json);
        return result;
    }
}

export interface ICheckpointDto {
    inspectionChecklistId: number | undefined;
    checkpointName: string;
    checkpointTypeId: number;
    checkpointTypeName: string | undefined;
    groupIndex: number;
    modeId: number;
    isControllerMode: boolean;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    checkPointId: number | undefined;
    plantId: number | undefined;
    checkListTypeId: number | undefined;
    id: number;
}

export class AreaUsageLogDto implements IAreaUsageLogDto {
    activityID: number;
    cubicalId: number;
    cubicalCode: string | undefined;
    operatorName: string;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isVerified: boolean;
    isApproved: boolean;
    isRejected: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    isActive: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;
    status: boolean;
    creatorUserId: number | undefined;
    areaUsageCheckpoints: CheckpointDto[] | undefined;
    id: number;

    constructor(data?: IAreaUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.cubicalId = _data["cubicalId"];
            this.cubicalCode = _data["cubicalCode"];
            this.operatorName = _data["operatorName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isVerified = _data["isVerified"];
            this.isApproved = _data["isApproved"];
            this.isRejected = _data["isRejected"];
            this.canApproved = _data["canApproved"];
            this.canVerified = _data["canVerified"];
            this.approvedByName = _data["approvedByName"];
            this.creatorName = _data["creatorName"];
            this.isInValidTransaction = _data["isInValidTransaction"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["areaUsageLogLists"])) {
                this.areaUsageLogLists = [] as any;
                for (let item of _data["areaUsageLogLists"])
                    this.areaUsageLogLists.push(CheckpointDto.fromJS(item));
            }
            this.status = _data["status"];
            this.creatorUserId = _data["creatorUserId"];
            if (Array.isArray(_data["areaUsageCheckpoints"])) {
                this.areaUsageCheckpoints = [] as any;
                for (let item of _data["areaUsageCheckpoints"])
                    this.areaUsageCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["cubicalId"] = this.cubicalId;
        data["cubicalCode"] = this.cubicalCode;
        data["operatorName"] = this.operatorName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isVerified"] = this.isVerified;
        data["isApproved"] = this.isApproved;
        data["isRejected"] = this.isRejected;
        data["canApproved"] = this.canApproved;
        data["canVerified"] = this.canVerified;
        data["approvedByName"] = this.approvedByName;
        data["creatorName"] = this.creatorName;
        data["isInValidTransaction"] = this.isInValidTransaction;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.areaUsageLogLists)) {
            data["areaUsageLogLists"] = [];
            for (let item of this.areaUsageLogLists)
                data["areaUsageLogLists"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["creatorUserId"] = this.creatorUserId;
        if (Array.isArray(this.areaUsageCheckpoints)) {
            data["areaUsageCheckpoints"] = [];
            for (let item of this.areaUsageCheckpoints)
                data["areaUsageCheckpoints"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaUsageLogDto {
        const json = this.toJSON();
        let result = new AreaUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface IAreaUsageLogDto {
    activityID: number;
    cubicalId: number;
    cubicalCode: string | undefined;
    operatorName: string;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isVerified: boolean;
    isApproved: boolean;
    isRejected: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    isActive: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;
    status: boolean;
    creatorUserId: number | undefined;
    areaUsageCheckpoints: CheckpointDto[] | undefined;
    id: number;
}

export class AreaUsageLogListDto implements IAreaUsageLogListDto {
    activityID: number | undefined;
    cubicalId: number | undefined;
    operatorName: string | undefined;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    userEnteredActivityId: string | undefined;
    userEnteredCubicalId: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IAreaUsageLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.cubicalId = _data["cubicalId"];
            this.operatorName = _data["operatorName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.userEnteredActivityId = _data["userEnteredActivityId"];
            this.userEnteredCubicalId = _data["userEnteredCubicalId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaUsageLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaUsageLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["cubicalId"] = this.cubicalId;
        data["operatorName"] = this.operatorName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["userEnteredActivityId"] = this.userEnteredActivityId;
        data["userEnteredCubicalId"] = this.userEnteredCubicalId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaUsageLogListDto {
        const json = this.toJSON();
        let result = new AreaUsageLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAreaUsageLogListDto {
    activityID: number | undefined;
    cubicalId: number | undefined;
    operatorName: string | undefined;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    userEnteredActivityId: string | undefined;
    userEnteredCubicalId: string | undefined;
    isActive: boolean;
    id: number;
}

export class AreaUsageLogListDtoPagedResultDto implements IAreaUsageLogListDtoPagedResultDto {
    totalCount: number;
    items: AreaUsageLogListDto[] | undefined;

    constructor(data?: IAreaUsageLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AreaUsageLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AreaUsageLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaUsageLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AreaUsageLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AreaUsageLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAreaUsageLogListDtoPagedResultDto {
    totalCount: number;
    items: AreaUsageLogListDto[] | undefined;
}

export class CreateAreaUsageLogDto implements ICreateAreaUsageLogDto {
    activityID: number;
    cubicalId: number;
    cubicalCode: string | undefined;
    operatorName: string;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isActive: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;

    constructor(data?: ICreateAreaUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.cubicalId = _data["cubicalId"];
            this.cubicalCode = _data["cubicalCode"];
            this.operatorName = _data["operatorName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["areaUsageLogLists"])) {
                this.areaUsageLogLists = [] as any;
                for (let item of _data["areaUsageLogLists"])
                    this.areaUsageLogLists.push(CheckpointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateAreaUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAreaUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["cubicalId"] = this.cubicalId;
        data["cubicalCode"] = this.cubicalCode;
        data["operatorName"] = this.operatorName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.areaUsageLogLists)) {
            data["areaUsageLogLists"] = [];
            for (let item of this.areaUsageLogLists)
                data["areaUsageLogLists"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateAreaUsageLogDto {
        const json = this.toJSON();
        let result = new CreateAreaUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAreaUsageLogDto {
    activityID: number;
    cubicalId: number;
    cubicalCode: string | undefined;
    operatorName: string;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isActive: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;
}

export class UpdateAreaUsageLogDto implements IUpdateAreaUsageLogDto {
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;
    id: number;

    constructor(data?: IUpdateAreaUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isApproved = _data["isApproved"];
            this.isRejected = _data["isRejected"];
            if (Array.isArray(_data["areaUsageLogLists"])) {
                this.areaUsageLogLists = [] as any;
                for (let item of _data["areaUsageLogLists"])
                    this.areaUsageLogLists.push(CheckpointDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAreaUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAreaUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isApproved"] = this.isApproved;
        data["isRejected"] = this.isRejected;
        if (Array.isArray(this.areaUsageLogLists)) {
            data["areaUsageLogLists"] = [];
            for (let item of this.areaUsageLogLists)
                data["areaUsageLogLists"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateAreaUsageLogDto {
        const json = this.toJSON();
        let result = new UpdateAreaUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAreaUsageLogDto {
    stopTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    areaUsageLogLists: CheckpointDto[] | undefined;
    id: number;
}

export class GateMaster implements IGateMaster {
    plantId: number;
    gateCode: string | undefined;
    name: string | undefined;
    aliasName: string | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGateMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.gateCode = _data["gateCode"];
            this.name = _data["name"];
            this.aliasName = _data["aliasName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GateMaster {
        data = typeof data === 'object' ? data : {};
        let result = new GateMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["gateCode"] = this.gateCode;
        data["name"] = this.name;
        data["aliasName"] = this.aliasName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateMaster {
        const json = this.toJSON();
        let result = new GateMaster();
        result.init(json);
        return result;
    }
}

export interface IGateMaster {
    plantId: number;
    gateCode: string | undefined;
    name: string | undefined;
    aliasName: string | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class PutAwayBinToBinTransfer implements IPutAwayBinToBinTransfer {
    locationId: number | undefined;
    palletId: number | undefined;
    materialId: number | undefined;
    containerId: number | undefined;
    materialTransferTypeId: number | undefined;
    transactionId: string;
    sapBatchNumber: string | undefined;
    containerNo: number;
    isUnloaded: boolean;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IPutAwayBinToBinTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"];
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.containerId = _data["containerId"];
            this.materialTransferTypeId = _data["materialTransferTypeId"];
            this.transactionId = _data["transactionId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.containerNo = _data["containerNo"];
            this.isUnloaded = _data["isUnloaded"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PutAwayBinToBinTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new PutAwayBinToBinTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["containerId"] = this.containerId;
        data["materialTransferTypeId"] = this.materialTransferTypeId;
        data["transactionId"] = this.transactionId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["containerNo"] = this.containerNo;
        data["isUnloaded"] = this.isUnloaded;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): PutAwayBinToBinTransfer {
        const json = this.toJSON();
        let result = new PutAwayBinToBinTransfer();
        result.init(json);
        return result;
    }
}

export interface IPutAwayBinToBinTransfer {
    locationId: number | undefined;
    palletId: number | undefined;
    materialId: number | undefined;
    containerId: number | undefined;
    materialTransferTypeId: number | undefined;
    transactionId: string;
    sapBatchNumber: string | undefined;
    containerNo: number;
    isUnloaded: boolean;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class LocationMaster implements ILocationMaster {
    locationCode: string | undefined;
    storageLocationType: string | undefined;
    plantId: number;
    departmentId: number;
    areaId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ILocationMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCode = _data["locationCode"];
            this.storageLocationType = _data["storageLocationType"];
            this.plantId = _data["plantId"];
            this.departmentId = _data["departmentId"];
            this.areaId = _data["areaId"];
            this.zone = _data["zone"];
            this.locationTemperature = _data["locationTemperature"];
            this.locationTemperatureUL = _data["locationTemperatureUL"];
            this.temperatureUnit = _data["temperatureUnit"];
            this.slocType = _data["slocType"];
            this.levelId = _data["levelId"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["putAwayBinToBinTransfers"])) {
                this.putAwayBinToBinTransfers = [] as any;
                for (let item of _data["putAwayBinToBinTransfers"])
                    this.putAwayBinToBinTransfers.push(PutAwayBinToBinTransfer.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LocationMaster {
        data = typeof data === 'object' ? data : {};
        let result = new LocationMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCode"] = this.locationCode;
        data["storageLocationType"] = this.storageLocationType;
        data["plantId"] = this.plantId;
        data["departmentId"] = this.departmentId;
        data["areaId"] = this.areaId;
        data["zone"] = this.zone;
        data["locationTemperature"] = this.locationTemperature;
        data["locationTemperatureUL"] = this.locationTemperatureUL;
        data["temperatureUnit"] = this.temperatureUnit;
        data["slocType"] = this.slocType;
        data["levelId"] = this.levelId;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.putAwayBinToBinTransfers)) {
            data["putAwayBinToBinTransfers"] = [];
            for (let item of this.putAwayBinToBinTransfers)
                data["putAwayBinToBinTransfers"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): LocationMaster {
        const json = this.toJSON();
        let result = new LocationMaster();
        result.init(json);
        return result;
    }
}

export interface ILocationMaster {
    locationCode: string | undefined;
    storageLocationType: string | undefined;
    plantId: number;
    departmentId: number;
    areaId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class GRNMaterialLabelPrintingDetail implements IGRNMaterialLabelPrintingDetail {
    grnMaterialLabelPrintingHeaderId: number | undefined;
    printerId: number | undefined;
    isController: boolean;
    rangePrint: string | undefined;
    comment: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGRNMaterialLabelPrintingDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnMaterialLabelPrintingHeaderId = _data["grnMaterialLabelPrintingHeaderId"];
            this.printerId = _data["printerId"];
            this.isController = _data["isController"];
            this.rangePrint = _data["rangePrint"];
            this.comment = _data["comment"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNMaterialLabelPrintingDetail {
        data = typeof data === 'object' ? data : {};
        let result = new GRNMaterialLabelPrintingDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnMaterialLabelPrintingHeaderId"] = this.grnMaterialLabelPrintingHeaderId;
        data["printerId"] = this.printerId;
        data["isController"] = this.isController;
        data["rangePrint"] = this.rangePrint;
        data["comment"] = this.comment;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNMaterialLabelPrintingDetail {
        const json = this.toJSON();
        let result = new GRNMaterialLabelPrintingDetail();
        result.init(json);
        return result;
    }
}

export interface IGRNMaterialLabelPrintingDetail {
    grnMaterialLabelPrintingHeaderId: number | undefined;
    printerId: number | undefined;
    isController: boolean;
    rangePrint: string | undefined;
    comment: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class DispensingPrintDetail implements IDispensingPrintDetail {
    dispensingDetailId: number | undefined;
    deviceId: number | undefined;
    isController: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IDispensingPrintDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispensingDetailId = _data["dispensingDetailId"];
            this.deviceId = _data["deviceId"];
            this.isController = _data["isController"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispensingPrintDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingPrintDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispensingDetailId"] = this.dispensingDetailId;
        data["deviceId"] = this.deviceId;
        data["isController"] = this.isController;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DispensingPrintDetail {
        const json = this.toJSON();
        let result = new DispensingPrintDetail();
        result.init(json);
        return result;
    }
}

export interface IDispensingPrintDetail {
    dispensingDetailId: number | undefined;
    deviceId: number | undefined;
    isController: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class DeviceMaster implements IDeviceMaster {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    grnMaterialLabelPrintingDetails: GRNMaterialLabelPrintingDetail[] | undefined;
    dispensingPrintDetails: DispensingPrintDetail[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IDeviceMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.deviceId = _data["deviceId"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.serialNo = _data["serialNo"];
            this.ipAddress = _data["ipAddress"];
            this.port = _data["port"];
            this.departmentId = _data["departmentId"];
            this.areaId = _data["areaId"];
            this.cubicleId = _data["cubicleId"];
            this.modeId = _data["modeId"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["grnMaterialLabelPrintingDetails"])) {
                this.grnMaterialLabelPrintingDetails = [] as any;
                for (let item of _data["grnMaterialLabelPrintingDetails"])
                    this.grnMaterialLabelPrintingDetails.push(GRNMaterialLabelPrintingDetail.fromJS(item));
            }
            if (Array.isArray(_data["dispensingPrintDetails"])) {
                this.dispensingPrintDetails = [] as any;
                for (let item of _data["dispensingPrintDetails"])
                    this.dispensingPrintDetails.push(DispensingPrintDetail.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceMaster {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["deviceId"] = this.deviceId;
        data["deviceTypeId"] = this.deviceTypeId;
        data["make"] = this.make;
        data["model"] = this.model;
        data["serialNo"] = this.serialNo;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["departmentId"] = this.departmentId;
        data["areaId"] = this.areaId;
        data["cubicleId"] = this.cubicleId;
        data["modeId"] = this.modeId;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.grnMaterialLabelPrintingDetails)) {
            data["grnMaterialLabelPrintingDetails"] = [];
            for (let item of this.grnMaterialLabelPrintingDetails)
                data["grnMaterialLabelPrintingDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.dispensingPrintDetails)) {
            data["dispensingPrintDetails"] = [];
            for (let item of this.dispensingPrintDetails)
                data["dispensingPrintDetails"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DeviceMaster {
        const json = this.toJSON();
        let result = new DeviceMaster();
        result.init(json);
        return result;
    }
}

export interface IDeviceMaster {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    grnMaterialLabelPrintingDetails: GRNMaterialLabelPrintingDetail[] | undefined;
    dispensingPrintDetails: DispensingPrintDetail[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CubicleCleaningCheckpoint implements ICubicleCleaningCheckpoint {
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    cubicleCleaningTransactionId: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleCleaningCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkPointId = _data["checkPointId"];
            this.observation = _data["observation"];
            this.remark = _data["remark"];
            this.cubicleCleaningTransactionId = _data["cubicleCleaningTransactionId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleCleaningCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleCleaningCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkPointId"] = this.checkPointId;
        data["observation"] = this.observation;
        data["remark"] = this.remark;
        data["cubicleCleaningTransactionId"] = this.cubicleCleaningTransactionId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleCleaningCheckpoint {
        const json = this.toJSON();
        let result = new CubicleCleaningCheckpoint();
        result.init(json);
        return result;
    }
}

export interface ICubicleCleaningCheckpoint {
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    cubicleCleaningTransactionId: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CubicleCleaningTransaction implements ICubicleCleaningTransaction {
    cleaningDate: moment.Moment;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    doneBy: string | undefined;
    isSampling: boolean;
    tenantId: number | undefined;
    remark: string | undefined;
    cubicleCleaningCheckpoints: CubicleCleaningCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleCleaningTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.typeId = _data["typeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            this.doneBy = _data["doneBy"];
            this.isSampling = _data["isSampling"];
            this.tenantId = _data["tenantId"];
            this.remark = _data["remark"];
            if (Array.isArray(_data["cubicleCleaningCheckpoints"])) {
                this.cubicleCleaningCheckpoints = [] as any;
                for (let item of _data["cubicleCleaningCheckpoints"])
                    this.cubicleCleaningCheckpoints.push(CubicleCleaningCheckpoint.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleCleaningTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleCleaningTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["typeId"] = this.typeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        data["doneBy"] = this.doneBy;
        data["isSampling"] = this.isSampling;
        data["tenantId"] = this.tenantId;
        data["remark"] = this.remark;
        if (Array.isArray(this.cubicleCleaningCheckpoints)) {
            data["cubicleCleaningCheckpoints"] = [];
            for (let item of this.cubicleCleaningCheckpoints)
                data["cubicleCleaningCheckpoints"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleCleaningTransaction {
        const json = this.toJSON();
        let result = new CubicleCleaningTransaction();
        result.init(json);
        return result;
    }
}

export interface ICubicleCleaningTransaction {
    cleaningDate: moment.Moment;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    doneBy: string | undefined;
    isSampling: boolean;
    tenantId: number | undefined;
    remark: string | undefined;
    cubicleCleaningCheckpoints: CubicleCleaningCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CubicleCleaningDailyStatus implements ICubicleCleaningDailyStatus {
    cleaningDate: moment.Moment;
    cubicleId: number;
    statusId: number;
    isSampling: boolean;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleCleaningDailyStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.statusId = _data["statusId"];
            this.isSampling = _data["isSampling"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleCleaningDailyStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleCleaningDailyStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["statusId"] = this.statusId;
        data["isSampling"] = this.isSampling;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleCleaningDailyStatus {
        const json = this.toJSON();
        let result = new CubicleCleaningDailyStatus();
        result.init(json);
        return result;
    }
}

export interface ICubicleCleaningDailyStatus {
    cleaningDate: moment.Moment;
    cubicleId: number;
    statusId: number;
    isSampling: boolean;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class EquipmentAssignment implements IEquipmentAssignment {
    equipmentId: number | undefined;
    cubicleid: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    groupId: string | undefined;
    isSampling: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.cubicleid = _data["cubicleid"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.groupId = _data["groupId"];
            this.isSampling = _data["isSampling"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["cubicleid"] = this.cubicleid;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["groupId"] = this.groupId;
        data["isSampling"] = this.isSampling;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentAssignment {
        const json = this.toJSON();
        let result = new EquipmentAssignment();
        result.init(json);
        return result;
    }
}

export interface IEquipmentAssignment {
    equipmentId: number | undefined;
    cubicleid: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    groupId: string | undefined;
    isSampling: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class LineClearanceCheckpoint implements ILineClearanceCheckpoint {
    lineClearanceTransactionId: number;
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ILineClearanceCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineClearanceTransactionId = _data["lineClearanceTransactionId"];
            this.checkPointId = _data["checkPointId"];
            this.observation = _data["observation"];
            this.remark = _data["remark"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LineClearanceCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new LineClearanceCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineClearanceTransactionId"] = this.lineClearanceTransactionId;
        data["checkPointId"] = this.checkPointId;
        data["observation"] = this.observation;
        data["remark"] = this.remark;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): LineClearanceCheckpoint {
        const json = this.toJSON();
        let result = new LineClearanceCheckpoint();
        result.init(json);
        return result;
    }
}

export interface ILineClearanceCheckpoint {
    lineClearanceTransactionId: number;
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class LineClearanceTransaction implements ILineClearanceTransaction {
    clearanceDate: moment.Moment;
    cubicleId: number;
    groupId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedBy: number | undefined;
    approvedBy: number | undefined;
    tenantId: number | undefined;
    isSampling: boolean;
    approvedTime: moment.Moment | undefined;
    lineClearanceCheckpoints: LineClearanceCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ILineClearanceTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedBy = _data["verifiedBy"];
            this.approvedBy = _data["approvedBy"];
            this.tenantId = _data["tenantId"];
            this.isSampling = _data["isSampling"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(LineClearanceCheckpoint.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LineClearanceTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new LineClearanceTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedBy"] = this.approvedBy;
        data["tenantId"] = this.tenantId;
        data["isSampling"] = this.isSampling;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): LineClearanceTransaction {
        const json = this.toJSON();
        let result = new LineClearanceTransaction();
        result.init(json);
        return result;
    }
}

export interface ILineClearanceTransaction {
    clearanceDate: moment.Moment;
    cubicleId: number;
    groupId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedBy: number | undefined;
    approvedBy: number | undefined;
    tenantId: number | undefined;
    isSampling: boolean;
    approvedTime: moment.Moment | undefined;
    lineClearanceCheckpoints: LineClearanceCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class StageOutDetail implements IStageOutDetail {
    stageOutHeaderId: number;
    sapBatchNo: string | undefined;
    materialContainerBarcode: string | undefined;
    balanceQuantity: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IStageOutDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stageOutHeaderId = _data["stageOutHeaderId"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.materialContainerBarcode = _data["materialContainerBarcode"];
            this.balanceQuantity = _data["balanceQuantity"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StageOutDetail {
        data = typeof data === 'object' ? data : {};
        let result = new StageOutDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stageOutHeaderId"] = this.stageOutHeaderId;
        data["sapBatchNo"] = this.sapBatchNo;
        data["materialContainerBarcode"] = this.materialContainerBarcode;
        data["balanceQuantity"] = this.balanceQuantity;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): StageOutDetail {
        const json = this.toJSON();
        let result = new StageOutDetail();
        result.init(json);
        return result;
    }
}

export interface IStageOutDetail {
    stageOutHeaderId: number;
    sapBatchNo: string | undefined;
    materialContainerBarcode: string | undefined;
    balanceQuantity: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class StageOutHeader implements IStageOutHeader {
    cubicleId: number;
    groupId: string | undefined;
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    statusId: number;
    isSampling: boolean;
    stageOutDetails: StageOutDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IStageOutHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.materialCode = _data["materialCode"];
            this.statusId = _data["statusId"];
            this.isSampling = _data["isSampling"];
            if (Array.isArray(_data["stageOutDetails"])) {
                this.stageOutDetails = [] as any;
                for (let item of _data["stageOutDetails"])
                    this.stageOutDetails.push(StageOutDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StageOutHeader {
        data = typeof data === 'object' ? data : {};
        let result = new StageOutHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["materialCode"] = this.materialCode;
        data["statusId"] = this.statusId;
        data["isSampling"] = this.isSampling;
        if (Array.isArray(this.stageOutDetails)) {
            data["stageOutDetails"] = [];
            for (let item of this.stageOutDetails)
                data["stageOutDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): StageOutHeader {
        const json = this.toJSON();
        let result = new StageOutHeader();
        result.init(json);
        return result;
    }
}

export interface IStageOutHeader {
    cubicleId: number;
    groupId: string | undefined;
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    statusId: number;
    isSampling: boolean;
    stageOutDetails: StageOutDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CubicleMaster implements ICubicleMaster {
    plantId: number;
    cubicleCode: string | undefined;
    areaId: number;
    slocId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    cubicleCleaningTransactions: CubicleCleaningTransaction[] | undefined;
    cubicleCleaningDailyStatuses: CubicleCleaningDailyStatus[] | undefined;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    stageOutHeaders: StageOutHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.cubicleCode = _data["cubicleCode"];
            this.areaId = _data["areaId"];
            this.slocId = _data["slocId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["deviceMasters"])) {
                this.deviceMasters = [] as any;
                for (let item of _data["deviceMasters"])
                    this.deviceMasters.push(DeviceMaster.fromJS(item));
            }
            if (Array.isArray(_data["cubicleCleaningTransactions"])) {
                this.cubicleCleaningTransactions = [] as any;
                for (let item of _data["cubicleCleaningTransactions"])
                    this.cubicleCleaningTransactions.push(CubicleCleaningTransaction.fromJS(item));
            }
            if (Array.isArray(_data["cubicleCleaningDailyStatuses"])) {
                this.cubicleCleaningDailyStatuses = [] as any;
                for (let item of _data["cubicleCleaningDailyStatuses"])
                    this.cubicleCleaningDailyStatuses.push(CubicleCleaningDailyStatus.fromJS(item));
            }
            if (Array.isArray(_data["cubicleAssignmentDetails"])) {
                this.cubicleAssignmentDetails = [] as any;
                for (let item of _data["cubicleAssignmentDetails"])
                    this.cubicleAssignmentDetails.push(CubicleAssignmentDetail.fromJS(item));
            }
            if (Array.isArray(_data["equipmentAssignments"])) {
                this.equipmentAssignments = [] as any;
                for (let item of _data["equipmentAssignments"])
                    this.equipmentAssignments.push(EquipmentAssignment.fromJS(item));
            }
            if (Array.isArray(_data["lineClearanceTransactions"])) {
                this.lineClearanceTransactions = [] as any;
                for (let item of _data["lineClearanceTransactions"])
                    this.lineClearanceTransactions.push(LineClearanceTransaction.fromJS(item));
            }
            if (Array.isArray(_data["stageOutHeaders"])) {
                this.stageOutHeaders = [] as any;
                for (let item of _data["stageOutHeaders"])
                    this.stageOutHeaders.push(StageOutHeader.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleMaster {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["cubicleCode"] = this.cubicleCode;
        data["areaId"] = this.areaId;
        data["slocId"] = this.slocId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.deviceMasters)) {
            data["deviceMasters"] = [];
            for (let item of this.deviceMasters)
                data["deviceMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleCleaningTransactions)) {
            data["cubicleCleaningTransactions"] = [];
            for (let item of this.cubicleCleaningTransactions)
                data["cubicleCleaningTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleCleaningDailyStatuses)) {
            data["cubicleCleaningDailyStatuses"] = [];
            for (let item of this.cubicleCleaningDailyStatuses)
                data["cubicleCleaningDailyStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleAssignmentDetails)) {
            data["cubicleAssignmentDetails"] = [];
            for (let item of this.cubicleAssignmentDetails)
                data["cubicleAssignmentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentAssignments)) {
            data["equipmentAssignments"] = [];
            for (let item of this.equipmentAssignments)
                data["equipmentAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.lineClearanceTransactions)) {
            data["lineClearanceTransactions"] = [];
            for (let item of this.lineClearanceTransactions)
                data["lineClearanceTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.stageOutHeaders)) {
            data["stageOutHeaders"] = [];
            for (let item of this.stageOutHeaders)
                data["stageOutHeaders"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleMaster {
        const json = this.toJSON();
        let result = new CubicleMaster();
        result.init(json);
        return result;
    }
}

export interface ICubicleMaster {
    plantId: number;
    cubicleCode: string | undefined;
    areaId: number;
    slocId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    cubicleCleaningTransactions: CubicleCleaningTransaction[] | undefined;
    cubicleCleaningDailyStatuses: CubicleCleaningDailyStatus[] | undefined;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    stageOutHeaders: StageOutHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class DispensingDetail implements IDispensingDetail {
    dispensingHeaderId: number | undefined;
    sapBatchNumber: string;
    containerMaterialBarcode: string;
    dispenseBarcode: string;
    unitOfMeasurementId: number | undefined;
    noOfPacks: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    weighingMachineId: number | undefined;
    samplingTypeId: number | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    dispensingPrintDetails: DispensingPrintDetail[] | undefined;
    noOfContainers: number;
    containerNo: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IDispensingDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispensingHeaderId = _data["dispensingHeaderId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.containerMaterialBarcode = _data["containerMaterialBarcode"];
            this.dispenseBarcode = _data["dispenseBarcode"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.noOfPacks = _data["noOfPacks"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.grossWeight = _data["grossWeight"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.samplingTypeId = _data["samplingTypeId"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
            this.printed = _data["printed"];
            if (Array.isArray(_data["dispensingPrintDetails"])) {
                this.dispensingPrintDetails = [] as any;
                for (let item of _data["dispensingPrintDetails"])
                    this.dispensingPrintDetails.push(DispensingPrintDetail.fromJS(item));
            }
            this.noOfContainers = _data["noOfContainers"];
            this.containerNo = _data["containerNo"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispensingDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispensingHeaderId"] = this.dispensingHeaderId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["containerMaterialBarcode"] = this.containerMaterialBarcode;
        data["dispenseBarcode"] = this.dispenseBarcode;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["noOfPacks"] = this.noOfPacks;
        data["isGrossWeight"] = this.isGrossWeight;
        data["grossWeight"] = this.grossWeight;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["weighingMachineId"] = this.weighingMachineId;
        data["samplingTypeId"] = this.samplingTypeId;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        data["printed"] = this.printed;
        if (Array.isArray(this.dispensingPrintDetails)) {
            data["dispensingPrintDetails"] = [];
            for (let item of this.dispensingPrintDetails)
                data["dispensingPrintDetails"].push(item.toJSON());
        }
        data["noOfContainers"] = this.noOfContainers;
        data["containerNo"] = this.containerNo;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DispensingDetail {
        const json = this.toJSON();
        let result = new DispensingDetail();
        result.init(json);
        return result;
    }
}

export interface IDispensingDetail {
    dispensingHeaderId: number | undefined;
    sapBatchNumber: string;
    containerMaterialBarcode: string;
    dispenseBarcode: string;
    unitOfMeasurementId: number | undefined;
    noOfPacks: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    weighingMachineId: number | undefined;
    samplingTypeId: number | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    dispensingPrintDetails: DispensingPrintDetail[] | undefined;
    noOfContainers: number;
    containerNo: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class DispensingHeader implements IDispensingHeader {
    rlafId: number;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    materialCodeId: string;
    startTime: moment.Moment;
    endTime: moment.Moment | undefined;
    statusId: number;
    isSampling: boolean;
    checkedBy: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    tenantId: number | undefined;
    dispensingDetails: DispensingDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IDispensingHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rlafId = _data["rlafId"];
            this.processOrderId = _data["processOrderId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.materialCodeId = _data["materialCodeId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isSampling = _data["isSampling"];
            this.checkedBy = _data["checkedBy"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["dispensingDetails"])) {
                this.dispensingDetails = [] as any;
                for (let item of _data["dispensingDetails"])
                    this.dispensingDetails.push(DispensingDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispensingHeader {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rlafId"] = this.rlafId;
        data["processOrderId"] = this.processOrderId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["materialCodeId"] = this.materialCodeId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isSampling"] = this.isSampling;
        data["checkedBy"] = this.checkedBy;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.dispensingDetails)) {
            data["dispensingDetails"] = [];
            for (let item of this.dispensingDetails)
                data["dispensingDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DispensingHeader {
        const json = this.toJSON();
        let result = new DispensingHeader();
        result.init(json);
        return result;
    }
}

export interface IDispensingHeader {
    rlafId: number;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    materialCodeId: string;
    startTime: moment.Moment;
    endTime: moment.Moment | undefined;
    statusId: number;
    isSampling: boolean;
    checkedBy: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    tenantId: number | undefined;
    dispensingDetails: DispensingDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class EquipmentMaster implements IEquipmentMaster {
    plantId: number;
    slocId: number | undefined;
    equipmentTypeId: number | undefined;
    equipmentCode: string | undefined;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    cleanHoldTime: number;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    dispensingHeaders: DispensingHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.slocId = _data["slocId"];
            this.equipmentTypeId = _data["equipmentTypeId"];
            this.equipmentCode = _data["equipmentCode"];
            this.name = _data["name"];
            this.alias = _data["alias"];
            this.equipmentModel = _data["equipmentModel"];
            this.description = _data["description"];
            this.isPortable = _data["isPortable"];
            this.dateOfProcurement = _data["dateOfProcurement"] ? moment(_data["dateOfProcurement"].toString()) : <any>undefined;
            this.dateOfInstallation = _data["dateOfInstallation"] ? moment(_data["dateOfInstallation"].toString()) : <any>undefined;
            this.isMaintenanceRequired = _data["isMaintenanceRequired"];
            this.maintenanceScheduleDays = _data["maintenanceScheduleDays"];
            this.communicationType = _data["communicationType"];
            this.vendorName = _data["vendorName"];
            this.vendorDocumentNumber = _data["vendorDocumentNumber"];
            this.supportExpiresOn = _data["supportExpiresOn"] ? moment(_data["supportExpiresOn"].toString()) : <any>undefined;
            this.networkIPAddress = _data["networkIPAddress"];
            this.networkIPPort = _data["networkIPPort"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
            this.cleanHoldTime = _data["cleanHoldTime"];
            if (Array.isArray(_data["equipmentAssignments"])) {
                this.equipmentAssignments = [] as any;
                for (let item of _data["equipmentAssignments"])
                    this.equipmentAssignments.push(EquipmentAssignment.fromJS(item));
            }
            if (Array.isArray(_data["dispensingHeaders"])) {
                this.dispensingHeaders = [] as any;
                for (let item of _data["dispensingHeaders"])
                    this.dispensingHeaders.push(DispensingHeader.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentMaster {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["slocId"] = this.slocId;
        data["equipmentTypeId"] = this.equipmentTypeId;
        data["equipmentCode"] = this.equipmentCode;
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["equipmentModel"] = this.equipmentModel;
        data["description"] = this.description;
        data["isPortable"] = this.isPortable;
        data["dateOfProcurement"] = this.dateOfProcurement ? this.dateOfProcurement.toISOString() : <any>undefined;
        data["dateOfInstallation"] = this.dateOfInstallation ? this.dateOfInstallation.toISOString() : <any>undefined;
        data["isMaintenanceRequired"] = this.isMaintenanceRequired;
        data["maintenanceScheduleDays"] = this.maintenanceScheduleDays;
        data["communicationType"] = this.communicationType;
        data["vendorName"] = this.vendorName;
        data["vendorDocumentNumber"] = this.vendorDocumentNumber;
        data["supportExpiresOn"] = this.supportExpiresOn ? this.supportExpiresOn.toISOString() : <any>undefined;
        data["networkIPAddress"] = this.networkIPAddress;
        data["networkIPPort"] = this.networkIPPort;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        data["cleanHoldTime"] = this.cleanHoldTime;
        if (Array.isArray(this.equipmentAssignments)) {
            data["equipmentAssignments"] = [];
            for (let item of this.equipmentAssignments)
                data["equipmentAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.dispensingHeaders)) {
            data["dispensingHeaders"] = [];
            for (let item of this.dispensingHeaders)
                data["dispensingHeaders"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentMaster {
        const json = this.toJSON();
        let result = new EquipmentMaster();
        result.init(json);
        return result;
    }
}

export interface IEquipmentMaster {
    plantId: number;
    slocId: number | undefined;
    equipmentTypeId: number | undefined;
    equipmentCode: string | undefined;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    cleanHoldTime: number;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    dispensingHeaders: DispensingHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class Palletization implements IPalletization {
    palletId: number | undefined;
    materialId: number | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    transactionId: string;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerBarCode: string | undefined;
    isUnloaded: boolean;
    tenantId: number | undefined;
    productBatchNo: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IPalletization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.grnDetailId = _data["grnDetailId"];
            this.containerId = _data["containerId"];
            this.transactionId = _data["transactionId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.containerNo = _data["containerNo"];
            this.containerBarCode = _data["containerBarCode"];
            this.isUnloaded = _data["isUnloaded"];
            this.tenantId = _data["tenantId"];
            this.productBatchNo = _data["productBatchNo"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Palletization {
        data = typeof data === 'object' ? data : {};
        let result = new Palletization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["grnDetailId"] = this.grnDetailId;
        data["containerId"] = this.containerId;
        data["transactionId"] = this.transactionId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["containerNo"] = this.containerNo;
        data["containerBarCode"] = this.containerBarCode;
        data["isUnloaded"] = this.isUnloaded;
        data["tenantId"] = this.tenantId;
        data["productBatchNo"] = this.productBatchNo;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): Palletization {
        const json = this.toJSON();
        let result = new Palletization();
        result.init(json);
        return result;
    }
}

export interface IPalletization {
    palletId: number | undefined;
    materialId: number | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    transactionId: string;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerBarCode: string | undefined;
    isUnloaded: boolean;
    tenantId: number | undefined;
    productBatchNo: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class HandlingUnitMaster implements IHandlingUnitMaster {
    plantId: number;
    huCode: string | undefined;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IHandlingUnitMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.handlingUnitTypeId = _data["handlingUnitTypeId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["palletizations"])) {
                this.palletizations = [] as any;
                for (let item of _data["palletizations"])
                    this.palletizations.push(Palletization.fromJS(item));
            }
            if (Array.isArray(_data["putAwayBinToBinTransfers"])) {
                this.putAwayBinToBinTransfers = [] as any;
                for (let item of _data["putAwayBinToBinTransfers"])
                    this.putAwayBinToBinTransfers.push(PutAwayBinToBinTransfer.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HandlingUnitMaster {
        data = typeof data === 'object' ? data : {};
        let result = new HandlingUnitMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["handlingUnitTypeId"] = this.handlingUnitTypeId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.palletizations)) {
            data["palletizations"] = [];
            for (let item of this.palletizations)
                data["palletizations"].push(item.toJSON());
        }
        if (Array.isArray(this.putAwayBinToBinTransfers)) {
            data["putAwayBinToBinTransfers"] = [];
            for (let item of this.putAwayBinToBinTransfers)
                data["putAwayBinToBinTransfers"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): HandlingUnitMaster {
        const json = this.toJSON();
        let result = new HandlingUnitMaster();
        result.init(json);
        return result;
    }
}

export interface IHandlingUnitMaster {
    plantId: number;
    huCode: string | undefined;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationDetailWeight implements IWMCalibrationDetailWeight {
    keyTypeId: number | undefined;
    capturedWeightKeyTypeId: number | undefined;
    wmCalibrationDetailId: number | undefined;
    wmCalibrationEccentricityTestId: number | undefined;
    wmCalibrationLinearityTestId: number | undefined;
    wmCalibrationRepeatabilityTestId: number | undefined;
    standardWeightId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationDetailWeight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyTypeId = _data["keyTypeId"];
            this.capturedWeightKeyTypeId = _data["capturedWeightKeyTypeId"];
            this.wmCalibrationDetailId = _data["wmCalibrationDetailId"];
            this.wmCalibrationEccentricityTestId = _data["wmCalibrationEccentricityTestId"];
            this.wmCalibrationLinearityTestId = _data["wmCalibrationLinearityTestId"];
            this.wmCalibrationRepeatabilityTestId = _data["wmCalibrationRepeatabilityTestId"];
            this.standardWeightId = _data["standardWeightId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationDetailWeight {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationDetailWeight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyTypeId"] = this.keyTypeId;
        data["capturedWeightKeyTypeId"] = this.capturedWeightKeyTypeId;
        data["wmCalibrationDetailId"] = this.wmCalibrationDetailId;
        data["wmCalibrationEccentricityTestId"] = this.wmCalibrationEccentricityTestId;
        data["wmCalibrationLinearityTestId"] = this.wmCalibrationLinearityTestId;
        data["wmCalibrationRepeatabilityTestId"] = this.wmCalibrationRepeatabilityTestId;
        data["standardWeightId"] = this.standardWeightId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationDetailWeight {
        const json = this.toJSON();
        let result = new WMCalibrationDetailWeight();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationDetailWeight {
    keyTypeId: number | undefined;
    capturedWeightKeyTypeId: number | undefined;
    wmCalibrationDetailId: number | undefined;
    wmCalibrationEccentricityTestId: number | undefined;
    wmCalibrationLinearityTestId: number | undefined;
    wmCalibrationRepeatabilityTestId: number | undefined;
    standardWeightId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class StandardWeightMaster implements IStandardWeightMaster {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightBoxMasterId: number | undefined;
    unitOfMeasurementId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IStandardWeightMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.standardWeightBoxMasterId = _data["standardWeightBoxMasterId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            if (Array.isArray(_data["wmCalibrationDetailWeights"])) {
                this.wmCalibrationDetailWeights = [] as any;
                for (let item of _data["wmCalibrationDetailWeights"])
                    this.wmCalibrationDetailWeights.push(WMCalibrationDetailWeight.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightMaster {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["standardWeightBoxMasterId"] = this.standardWeightBoxMasterId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        if (Array.isArray(this.wmCalibrationDetailWeights)) {
            data["wmCalibrationDetailWeights"] = [];
            for (let item of this.wmCalibrationDetailWeights)
                data["wmCalibrationDetailWeights"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightMaster {
        const json = this.toJSON();
        let result = new StandardWeightMaster();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightMaster {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightBoxMasterId: number | undefined;
    unitOfMeasurementId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationDetail implements IWMCalibrationDetail {
    wmCalibrationHeaderId: number | undefined;
    calibrationLevelId: number | undefined;
    standardWeightBoxId: number | undefined;
    capturedWeight: number;
    remark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    calibrationStatusId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.calibrationLevelId = _data["calibrationLevelId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.capturedWeight = _data["capturedWeight"];
            this.remark = _data["remark"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.calibrationStatusId = _data["calibrationStatusId"];
            if (Array.isArray(_data["wmCalibrationDetailWeights"])) {
                this.wmCalibrationDetailWeights = [] as any;
                for (let item of _data["wmCalibrationDetailWeights"])
                    this.wmCalibrationDetailWeights.push(WMCalibrationDetailWeight.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationDetail {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["calibrationLevelId"] = this.calibrationLevelId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["capturedWeight"] = this.capturedWeight;
        data["remark"] = this.remark;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["calibrationStatusId"] = this.calibrationStatusId;
        if (Array.isArray(this.wmCalibrationDetailWeights)) {
            data["wmCalibrationDetailWeights"] = [];
            for (let item of this.wmCalibrationDetailWeights)
                data["wmCalibrationDetailWeights"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationDetail {
        const json = this.toJSON();
        let result = new WMCalibrationDetail();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationDetail {
    wmCalibrationHeaderId: number | undefined;
    calibrationLevelId: number | undefined;
    standardWeightBoxId: number | undefined;
    capturedWeight: number;
    remark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    calibrationStatusId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationEccentricityTest implements IWMCalibrationEccentricityTest {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    initialZeroReading: string | undefined;
    cValue: number;
    lfValue: number;
    rfValue: number;
    lbValue: number;
    rbValue: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    cValueStandardWeightBoxId: number | undefined;
    lfValueStandardWeightBoxId: number | undefined;
    rfValueStandardWeightBoxId: number | undefined;
    lbValueStandardWeightBoxId: number | undefined;
    rbValueStandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationEccentricityTest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.calculatedCapacityWeight = _data["calculatedCapacityWeight"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.cValue = _data["cValue"];
            this.lfValue = _data["lfValue"];
            this.rfValue = _data["rfValue"];
            this.lbValue = _data["lbValue"];
            this.rbValue = _data["rbValue"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.cValueStandardWeightBoxId = _data["cValueStandardWeightBoxId"];
            this.lfValueStandardWeightBoxId = _data["lfValueStandardWeightBoxId"];
            this.rfValueStandardWeightBoxId = _data["rfValueStandardWeightBoxId"];
            this.lbValueStandardWeightBoxId = _data["lbValueStandardWeightBoxId"];
            this.rbValueStandardWeightBoxId = _data["rbValueStandardWeightBoxId"];
            this.meanValue = _data["meanValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            if (Array.isArray(_data["wmCalibrationDetailWeights"])) {
                this.wmCalibrationDetailWeights = [] as any;
                for (let item of _data["wmCalibrationDetailWeights"])
                    this.wmCalibrationDetailWeights.push(WMCalibrationDetailWeight.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationEccentricityTest {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationEccentricityTest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["calculatedCapacityWeight"] = this.calculatedCapacityWeight;
        data["initialZeroReading"] = this.initialZeroReading;
        data["cValue"] = this.cValue;
        data["lfValue"] = this.lfValue;
        data["rfValue"] = this.rfValue;
        data["lbValue"] = this.lbValue;
        data["rbValue"] = this.rbValue;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["cValueStandardWeightBoxId"] = this.cValueStandardWeightBoxId;
        data["lfValueStandardWeightBoxId"] = this.lfValueStandardWeightBoxId;
        data["rfValueStandardWeightBoxId"] = this.rfValueStandardWeightBoxId;
        data["lbValueStandardWeightBoxId"] = this.lbValueStandardWeightBoxId;
        data["rbValueStandardWeightBoxId"] = this.rbValueStandardWeightBoxId;
        data["meanValue"] = this.meanValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        if (Array.isArray(this.wmCalibrationDetailWeights)) {
            data["wmCalibrationDetailWeights"] = [];
            for (let item of this.wmCalibrationDetailWeights)
                data["wmCalibrationDetailWeights"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationEccentricityTest {
        const json = this.toJSON();
        let result = new WMCalibrationEccentricityTest();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationEccentricityTest {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    initialZeroReading: string | undefined;
    cValue: number;
    lfValue: number;
    rfValue: number;
    lbValue: number;
    rbValue: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    cValueStandardWeightBoxId: number | undefined;
    lfValueStandardWeightBoxId: number | undefined;
    rfValueStandardWeightBoxId: number | undefined;
    lbValueStandardWeightBoxId: number | undefined;
    rbValueStandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationLinearityTest implements IWMCalibrationLinearityTest {
    wmCalibrationHeaderId: number | undefined;
    initialZeroReading: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationLinearityTest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.weightValue1 = _data["weightValue1"];
            this.weightValue2 = _data["weightValue2"];
            this.weightValue3 = _data["weightValue3"];
            this.weightValue4 = _data["weightValue4"];
            this.weightValue5 = _data["weightValue5"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weightValue1StandardWeightBoxId = _data["weightValue1StandardWeightBoxId"];
            this.weightValue2StandardWeightBoxId = _data["weightValue2StandardWeightBoxId"];
            this.weightValue3StandardWeightBoxId = _data["weightValue3StandardWeightBoxId"];
            this.weightValue4StandardWeightBoxId = _data["weightValue4StandardWeightBoxId"];
            this.weightValue5StandardWeightBoxId = _data["weightValue5StandardWeightBoxId"];
            this.meanValue = _data["meanValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            if (Array.isArray(_data["wmCalibrationDetailWeights"])) {
                this.wmCalibrationDetailWeights = [] as any;
                for (let item of _data["wmCalibrationDetailWeights"])
                    this.wmCalibrationDetailWeights.push(WMCalibrationDetailWeight.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationLinearityTest {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationLinearityTest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["initialZeroReading"] = this.initialZeroReading;
        data["weightValue1"] = this.weightValue1;
        data["weightValue2"] = this.weightValue2;
        data["weightValue3"] = this.weightValue3;
        data["weightValue4"] = this.weightValue4;
        data["weightValue5"] = this.weightValue5;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weightValue1StandardWeightBoxId"] = this.weightValue1StandardWeightBoxId;
        data["weightValue2StandardWeightBoxId"] = this.weightValue2StandardWeightBoxId;
        data["weightValue3StandardWeightBoxId"] = this.weightValue3StandardWeightBoxId;
        data["weightValue4StandardWeightBoxId"] = this.weightValue4StandardWeightBoxId;
        data["weightValue5StandardWeightBoxId"] = this.weightValue5StandardWeightBoxId;
        data["meanValue"] = this.meanValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        if (Array.isArray(this.wmCalibrationDetailWeights)) {
            data["wmCalibrationDetailWeights"] = [];
            for (let item of this.wmCalibrationDetailWeights)
                data["wmCalibrationDetailWeights"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationLinearityTest {
        const json = this.toJSON();
        let result = new WMCalibrationLinearityTest();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationLinearityTest {
    wmCalibrationHeaderId: number | undefined;
    initialZeroReading: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationRepeatabilityTest implements IWMCalibrationRepeatabilityTest {
    wmCalibrationHeaderId: number | undefined;
    initialZeroReading: string | undefined;
    calculatedCapacityWeight: number;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    weightValue6: number;
    weightValue7: number;
    weightValue8: number;
    weightValue9: number;
    weightValue10: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    weightValue6StandardWeightBoxId: number | undefined;
    weightValue7StandardWeightBoxId: number | undefined;
    weightValue8StandardWeightBoxId: number | undefined;
    weightValue9StandardWeightBoxId: number | undefined;
    weightValue10StandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationRepeatabilityTest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.calculatedCapacityWeight = _data["calculatedCapacityWeight"];
            this.weightValue1 = _data["weightValue1"];
            this.weightValue2 = _data["weightValue2"];
            this.weightValue3 = _data["weightValue3"];
            this.weightValue4 = _data["weightValue4"];
            this.weightValue5 = _data["weightValue5"];
            this.weightValue6 = _data["weightValue6"];
            this.weightValue7 = _data["weightValue7"];
            this.weightValue8 = _data["weightValue8"];
            this.weightValue9 = _data["weightValue9"];
            this.weightValue10 = _data["weightValue10"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weightValue1StandardWeightBoxId = _data["weightValue1StandardWeightBoxId"];
            this.weightValue2StandardWeightBoxId = _data["weightValue2StandardWeightBoxId"];
            this.weightValue3StandardWeightBoxId = _data["weightValue3StandardWeightBoxId"];
            this.weightValue4StandardWeightBoxId = _data["weightValue4StandardWeightBoxId"];
            this.weightValue5StandardWeightBoxId = _data["weightValue5StandardWeightBoxId"];
            this.weightValue6StandardWeightBoxId = _data["weightValue6StandardWeightBoxId"];
            this.weightValue7StandardWeightBoxId = _data["weightValue7StandardWeightBoxId"];
            this.weightValue8StandardWeightBoxId = _data["weightValue8StandardWeightBoxId"];
            this.weightValue9StandardWeightBoxId = _data["weightValue9StandardWeightBoxId"];
            this.weightValue10StandardWeightBoxId = _data["weightValue10StandardWeightBoxId"];
            this.meanValue = _data["meanValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            if (Array.isArray(_data["wmCalibrationDetailWeights"])) {
                this.wmCalibrationDetailWeights = [] as any;
                for (let item of _data["wmCalibrationDetailWeights"])
                    this.wmCalibrationDetailWeights.push(WMCalibrationDetailWeight.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationRepeatabilityTest {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationRepeatabilityTest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["initialZeroReading"] = this.initialZeroReading;
        data["calculatedCapacityWeight"] = this.calculatedCapacityWeight;
        data["weightValue1"] = this.weightValue1;
        data["weightValue2"] = this.weightValue2;
        data["weightValue3"] = this.weightValue3;
        data["weightValue4"] = this.weightValue4;
        data["weightValue5"] = this.weightValue5;
        data["weightValue6"] = this.weightValue6;
        data["weightValue7"] = this.weightValue7;
        data["weightValue8"] = this.weightValue8;
        data["weightValue9"] = this.weightValue9;
        data["weightValue10"] = this.weightValue10;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weightValue1StandardWeightBoxId"] = this.weightValue1StandardWeightBoxId;
        data["weightValue2StandardWeightBoxId"] = this.weightValue2StandardWeightBoxId;
        data["weightValue3StandardWeightBoxId"] = this.weightValue3StandardWeightBoxId;
        data["weightValue4StandardWeightBoxId"] = this.weightValue4StandardWeightBoxId;
        data["weightValue5StandardWeightBoxId"] = this.weightValue5StandardWeightBoxId;
        data["weightValue6StandardWeightBoxId"] = this.weightValue6StandardWeightBoxId;
        data["weightValue7StandardWeightBoxId"] = this.weightValue7StandardWeightBoxId;
        data["weightValue8StandardWeightBoxId"] = this.weightValue8StandardWeightBoxId;
        data["weightValue9StandardWeightBoxId"] = this.weightValue9StandardWeightBoxId;
        data["weightValue10StandardWeightBoxId"] = this.weightValue10StandardWeightBoxId;
        data["meanValue"] = this.meanValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        if (Array.isArray(this.wmCalibrationDetailWeights)) {
            data["wmCalibrationDetailWeights"] = [];
            for (let item of this.wmCalibrationDetailWeights)
                data["wmCalibrationDetailWeights"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationRepeatabilityTest {
        const json = this.toJSON();
        let result = new WMCalibrationRepeatabilityTest();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationRepeatabilityTest {
    wmCalibrationHeaderId: number | undefined;
    initialZeroReading: string | undefined;
    calculatedCapacityWeight: number;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    weightValue6: number;
    weightValue7: number;
    weightValue8: number;
    weightValue9: number;
    weightValue10: number;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    weightValue6StandardWeightBoxId: number | undefined;
    weightValue7StandardWeightBoxId: number | undefined;
    weightValue8StandardWeightBoxId: number | undefined;
    weightValue9StandardWeightBoxId: number | undefined;
    weightValue10StandardWeightBoxId: number | undefined;
    meanValue: number;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    wmCalibrationDetailWeights: WMCalibrationDetailWeight[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class StandardWeightBoxMaster implements IStandardWeightBoxMaster {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    wmcValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmlfValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmrfValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmlbValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmrbValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmWeightValue1CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue2CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue3CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue4CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue5CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue1CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue2CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue3CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue4CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue5CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue6CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue7CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue8CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue9CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue10CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IStandardWeightBoxMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["standardWeightMasters"])) {
                this.standardWeightMasters = [] as any;
                for (let item of _data["standardWeightMasters"])
                    this.standardWeightMasters.push(StandardWeightMaster.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationDetails"])) {
                this.wmCalibrationDetails = [] as any;
                for (let item of _data["wmCalibrationDetails"])
                    this.wmCalibrationDetails.push(WMCalibrationDetail.fromJS(item));
            }
            if (Array.isArray(_data["wmcValueCalibrationEccentricityTests"])) {
                this.wmcValueCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmcValueCalibrationEccentricityTests"])
                    this.wmcValueCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmlfValueCalibrationEccentricityTests"])) {
                this.wmlfValueCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmlfValueCalibrationEccentricityTests"])
                    this.wmlfValueCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmrfValueCalibrationEccentricityTests"])) {
                this.wmrfValueCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmrfValueCalibrationEccentricityTests"])
                    this.wmrfValueCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmlbValueCalibrationEccentricityTests"])) {
                this.wmlbValueCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmlbValueCalibrationEccentricityTests"])
                    this.wmlbValueCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmrbValueCalibrationEccentricityTests"])) {
                this.wmrbValueCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmrbValueCalibrationEccentricityTests"])
                    this.wmrbValueCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue1CalibrationLinearityTests"])) {
                this.wmWeightValue1CalibrationLinearityTests = [] as any;
                for (let item of _data["wmWeightValue1CalibrationLinearityTests"])
                    this.wmWeightValue1CalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue2CalibrationLinearityTests"])) {
                this.wmWeightValue2CalibrationLinearityTests = [] as any;
                for (let item of _data["wmWeightValue2CalibrationLinearityTests"])
                    this.wmWeightValue2CalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue3CalibrationLinearityTests"])) {
                this.wmWeightValue3CalibrationLinearityTests = [] as any;
                for (let item of _data["wmWeightValue3CalibrationLinearityTests"])
                    this.wmWeightValue3CalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue4CalibrationLinearityTests"])) {
                this.wmWeightValue4CalibrationLinearityTests = [] as any;
                for (let item of _data["wmWeightValue4CalibrationLinearityTests"])
                    this.wmWeightValue4CalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue5CalibrationLinearityTests"])) {
                this.wmWeightValue5CalibrationLinearityTests = [] as any;
                for (let item of _data["wmWeightValue5CalibrationLinearityTests"])
                    this.wmWeightValue5CalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue1CalibrationRepeatabilityTests"])) {
                this.wmWeightValue1CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue1CalibrationRepeatabilityTests"])
                    this.wmWeightValue1CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue2CalibrationRepeatabilityTests"])) {
                this.wmWeightValue2CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue2CalibrationRepeatabilityTests"])
                    this.wmWeightValue2CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue3CalibrationRepeatabilityTests"])) {
                this.wmWeightValue3CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue3CalibrationRepeatabilityTests"])
                    this.wmWeightValue3CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue4CalibrationRepeatabilityTests"])) {
                this.wmWeightValue4CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue4CalibrationRepeatabilityTests"])
                    this.wmWeightValue4CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue5CalibrationRepeatabilityTests"])) {
                this.wmWeightValue5CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue5CalibrationRepeatabilityTests"])
                    this.wmWeightValue5CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue6CalibrationRepeatabilityTests"])) {
                this.wmWeightValue6CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue6CalibrationRepeatabilityTests"])
                    this.wmWeightValue6CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue7CalibrationRepeatabilityTests"])) {
                this.wmWeightValue7CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue7CalibrationRepeatabilityTests"])
                    this.wmWeightValue7CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue8CalibrationRepeatabilityTests"])) {
                this.wmWeightValue8CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue8CalibrationRepeatabilityTests"])
                    this.wmWeightValue8CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue9CalibrationRepeatabilityTests"])) {
                this.wmWeightValue9CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue9CalibrationRepeatabilityTests"])
                    this.wmWeightValue9CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmWeightValue10CalibrationRepeatabilityTests"])) {
                this.wmWeightValue10CalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmWeightValue10CalibrationRepeatabilityTests"])
                    this.wmWeightValue10CalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightBoxMaster {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightBoxMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.standardWeightMasters)) {
            data["standardWeightMasters"] = [];
            for (let item of this.standardWeightMasters)
                data["standardWeightMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationDetails)) {
            data["wmCalibrationDetails"] = [];
            for (let item of this.wmCalibrationDetails)
                data["wmCalibrationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.wmcValueCalibrationEccentricityTests)) {
            data["wmcValueCalibrationEccentricityTests"] = [];
            for (let item of this.wmcValueCalibrationEccentricityTests)
                data["wmcValueCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmlfValueCalibrationEccentricityTests)) {
            data["wmlfValueCalibrationEccentricityTests"] = [];
            for (let item of this.wmlfValueCalibrationEccentricityTests)
                data["wmlfValueCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmrfValueCalibrationEccentricityTests)) {
            data["wmrfValueCalibrationEccentricityTests"] = [];
            for (let item of this.wmrfValueCalibrationEccentricityTests)
                data["wmrfValueCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmlbValueCalibrationEccentricityTests)) {
            data["wmlbValueCalibrationEccentricityTests"] = [];
            for (let item of this.wmlbValueCalibrationEccentricityTests)
                data["wmlbValueCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmrbValueCalibrationEccentricityTests)) {
            data["wmrbValueCalibrationEccentricityTests"] = [];
            for (let item of this.wmrbValueCalibrationEccentricityTests)
                data["wmrbValueCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue1CalibrationLinearityTests)) {
            data["wmWeightValue1CalibrationLinearityTests"] = [];
            for (let item of this.wmWeightValue1CalibrationLinearityTests)
                data["wmWeightValue1CalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue2CalibrationLinearityTests)) {
            data["wmWeightValue2CalibrationLinearityTests"] = [];
            for (let item of this.wmWeightValue2CalibrationLinearityTests)
                data["wmWeightValue2CalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue3CalibrationLinearityTests)) {
            data["wmWeightValue3CalibrationLinearityTests"] = [];
            for (let item of this.wmWeightValue3CalibrationLinearityTests)
                data["wmWeightValue3CalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue4CalibrationLinearityTests)) {
            data["wmWeightValue4CalibrationLinearityTests"] = [];
            for (let item of this.wmWeightValue4CalibrationLinearityTests)
                data["wmWeightValue4CalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue5CalibrationLinearityTests)) {
            data["wmWeightValue5CalibrationLinearityTests"] = [];
            for (let item of this.wmWeightValue5CalibrationLinearityTests)
                data["wmWeightValue5CalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue1CalibrationRepeatabilityTests)) {
            data["wmWeightValue1CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue1CalibrationRepeatabilityTests)
                data["wmWeightValue1CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue2CalibrationRepeatabilityTests)) {
            data["wmWeightValue2CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue2CalibrationRepeatabilityTests)
                data["wmWeightValue2CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue3CalibrationRepeatabilityTests)) {
            data["wmWeightValue3CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue3CalibrationRepeatabilityTests)
                data["wmWeightValue3CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue4CalibrationRepeatabilityTests)) {
            data["wmWeightValue4CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue4CalibrationRepeatabilityTests)
                data["wmWeightValue4CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue5CalibrationRepeatabilityTests)) {
            data["wmWeightValue5CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue5CalibrationRepeatabilityTests)
                data["wmWeightValue5CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue6CalibrationRepeatabilityTests)) {
            data["wmWeightValue6CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue6CalibrationRepeatabilityTests)
                data["wmWeightValue6CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue7CalibrationRepeatabilityTests)) {
            data["wmWeightValue7CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue7CalibrationRepeatabilityTests)
                data["wmWeightValue7CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue8CalibrationRepeatabilityTests)) {
            data["wmWeightValue8CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue8CalibrationRepeatabilityTests)
                data["wmWeightValue8CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue9CalibrationRepeatabilityTests)) {
            data["wmWeightValue9CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue9CalibrationRepeatabilityTests)
                data["wmWeightValue9CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmWeightValue10CalibrationRepeatabilityTests)) {
            data["wmWeightValue10CalibrationRepeatabilityTests"] = [];
            for (let item of this.wmWeightValue10CalibrationRepeatabilityTests)
                data["wmWeightValue10CalibrationRepeatabilityTests"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightBoxMaster {
        const json = this.toJSON();
        let result = new StandardWeightBoxMaster();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightBoxMaster {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    wmcValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmlfValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmrfValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmlbValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmrbValueCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmWeightValue1CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue2CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue3CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue4CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue5CalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmWeightValue1CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue2CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue3CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue4CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue5CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue6CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue7CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue8CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue9CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmWeightValue10CalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class AreaMaster implements IAreaMaster {
    subPlantId: number;
    departmentId: number;
    areaCode: string;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;
    tenantId: number | undefined;
    locationMasters: LocationMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IAreaMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentId = _data["departmentId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.zone = _data["zone"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["locationMasters"])) {
                this.locationMasters = [] as any;
                for (let item of _data["locationMasters"])
                    this.locationMasters.push(LocationMaster.fromJS(item));
            }
            if (Array.isArray(_data["cubicleMasters"])) {
                this.cubicleMasters = [] as any;
                for (let item of _data["cubicleMasters"])
                    this.cubicleMasters.push(CubicleMaster.fromJS(item));
            }
            if (Array.isArray(_data["standardWeightBoxMasters"])) {
                this.standardWeightBoxMasters = [] as any;
                for (let item of _data["standardWeightBoxMasters"])
                    this.standardWeightBoxMasters.push(StandardWeightBoxMaster.fromJS(item));
            }
            if (Array.isArray(_data["standardWeightMasters"])) {
                this.standardWeightMasters = [] as any;
                for (let item of _data["standardWeightMasters"])
                    this.standardWeightMasters.push(StandardWeightMaster.fromJS(item));
            }
            if (Array.isArray(_data["deviceMasters"])) {
                this.deviceMasters = [] as any;
                for (let item of _data["deviceMasters"])
                    this.deviceMasters.push(DeviceMaster.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaMaster {
        data = typeof data === 'object' ? data : {};
        let result = new AreaMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentId"] = this.departmentId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["zone"] = this.zone;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.locationMasters)) {
            data["locationMasters"] = [];
            for (let item of this.locationMasters)
                data["locationMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleMasters)) {
            data["cubicleMasters"] = [];
            for (let item of this.cubicleMasters)
                data["cubicleMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.standardWeightBoxMasters)) {
            data["standardWeightBoxMasters"] = [];
            for (let item of this.standardWeightBoxMasters)
                data["standardWeightBoxMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.standardWeightMasters)) {
            data["standardWeightMasters"] = [];
            for (let item of this.standardWeightMasters)
                data["standardWeightMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.deviceMasters)) {
            data["deviceMasters"] = [];
            for (let item of this.deviceMasters)
                data["deviceMasters"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaMaster {
        const json = this.toJSON();
        let result = new AreaMaster();
        result.init(json);
        return result;
    }
}

export interface IAreaMaster {
    subPlantId: number;
    departmentId: number;
    areaCode: string;
    areaName: string;
    isActive: boolean;
    description: string | undefined;
    zone: string | undefined;
    tenantId: number | undefined;
    locationMasters: LocationMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class DepartmentMaster implements IDepartmentMaster {
    subPlantId: number;
    departmentCode: string;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    areaMasters: AreaMaster[] | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    equipmentMasters: EquipmentMaster[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IDepartmentMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentCode = _data["departmentCode"];
            this.departmentName = _data["departmentName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["standardWeightBoxMasters"])) {
                this.standardWeightBoxMasters = [] as any;
                for (let item of _data["standardWeightBoxMasters"])
                    this.standardWeightBoxMasters.push(StandardWeightBoxMaster.fromJS(item));
            }
            if (Array.isArray(_data["standardWeightMasters"])) {
                this.standardWeightMasters = [] as any;
                for (let item of _data["standardWeightMasters"])
                    this.standardWeightMasters.push(StandardWeightMaster.fromJS(item));
            }
            if (Array.isArray(_data["areaMasters"])) {
                this.areaMasters = [] as any;
                for (let item of _data["areaMasters"])
                    this.areaMasters.push(AreaMaster.fromJS(item));
            }
            if (Array.isArray(_data["deviceMasters"])) {
                this.deviceMasters = [] as any;
                for (let item of _data["deviceMasters"])
                    this.deviceMasters.push(DeviceMaster.fromJS(item));
            }
            if (Array.isArray(_data["cubicleMasters"])) {
                this.cubicleMasters = [] as any;
                for (let item of _data["cubicleMasters"])
                    this.cubicleMasters.push(CubicleMaster.fromJS(item));
            }
            if (Array.isArray(_data["equipmentMasters"])) {
                this.equipmentMasters = [] as any;
                for (let item of _data["equipmentMasters"])
                    this.equipmentMasters.push(EquipmentMaster.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DepartmentMaster {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentCode"] = this.departmentCode;
        data["departmentName"] = this.departmentName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.standardWeightBoxMasters)) {
            data["standardWeightBoxMasters"] = [];
            for (let item of this.standardWeightBoxMasters)
                data["standardWeightBoxMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.standardWeightMasters)) {
            data["standardWeightMasters"] = [];
            for (let item of this.standardWeightMasters)
                data["standardWeightMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.areaMasters)) {
            data["areaMasters"] = [];
            for (let item of this.areaMasters)
                data["areaMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.deviceMasters)) {
            data["deviceMasters"] = [];
            for (let item of this.deviceMasters)
                data["deviceMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleMasters)) {
            data["cubicleMasters"] = [];
            for (let item of this.cubicleMasters)
                data["cubicleMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentMasters)) {
            data["equipmentMasters"] = [];
            for (let item of this.equipmentMasters)
                data["equipmentMasters"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DepartmentMaster {
        const json = this.toJSON();
        let result = new DepartmentMaster();
        result.init(json);
        return result;
    }
}

export interface IDepartmentMaster {
    subPlantId: number;
    departmentCode: string;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;
    tenantId: number | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    areaMasters: AreaMaster[] | undefined;
    deviceMasters: DeviceMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    equipmentMasters: EquipmentMaster[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CalibrationFrequencyMaster implements ICalibrationFrequencyMaster {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    tenantId: number | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICalibrationFrequencyMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.calibrationLevel = _data["calibrationLevel"];
            this.calibrationCriteria = _data["calibrationCriteria"];
            this.standardWeightValue = _data["standardWeightValue"];
            this.minimumValue = _data["minimumValue"];
            this.maximumValue = _data["maximumValue"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["wmCalibrationDetails"])) {
                this.wmCalibrationDetails = [] as any;
                for (let item of _data["wmCalibrationDetails"])
                    this.wmCalibrationDetails.push(WMCalibrationDetail.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CalibrationFrequencyMaster {
        data = typeof data === 'object' ? data : {};
        let result = new CalibrationFrequencyMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["calibrationLevel"] = this.calibrationLevel;
        data["calibrationCriteria"] = this.calibrationCriteria;
        data["standardWeightValue"] = this.standardWeightValue;
        data["minimumValue"] = this.minimumValue;
        data["maximumValue"] = this.maximumValue;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.wmCalibrationDetails)) {
            data["wmCalibrationDetails"] = [];
            for (let item of this.wmCalibrationDetails)
                data["wmCalibrationDetails"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CalibrationFrequencyMaster {
        const json = this.toJSON();
        let result = new CalibrationFrequencyMaster();
        result.init(json);
        return result;
    }
}

export interface ICalibrationFrequencyMaster {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    tenantId: number | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WeightCaptureDetail implements IWeightCaptureDetail {
    weightCaptureHeaderId: number;
    tenantId: number | undefined;
    scanBalanceId: number;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfPacks: number | undefined;
    containerNo: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWeightCaptureDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weightCaptureHeaderId = _data["weightCaptureHeaderId"];
            this.tenantId = _data["tenantId"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.noOfPacks = _data["noOfPacks"];
            this.containerNo = _data["containerNo"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightCaptureDetail {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weightCaptureHeaderId"] = this.weightCaptureHeaderId;
        data["tenantId"] = this.tenantId;
        data["scanBalanceId"] = this.scanBalanceId;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["noOfPacks"] = this.noOfPacks;
        data["containerNo"] = this.containerNo;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightCaptureDetail {
        const json = this.toJSON();
        let result = new WeightCaptureDetail();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureDetail {
    weightCaptureHeaderId: number;
    tenantId: number | undefined;
    scanBalanceId: number;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfPacks: number | undefined;
    containerNo: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationCheckpoint implements IWMCalibrationCheckpoint {
    checkPointId: number | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    wmCalibrationHeaderId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkPointId = _data["checkPointId"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkPointId"] = this.checkPointId;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationCheckpoint {
        const json = this.toJSON();
        let result = new WMCalibrationCheckpoint();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationCheckpoint {
    checkPointId: number | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    wmCalibrationHeaderId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationUncertainityTest implements IWMCalibrationUncertainityTest {
    wmCalibrationHeaderId: number | undefined;
    uncertainityValue: number;
    testResultId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationUncertainityTest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.uncertainityValue = _data["uncertainityValue"];
            this.testResultId = _data["testResultId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationUncertainityTest {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationUncertainityTest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["uncertainityValue"] = this.uncertainityValue;
        data["testResultId"] = this.testResultId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationUncertainityTest {
        const json = this.toJSON();
        let result = new WMCalibrationUncertainityTest();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationUncertainityTest {
    wmCalibrationHeaderId: number | undefined;
    uncertainityValue: number;
    testResultId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibratedLatestMachineDetail implements IWMCalibratedLatestMachineDetail {
    wmCalibrationHeaderId: number | undefined;
    weighingMachineId: number | undefined;
    lastCalibrationTestDate: moment.Moment;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibratedLatestMachineDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.lastCalibrationTestDate = _data["lastCalibrationTestDate"] ? moment(_data["lastCalibrationTestDate"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibratedLatestMachineDetail {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibratedLatestMachineDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["weighingMachineId"] = this.weighingMachineId;
        data["lastCalibrationTestDate"] = this.lastCalibrationTestDate ? this.lastCalibrationTestDate.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibratedLatestMachineDetail {
        const json = this.toJSON();
        let result = new WMCalibratedLatestMachineDetail();
        result.init(json);
        return result;
    }
}

export interface IWMCalibratedLatestMachineDetail {
    wmCalibrationHeaderId: number | undefined;
    weighingMachineId: number | undefined;
    lastCalibrationTestDate: moment.Moment;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WMCalibrationHeader implements IWMCalibrationHeader {
    weighingMachineId: number | undefined;
    calibrationFrequencyId: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    calibrationStatusId: number | undefined;
    isReCalibrated: boolean | undefined;
    initialZeroReading: string | undefined;
    reCalibrationRemark: string | undefined;
    calibrationTestDate: moment.Moment;
    wmCalibrationCheckpoints: WMCalibrationCheckpoint[] | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    wmCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmCalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmCalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmCalibrationUncertainityTests: WMCalibrationUncertainityTest[] | undefined;
    wmCalibratedLatestMachineDetails: WMCalibratedLatestMachineDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWMCalibrationHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.calibrationFrequencyId = _data["calibrationFrequencyId"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.calibrationStatusId = _data["calibrationStatusId"];
            this.isReCalibrated = _data["isReCalibrated"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.reCalibrationRemark = _data["reCalibrationRemark"];
            this.calibrationTestDate = _data["calibrationTestDate"] ? moment(_data["calibrationTestDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["wmCalibrationCheckpoints"])) {
                this.wmCalibrationCheckpoints = [] as any;
                for (let item of _data["wmCalibrationCheckpoints"])
                    this.wmCalibrationCheckpoints.push(WMCalibrationCheckpoint.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationDetails"])) {
                this.wmCalibrationDetails = [] as any;
                for (let item of _data["wmCalibrationDetails"])
                    this.wmCalibrationDetails.push(WMCalibrationDetail.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationEccentricityTests"])) {
                this.wmCalibrationEccentricityTests = [] as any;
                for (let item of _data["wmCalibrationEccentricityTests"])
                    this.wmCalibrationEccentricityTests.push(WMCalibrationEccentricityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationLinearityTests"])) {
                this.wmCalibrationLinearityTests = [] as any;
                for (let item of _data["wmCalibrationLinearityTests"])
                    this.wmCalibrationLinearityTests.push(WMCalibrationLinearityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationRepeatabilityTests"])) {
                this.wmCalibrationRepeatabilityTests = [] as any;
                for (let item of _data["wmCalibrationRepeatabilityTests"])
                    this.wmCalibrationRepeatabilityTests.push(WMCalibrationRepeatabilityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationUncertainityTests"])) {
                this.wmCalibrationUncertainityTests = [] as any;
                for (let item of _data["wmCalibrationUncertainityTests"])
                    this.wmCalibrationUncertainityTests.push(WMCalibrationUncertainityTest.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibratedLatestMachineDetails"])) {
                this.wmCalibratedLatestMachineDetails = [] as any;
                for (let item of _data["wmCalibratedLatestMachineDetails"])
                    this.wmCalibratedLatestMachineDetails.push(WMCalibratedLatestMachineDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMCalibrationHeader {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["calibrationFrequencyId"] = this.calibrationFrequencyId;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["calibrationStatusId"] = this.calibrationStatusId;
        data["isReCalibrated"] = this.isReCalibrated;
        data["initialZeroReading"] = this.initialZeroReading;
        data["reCalibrationRemark"] = this.reCalibrationRemark;
        data["calibrationTestDate"] = this.calibrationTestDate ? this.calibrationTestDate.toISOString() : <any>undefined;
        if (Array.isArray(this.wmCalibrationCheckpoints)) {
            data["wmCalibrationCheckpoints"] = [];
            for (let item of this.wmCalibrationCheckpoints)
                data["wmCalibrationCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationDetails)) {
            data["wmCalibrationDetails"] = [];
            for (let item of this.wmCalibrationDetails)
                data["wmCalibrationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationEccentricityTests)) {
            data["wmCalibrationEccentricityTests"] = [];
            for (let item of this.wmCalibrationEccentricityTests)
                data["wmCalibrationEccentricityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationLinearityTests)) {
            data["wmCalibrationLinearityTests"] = [];
            for (let item of this.wmCalibrationLinearityTests)
                data["wmCalibrationLinearityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationRepeatabilityTests)) {
            data["wmCalibrationRepeatabilityTests"] = [];
            for (let item of this.wmCalibrationRepeatabilityTests)
                data["wmCalibrationRepeatabilityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationUncertainityTests)) {
            data["wmCalibrationUncertainityTests"] = [];
            for (let item of this.wmCalibrationUncertainityTests)
                data["wmCalibrationUncertainityTests"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibratedLatestMachineDetails)) {
            data["wmCalibratedLatestMachineDetails"] = [];
            for (let item of this.wmCalibratedLatestMachineDetails)
                data["wmCalibratedLatestMachineDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMCalibrationHeader {
        const json = this.toJSON();
        let result = new WMCalibrationHeader();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationHeader {
    weighingMachineId: number | undefined;
    calibrationFrequencyId: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    calibrationStatusId: number | undefined;
    isReCalibrated: boolean | undefined;
    initialZeroReading: string | undefined;
    reCalibrationRemark: string | undefined;
    calibrationTestDate: moment.Moment;
    wmCalibrationCheckpoints: WMCalibrationCheckpoint[] | undefined;
    wmCalibrationDetails: WMCalibrationDetail[] | undefined;
    wmCalibrationEccentricityTests: WMCalibrationEccentricityTest[] | undefined;
    wmCalibrationLinearityTests: WMCalibrationLinearityTest[] | undefined;
    wmCalibrationRepeatabilityTests: WMCalibrationRepeatabilityTest[] | undefined;
    wmCalibrationUncertainityTests: WMCalibrationUncertainityTest[] | undefined;
    wmCalibratedLatestMachineDetails: WMCalibratedLatestMachineDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WeighingMachineTestConfiguration implements IWeighingMachineTestConfiguration {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWeighingMachineTestConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.isEccentricityTestRequired = _data["isEccentricityTestRequired"];
            this.isLinearityTestRequired = _data["isLinearityTestRequired"];
            this.isRepeatabilityTestRequired = _data["isRepeatabilityTestRequired"];
            this.isUncertainityTestRequired = _data["isUncertainityTestRequired"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineTestConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineTestConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["isEccentricityTestRequired"] = this.isEccentricityTestRequired;
        data["isLinearityTestRequired"] = this.isLinearityTestRequired;
        data["isRepeatabilityTestRequired"] = this.isRepeatabilityTestRequired;
        data["isUncertainityTestRequired"] = this.isUncertainityTestRequired;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineTestConfiguration {
        const json = this.toJSON();
        let result = new WeighingMachineTestConfiguration();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineTestConfiguration {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class SampleDestruction implements ISampleDestruction {
    inspectionLotId: number;
    materialCode: string;
    sapBatchNumber: string;
    unitOfMeasurementId: number | undefined;
    containerMaterialBarcode: string;
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    weighingMachineId: number | undefined;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ISampleDestruction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionLotId = _data["inspectionLotId"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.containerMaterialBarcode = _data["containerMaterialBarcode"];
            this.noOfPacks = _data["noOfPacks"];
            this.grossWeight = _data["grossWeight"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.tenantId = _data["tenantId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SampleDestruction {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDestruction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionLotId"] = this.inspectionLotId;
        data["materialCode"] = this.materialCode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["containerMaterialBarcode"] = this.containerMaterialBarcode;
        data["noOfPacks"] = this.noOfPacks;
        data["grossWeight"] = this.grossWeight;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["weighingMachineId"] = this.weighingMachineId;
        data["tenantId"] = this.tenantId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): SampleDestruction {
        const json = this.toJSON();
        let result = new SampleDestruction();
        result.init(json);
        return result;
    }
}

export interface ISampleDestruction {
    inspectionLotId: number;
    materialCode: string;
    sapBatchNumber: string;
    unitOfMeasurementId: number | undefined;
    containerMaterialBarcode: string;
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    weighingMachineId: number | undefined;
    tenantId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WeighingMachineMaster implements IWeighingMachineMaster {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValue: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    balancedTypeId: number | undefined;
    calibrations: CalibrationFrequencyMaster[] | undefined;
    weightCaptureDetails: WeightCaptureDetail[] | undefined;
    wmCalibrationHeaders: WMCalibrationHeader[] | undefined;
    wmCalibratedLatestMachineDetails: WMCalibratedLatestMachineDetail[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestConfiguration[] | undefined;
    dispensingDetails: DispensingDetail[] | undefined;
    sampleDestructions: SampleDestruction[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWeighingMachineMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.subPlantId = _data["subPlantId"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.capacity = _data["capacity"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.minimumOperatingCapacity = _data["minimumOperatingCapacity"];
            this.maximumOperatingCapacity = _data["maximumOperatingCapacity"];
            this.leastCount = _data["leastCount"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.eccentricityAcceptanceValue = _data["eccentricityAcceptanceValue"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityAcceptanceValue = _data["linearityAcceptanceValue"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityAcceptanceValue = _data["repeatabilityAcceptanceValue"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyAcceptanceValue = _data["uncertaintyAcceptanceValue"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.percentageRSDValue = _data["percentageRSDValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.meanValue = _data["meanValue"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.formula = _data["formula"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
            this.balancedTypeId = _data["balancedTypeId"];
            if (Array.isArray(_data["calibrations"])) {
                this.calibrations = [] as any;
                for (let item of _data["calibrations"])
                    this.calibrations.push(CalibrationFrequencyMaster.fromJS(item));
            }
            if (Array.isArray(_data["weightCaptureDetails"])) {
                this.weightCaptureDetails = [] as any;
                for (let item of _data["weightCaptureDetails"])
                    this.weightCaptureDetails.push(WeightCaptureDetail.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationHeaders"])) {
                this.wmCalibrationHeaders = [] as any;
                for (let item of _data["wmCalibrationHeaders"])
                    this.wmCalibrationHeaders.push(WMCalibrationHeader.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibratedLatestMachineDetails"])) {
                this.wmCalibratedLatestMachineDetails = [] as any;
                for (let item of _data["wmCalibratedLatestMachineDetails"])
                    this.wmCalibratedLatestMachineDetails.push(WMCalibratedLatestMachineDetail.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestConfiguration.fromJS(item));
            }
            if (Array.isArray(_data["dispensingDetails"])) {
                this.dispensingDetails = [] as any;
                for (let item of _data["dispensingDetails"])
                    this.dispensingDetails.push(DispensingDetail.fromJS(item));
            }
            if (Array.isArray(_data["sampleDestructions"])) {
                this.sampleDestructions = [] as any;
                for (let item of _data["sampleDestructions"])
                    this.sampleDestructions.push(SampleDestruction.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineMaster {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["subPlantId"] = this.subPlantId;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["capacity"] = this.capacity;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["minimumOperatingCapacity"] = this.minimumOperatingCapacity;
        data["maximumOperatingCapacity"] = this.maximumOperatingCapacity;
        data["leastCount"] = this.leastCount;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["eccentricityAcceptanceValue"] = this.eccentricityAcceptanceValue;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityAcceptanceValue"] = this.linearityAcceptanceValue;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityAcceptanceValue"] = this.repeatabilityAcceptanceValue;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyAcceptanceValue"] = this.uncertaintyAcceptanceValue;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["percentageRSDValue"] = this.percentageRSDValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["meanValue"] = this.meanValue;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["formula"] = this.formula;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        data["balancedTypeId"] = this.balancedTypeId;
        if (Array.isArray(this.calibrations)) {
            data["calibrations"] = [];
            for (let item of this.calibrations)
                data["calibrations"].push(item.toJSON());
        }
        if (Array.isArray(this.weightCaptureDetails)) {
            data["weightCaptureDetails"] = [];
            for (let item of this.weightCaptureDetails)
                data["weightCaptureDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationHeaders)) {
            data["wmCalibrationHeaders"] = [];
            for (let item of this.wmCalibrationHeaders)
                data["wmCalibrationHeaders"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibratedLatestMachineDetails)) {
            data["wmCalibratedLatestMachineDetails"] = [];
            for (let item of this.wmCalibratedLatestMachineDetails)
                data["wmCalibratedLatestMachineDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        if (Array.isArray(this.dispensingDetails)) {
            data["dispensingDetails"] = [];
            for (let item of this.dispensingDetails)
                data["dispensingDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.sampleDestructions)) {
            data["sampleDestructions"] = [];
            for (let item of this.sampleDestructions)
                data["sampleDestructions"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineMaster {
        const json = this.toJSON();
        let result = new WeighingMachineMaster();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineMaster {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValue: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    balancedTypeId: number | undefined;
    calibrations: CalibrationFrequencyMaster[] | undefined;
    weightCaptureDetails: WeightCaptureDetail[] | undefined;
    wmCalibrationHeaders: WMCalibrationHeader[] | undefined;
    wmCalibratedLatestMachineDetails: WMCalibratedLatestMachineDetail[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestConfiguration[] | undefined;
    dispensingDetails: DispensingDetail[] | undefined;
    sampleDestructions: SampleDestruction[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class MaterialChecklistDetail implements IMaterialChecklistDetail {
    checkPointId: number | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    materialRelationId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterialChecklistDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkPointId = _data["checkPointId"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.materialRelationId = _data["materialRelationId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialChecklistDetail {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialChecklistDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkPointId"] = this.checkPointId;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["materialRelationId"] = this.materialRelationId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialChecklistDetail {
        const json = this.toJSON();
        let result = new MaterialChecklistDetail();
        result.init(json);
        return result;
    }
}

export interface IMaterialChecklistDetail {
    checkPointId: number | undefined;
    observation: string | undefined;
    discrepancyRemark: string | undefined;
    materialRelationId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class GRNMaterialLabelPrintingContainerBarcode implements IGRNMaterialLabelPrintingContainerBarcode {
    grnMaterialLabelPrintingHeaderId: number | undefined;
    containerNo: number;
    materialLabelContainerBarCode: string;
    grnDetailId: number | undefined;
    grnQtyDetailId: number | undefined;
    quantity: number | undefined;
    balanceQuantity: number | undefined;
    isLoosedContainer: boolean | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGRNMaterialLabelPrintingContainerBarcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnMaterialLabelPrintingHeaderId = _data["grnMaterialLabelPrintingHeaderId"];
            this.containerNo = _data["containerNo"];
            this.materialLabelContainerBarCode = _data["materialLabelContainerBarCode"];
            this.grnDetailId = _data["grnDetailId"];
            this.grnQtyDetailId = _data["grnQtyDetailId"];
            this.quantity = _data["quantity"];
            this.balanceQuantity = _data["balanceQuantity"];
            this.isLoosedContainer = _data["isLoosedContainer"];
            if (Array.isArray(_data["palletizations"])) {
                this.palletizations = [] as any;
                for (let item of _data["palletizations"])
                    this.palletizations.push(Palletization.fromJS(item));
            }
            if (Array.isArray(_data["putAwayBinToBinTransfers"])) {
                this.putAwayBinToBinTransfers = [] as any;
                for (let item of _data["putAwayBinToBinTransfers"])
                    this.putAwayBinToBinTransfers.push(PutAwayBinToBinTransfer.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNMaterialLabelPrintingContainerBarcode {
        data = typeof data === 'object' ? data : {};
        let result = new GRNMaterialLabelPrintingContainerBarcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnMaterialLabelPrintingHeaderId"] = this.grnMaterialLabelPrintingHeaderId;
        data["containerNo"] = this.containerNo;
        data["materialLabelContainerBarCode"] = this.materialLabelContainerBarCode;
        data["grnDetailId"] = this.grnDetailId;
        data["grnQtyDetailId"] = this.grnQtyDetailId;
        data["quantity"] = this.quantity;
        data["balanceQuantity"] = this.balanceQuantity;
        data["isLoosedContainer"] = this.isLoosedContainer;
        if (Array.isArray(this.palletizations)) {
            data["palletizations"] = [];
            for (let item of this.palletizations)
                data["palletizations"].push(item.toJSON());
        }
        if (Array.isArray(this.putAwayBinToBinTransfers)) {
            data["putAwayBinToBinTransfers"] = [];
            for (let item of this.putAwayBinToBinTransfers)
                data["putAwayBinToBinTransfers"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNMaterialLabelPrintingContainerBarcode {
        const json = this.toJSON();
        let result = new GRNMaterialLabelPrintingContainerBarcode();
        result.init(json);
        return result;
    }
}

export interface IGRNMaterialLabelPrintingContainerBarcode {
    grnMaterialLabelPrintingHeaderId: number | undefined;
    containerNo: number;
    materialLabelContainerBarCode: string;
    grnDetailId: number | undefined;
    grnQtyDetailId: number | undefined;
    quantity: number | undefined;
    balanceQuantity: number | undefined;
    isLoosedContainer: boolean | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class GRNQtyDetail implements IGRNQtyDetail {
    grnDetailId: number | undefined;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    discrepancyRemark: string | undefined;
    isDamaged: string | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGRNQtyDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnDetailId = _data["grnDetailId"];
            this.totalQty = _data["totalQty"];
            this.noOfContainer = _data["noOfContainer"];
            this.qtyPerContainer = _data["qtyPerContainer"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.isDamaged = _data["isDamaged"];
            if (Array.isArray(_data["grnMaterialLabelPrintingContainerBarcodes"])) {
                this.grnMaterialLabelPrintingContainerBarcodes = [] as any;
                for (let item of _data["grnMaterialLabelPrintingContainerBarcodes"])
                    this.grnMaterialLabelPrintingContainerBarcodes.push(GRNMaterialLabelPrintingContainerBarcode.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNQtyDetail {
        data = typeof data === 'object' ? data : {};
        let result = new GRNQtyDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnDetailId"] = this.grnDetailId;
        data["totalQty"] = this.totalQty;
        data["noOfContainer"] = this.noOfContainer;
        data["qtyPerContainer"] = this.qtyPerContainer;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["isDamaged"] = this.isDamaged;
        if (Array.isArray(this.grnMaterialLabelPrintingContainerBarcodes)) {
            data["grnMaterialLabelPrintingContainerBarcodes"] = [];
            for (let item of this.grnMaterialLabelPrintingContainerBarcodes)
                data["grnMaterialLabelPrintingContainerBarcodes"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNQtyDetail {
        const json = this.toJSON();
        let result = new GRNQtyDetail();
        result.init(json);
        return result;
    }
}

export interface IGRNQtyDetail {
    grnDetailId: number | undefined;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    discrepancyRemark: string | undefined;
    isDamaged: string | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class GRNMaterialLabelPrintingHeader implements IGRNMaterialLabelPrintingHeader {
    grnDetailId: number | undefined;
    packDetails: string | undefined;
    grnMaterialLabelPrintingDetails: GRNMaterialLabelPrintingDetail[] | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGRNMaterialLabelPrintingHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnDetailId = _data["grnDetailId"];
            this.packDetails = _data["packDetails"];
            if (Array.isArray(_data["grnMaterialLabelPrintingDetails"])) {
                this.grnMaterialLabelPrintingDetails = [] as any;
                for (let item of _data["grnMaterialLabelPrintingDetails"])
                    this.grnMaterialLabelPrintingDetails.push(GRNMaterialLabelPrintingDetail.fromJS(item));
            }
            if (Array.isArray(_data["grnMaterialLabelPrintingContainerBarcodes"])) {
                this.grnMaterialLabelPrintingContainerBarcodes = [] as any;
                for (let item of _data["grnMaterialLabelPrintingContainerBarcodes"])
                    this.grnMaterialLabelPrintingContainerBarcodes.push(GRNMaterialLabelPrintingContainerBarcode.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNMaterialLabelPrintingHeader {
        data = typeof data === 'object' ? data : {};
        let result = new GRNMaterialLabelPrintingHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnDetailId"] = this.grnDetailId;
        data["packDetails"] = this.packDetails;
        if (Array.isArray(this.grnMaterialLabelPrintingDetails)) {
            data["grnMaterialLabelPrintingDetails"] = [];
            for (let item of this.grnMaterialLabelPrintingDetails)
                data["grnMaterialLabelPrintingDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.grnMaterialLabelPrintingContainerBarcodes)) {
            data["grnMaterialLabelPrintingContainerBarcodes"] = [];
            for (let item of this.grnMaterialLabelPrintingContainerBarcodes)
                data["grnMaterialLabelPrintingContainerBarcodes"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNMaterialLabelPrintingHeader {
        const json = this.toJSON();
        let result = new GRNMaterialLabelPrintingHeader();
        result.init(json);
        return result;
    }
}

export interface IGRNMaterialLabelPrintingHeader {
    grnDetailId: number | undefined;
    packDetails: string | undefined;
    grnMaterialLabelPrintingDetails: GRNMaterialLabelPrintingDetail[] | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class GRNDetail implements IGRNDetail {
    grnHeaderId: number | undefined;
    sapBatchNumber: string;
    tenantId: number | undefined;
    materialId: number | undefined;
    mfgBatchNoId: number | undefined;
    invoiceId: number | undefined;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    grnQtyDetails: GRNQtyDetail[] | undefined;
    grnMaterialLabelPrintingHeaders: GRNMaterialLabelPrintingHeader[] | undefined;
    palletizations: Palletization[] | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IGRNDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnHeaderId = _data["grnHeaderId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.tenantId = _data["tenantId"];
            this.materialId = _data["materialId"];
            this.mfgBatchNoId = _data["mfgBatchNoId"];
            this.invoiceId = _data["invoiceId"];
            this.totalQty = _data["totalQty"];
            this.noOfContainer = _data["noOfContainer"];
            this.qtyPerContainer = _data["qtyPerContainer"];
            this.totalQtyInDecimal = _data["totalQtyInDecimal"];
            this.qtyPerContainerInDecimal = _data["qtyPerContainerInDecimal"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            if (Array.isArray(_data["grnQtyDetails"])) {
                this.grnQtyDetails = [] as any;
                for (let item of _data["grnQtyDetails"])
                    this.grnQtyDetails.push(GRNQtyDetail.fromJS(item));
            }
            if (Array.isArray(_data["grnMaterialLabelPrintingHeaders"])) {
                this.grnMaterialLabelPrintingHeaders = [] as any;
                for (let item of _data["grnMaterialLabelPrintingHeaders"])
                    this.grnMaterialLabelPrintingHeaders.push(GRNMaterialLabelPrintingHeader.fromJS(item));
            }
            if (Array.isArray(_data["palletizations"])) {
                this.palletizations = [] as any;
                for (let item of _data["palletizations"])
                    this.palletizations.push(Palletization.fromJS(item));
            }
            if (Array.isArray(_data["grnMaterialLabelPrintingContainerBarcodes"])) {
                this.grnMaterialLabelPrintingContainerBarcodes = [] as any;
                for (let item of _data["grnMaterialLabelPrintingContainerBarcodes"])
                    this.grnMaterialLabelPrintingContainerBarcodes.push(GRNMaterialLabelPrintingContainerBarcode.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNDetail {
        data = typeof data === 'object' ? data : {};
        let result = new GRNDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnHeaderId"] = this.grnHeaderId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["tenantId"] = this.tenantId;
        data["materialId"] = this.materialId;
        data["mfgBatchNoId"] = this.mfgBatchNoId;
        data["invoiceId"] = this.invoiceId;
        data["totalQty"] = this.totalQty;
        data["noOfContainer"] = this.noOfContainer;
        data["qtyPerContainer"] = this.qtyPerContainer;
        data["totalQtyInDecimal"] = this.totalQtyInDecimal;
        data["qtyPerContainerInDecimal"] = this.qtyPerContainerInDecimal;
        data["discrepancyRemark"] = this.discrepancyRemark;
        if (Array.isArray(this.grnQtyDetails)) {
            data["grnQtyDetails"] = [];
            for (let item of this.grnQtyDetails)
                data["grnQtyDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.grnMaterialLabelPrintingHeaders)) {
            data["grnMaterialLabelPrintingHeaders"] = [];
            for (let item of this.grnMaterialLabelPrintingHeaders)
                data["grnMaterialLabelPrintingHeaders"].push(item.toJSON());
        }
        if (Array.isArray(this.palletizations)) {
            data["palletizations"] = [];
            for (let item of this.palletizations)
                data["palletizations"].push(item.toJSON());
        }
        if (Array.isArray(this.grnMaterialLabelPrintingContainerBarcodes)) {
            data["grnMaterialLabelPrintingContainerBarcodes"] = [];
            for (let item of this.grnMaterialLabelPrintingContainerBarcodes)
                data["grnMaterialLabelPrintingContainerBarcodes"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNDetail {
        const json = this.toJSON();
        let result = new GRNDetail();
        result.init(json);
        return result;
    }
}

export interface IGRNDetail {
    grnHeaderId: number | undefined;
    sapBatchNumber: string;
    tenantId: number | undefined;
    materialId: number | undefined;
    mfgBatchNoId: number | undefined;
    invoiceId: number | undefined;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    grnQtyDetails: GRNQtyDetail[] | undefined;
    grnMaterialLabelPrintingHeaders: GRNMaterialLabelPrintingHeader[] | undefined;
    palletizations: Palletization[] | undefined;
    grnMaterialLabelPrintingContainerBarcodes: GRNMaterialLabelPrintingContainerBarcode[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class WeightCaptureHeader implements IWeightCaptureHeader {
    tenantId: number | undefined;
    invoiceId: number;
    purchaseOrderId: number;
    weightCaptureHeaderDetails: WeightCaptureDetail[] | undefined;
    materialId: number;
    mfgBatchNoId: number;
    unitofMeasurementId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IWeightCaptureHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.invoiceId = _data["invoiceId"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            if (Array.isArray(_data["weightCaptureHeaderDetails"])) {
                this.weightCaptureHeaderDetails = [] as any;
                for (let item of _data["weightCaptureHeaderDetails"])
                    this.weightCaptureHeaderDetails.push(WeightCaptureDetail.fromJS(item));
            }
            this.materialId = _data["materialId"];
            this.mfgBatchNoId = _data["mfgBatchNoId"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightCaptureHeader {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        data["purchaseOrderId"] = this.purchaseOrderId;
        if (Array.isArray(this.weightCaptureHeaderDetails)) {
            data["weightCaptureHeaderDetails"] = [];
            for (let item of this.weightCaptureHeaderDetails)
                data["weightCaptureHeaderDetails"].push(item.toJSON());
        }
        data["materialId"] = this.materialId;
        data["mfgBatchNoId"] = this.mfgBatchNoId;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightCaptureHeader {
        const json = this.toJSON();
        let result = new WeightCaptureHeader();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureHeader {
    tenantId: number | undefined;
    invoiceId: number;
    purchaseOrderId: number;
    weightCaptureHeaderDetails: WeightCaptureDetail[] | undefined;
    materialId: number;
    mfgBatchNoId: number;
    unitofMeasurementId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class MaterialDamageDetail implements IMaterialDamageDetail {
    sequenceId: number | undefined;
    containerNo: string | undefined;
    remark: string | undefined;
    quantity: number | undefined;
    quantityInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    materialRelationId: number | undefined;
    materialConsignmentId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterialDamageDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceId = _data["sequenceId"];
            this.containerNo = _data["containerNo"];
            this.remark = _data["remark"];
            this.quantity = _data["quantity"];
            this.quantityInDecimal = _data["quantityInDecimal"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.materialRelationId = _data["materialRelationId"];
            this.materialConsignmentId = _data["materialConsignmentId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialDamageDetail {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDamageDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceId"] = this.sequenceId;
        data["containerNo"] = this.containerNo;
        data["remark"] = this.remark;
        data["quantity"] = this.quantity;
        data["quantityInDecimal"] = this.quantityInDecimal;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["materialRelationId"] = this.materialRelationId;
        data["materialConsignmentId"] = this.materialConsignmentId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialDamageDetail {
        const json = this.toJSON();
        let result = new MaterialDamageDetail();
        result.init(json);
        return result;
    }
}

export interface IMaterialDamageDetail {
    sequenceId: number | undefined;
    containerNo: string | undefined;
    remark: string | undefined;
    quantity: number | undefined;
    quantityInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    materialRelationId: number | undefined;
    materialConsignmentId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class MaterialConsignmentDetail implements IMaterialConsignmentDetail {
    manufacturedBatchNo: string | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    qtyAsPerInvoice: number | undefined;
    qtyAsPerInvoiceInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    sequenceId: number | undefined;
    materialRelationId: number | undefined;
    grnDetails: GRNDetail[] | undefined;
    weightCapture: WeightCaptureHeader[] | undefined;
    materialDamageDetails: MaterialDamageDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterialConsignmentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.manufacturedBatchNo = _data["manufacturedBatchNo"];
            this.manufacturedDate = _data["manufacturedDate"] ? moment(_data["manufacturedDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.qtyAsPerInvoice = _data["qtyAsPerInvoice"];
            this.qtyAsPerInvoiceInDecimal = _data["qtyAsPerInvoiceInDecimal"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.sequenceId = _data["sequenceId"];
            this.materialRelationId = _data["materialRelationId"];
            if (Array.isArray(_data["grnDetails"])) {
                this.grnDetails = [] as any;
                for (let item of _data["grnDetails"])
                    this.grnDetails.push(GRNDetail.fromJS(item));
            }
            if (Array.isArray(_data["weightCapture"])) {
                this.weightCapture = [] as any;
                for (let item of _data["weightCapture"])
                    this.weightCapture.push(WeightCaptureHeader.fromJS(item));
            }
            if (Array.isArray(_data["materialDamageDetails"])) {
                this.materialDamageDetails = [] as any;
                for (let item of _data["materialDamageDetails"])
                    this.materialDamageDetails.push(MaterialDamageDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialConsignmentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialConsignmentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["manufacturedBatchNo"] = this.manufacturedBatchNo;
        data["manufacturedDate"] = this.manufacturedDate ? this.manufacturedDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["qtyAsPerInvoice"] = this.qtyAsPerInvoice;
        data["qtyAsPerInvoiceInDecimal"] = this.qtyAsPerInvoiceInDecimal;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["sequenceId"] = this.sequenceId;
        data["materialRelationId"] = this.materialRelationId;
        if (Array.isArray(this.grnDetails)) {
            data["grnDetails"] = [];
            for (let item of this.grnDetails)
                data["grnDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.weightCapture)) {
            data["weightCapture"] = [];
            for (let item of this.weightCapture)
                data["weightCapture"].push(item.toJSON());
        }
        if (Array.isArray(this.materialDamageDetails)) {
            data["materialDamageDetails"] = [];
            for (let item of this.materialDamageDetails)
                data["materialDamageDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialConsignmentDetail {
        const json = this.toJSON();
        let result = new MaterialConsignmentDetail();
        result.init(json);
        return result;
    }
}

export interface IMaterialConsignmentDetail {
    manufacturedBatchNo: string | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    qtyAsPerInvoice: number | undefined;
    qtyAsPerInvoiceInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    sequenceId: number | undefined;
    materialRelationId: number | undefined;
    grnDetails: GRNDetail[] | undefined;
    weightCapture: WeightCaptureHeader[] | undefined;
    materialDamageDetails: MaterialDamageDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class MaterialInspectionRelationDetail implements IMaterialInspectionRelationDetail {
    materialId: number;
    materialHeaderId: number;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    transactionStatusId: number | undefined;
    materialCheckpoints: MaterialChecklistDetail[] | undefined;
    materialConsignments: MaterialConsignmentDetail[] | undefined;
    materialDamageDetails: MaterialDamageDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterialInspectionRelationDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialId = _data["materialId"];
            this.materialHeaderId = _data["materialHeaderId"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.transactionStatusId = _data["transactionStatusId"];
            if (Array.isArray(_data["materialCheckpoints"])) {
                this.materialCheckpoints = [] as any;
                for (let item of _data["materialCheckpoints"])
                    this.materialCheckpoints.push(MaterialChecklistDetail.fromJS(item));
            }
            if (Array.isArray(_data["materialConsignments"])) {
                this.materialConsignments = [] as any;
                for (let item of _data["materialConsignments"])
                    this.materialConsignments.push(MaterialConsignmentDetail.fromJS(item));
            }
            if (Array.isArray(_data["materialDamageDetails"])) {
                this.materialDamageDetails = [] as any;
                for (let item of _data["materialDamageDetails"])
                    this.materialDamageDetails.push(MaterialDamageDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialInspectionRelationDetail {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInspectionRelationDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["materialHeaderId"] = this.materialHeaderId;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["transactionStatusId"] = this.transactionStatusId;
        if (Array.isArray(this.materialCheckpoints)) {
            data["materialCheckpoints"] = [];
            for (let item of this.materialCheckpoints)
                data["materialCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.materialConsignments)) {
            data["materialConsignments"] = [];
            for (let item of this.materialConsignments)
                data["materialConsignments"].push(item.toJSON());
        }
        if (Array.isArray(this.materialDamageDetails)) {
            data["materialDamageDetails"] = [];
            for (let item of this.materialDamageDetails)
                data["materialDamageDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialInspectionRelationDetail {
        const json = this.toJSON();
        let result = new MaterialInspectionRelationDetail();
        result.init(json);
        return result;
    }
}

export interface IMaterialInspectionRelationDetail {
    materialId: number;
    materialHeaderId: number;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    transactionStatusId: number | undefined;
    materialCheckpoints: MaterialChecklistDetail[] | undefined;
    materialConsignments: MaterialConsignmentDetail[] | undefined;
    materialDamageDetails: MaterialDamageDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class Material implements IMaterial {
    purchaseOrderId: number;
    purchaseOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;
    balanceQuantity: number | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    tenantId: number | undefined;
    materialInspectionRelationDetails: MaterialInspectionRelationDetail[] | undefined;
    grnDetails: GRNDetail[] | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.itemNo = _data["itemNo"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.orderQuantity = _data["orderQuantity"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.balanceQuantity = _data["balanceQuantity"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["materialInspectionRelationDetails"])) {
                this.materialInspectionRelationDetails = [] as any;
                for (let item of _data["materialInspectionRelationDetails"])
                    this.materialInspectionRelationDetails.push(MaterialInspectionRelationDetail.fromJS(item));
            }
            if (Array.isArray(_data["grnDetails"])) {
                this.grnDetails = [] as any;
                for (let item of _data["grnDetails"])
                    this.grnDetails.push(GRNDetail.fromJS(item));
            }
            if (Array.isArray(_data["palletizations"])) {
                this.palletizations = [] as any;
                for (let item of _data["palletizations"])
                    this.palletizations.push(Palletization.fromJS(item));
            }
            if (Array.isArray(_data["putAwayBinToBinTransfers"])) {
                this.putAwayBinToBinTransfers = [] as any;
                for (let item of _data["putAwayBinToBinTransfers"])
                    this.putAwayBinToBinTransfers.push(PutAwayBinToBinTransfer.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Material {
        data = typeof data === 'object' ? data : {};
        let result = new Material();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["itemNo"] = this.itemNo;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["orderQuantity"] = this.orderQuantity;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["balanceQuantity"] = this.balanceQuantity;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.materialInspectionRelationDetails)) {
            data["materialInspectionRelationDetails"] = [];
            for (let item of this.materialInspectionRelationDetails)
                data["materialInspectionRelationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.grnDetails)) {
            data["grnDetails"] = [];
            for (let item of this.grnDetails)
                data["grnDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.palletizations)) {
            data["palletizations"] = [];
            for (let item of this.palletizations)
                data["palletizations"].push(item.toJSON());
        }
        if (Array.isArray(this.putAwayBinToBinTransfers)) {
            data["putAwayBinToBinTransfers"] = [];
            for (let item of this.putAwayBinToBinTransfers)
                data["putAwayBinToBinTransfers"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): Material {
        const json = this.toJSON();
        let result = new Material();
        result.init(json);
        return result;
    }
}

export interface IMaterial {
    purchaseOrderId: number;
    purchaseOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;
    balanceQuantity: number | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    tenantId: number | undefined;
    materialInspectionRelationDetails: MaterialInspectionRelationDetail[] | undefined;
    grnDetails: GRNDetail[] | undefined;
    palletizations: Palletization[] | undefined;
    putAwayBinToBinTransfers: PutAwayBinToBinTransfer[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class PurchaseOrder implements IPurchaseOrder {
    plantId: number;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    purchaseOrders: Material[] | undefined;
    weightCaptureHeaders: WeightCaptureHeader[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IPurchaseOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.purchaseOrderDate = _data["purchaseOrderDate"] ? moment(_data["purchaseOrderDate"].toString()) : <any>undefined;
            this.vendorName = _data["vendorName"];
            this.vendorCode = _data["vendorCode"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
            if (Array.isArray(_data["purchaseOrders"])) {
                this.purchaseOrders = [] as any;
                for (let item of _data["purchaseOrders"])
                    this.purchaseOrders.push(Material.fromJS(item));
            }
            if (Array.isArray(_data["weightCaptureHeaders"])) {
                this.weightCaptureHeaders = [] as any;
                for (let item of _data["weightCaptureHeaders"])
                    this.weightCaptureHeaders.push(WeightCaptureHeader.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseOrder {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["purchaseOrderDate"] = this.purchaseOrderDate ? this.purchaseOrderDate.toISOString() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["vendorCode"] = this.vendorCode;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        if (Array.isArray(this.purchaseOrders)) {
            data["purchaseOrders"] = [];
            for (let item of this.purchaseOrders)
                data["purchaseOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.weightCaptureHeaders)) {
            data["weightCaptureHeaders"] = [];
            for (let item of this.weightCaptureHeaders)
                data["weightCaptureHeaders"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): PurchaseOrder {
        const json = this.toJSON();
        let result = new PurchaseOrder();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrder {
    plantId: number;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    purchaseOrders: Material[] | undefined;
    weightCaptureHeaders: WeightCaptureHeader[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class VehicleInspectionDetail implements IVehicleInspectionDetail {
    vehicleInspectionHeaderId: number | undefined;
    tenantId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IVehicleInspectionDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleInspectionHeaderId = _data["vehicleInspectionHeaderId"];
            this.tenantId = _data["tenantId"];
            this.checkpointId = _data["checkpointId"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionDetail {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleInspectionHeaderId"] = this.vehicleInspectionHeaderId;
        data["tenantId"] = this.tenantId;
        data["checkpointId"] = this.checkpointId;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionDetail {
        const json = this.toJSON();
        let result = new VehicleInspectionDetail();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionDetail {
    vehicleInspectionHeaderId: number | undefined;
    tenantId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class VehicleInspectionHeader implements IVehicleInspectionHeader {
    gateEntryId: number | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    invoiceId: number | undefined;
    vehicleInspectionDetails: VehicleInspectionDetail[] | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    transactionStatusId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IVehicleInspectionHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.inspectionDate = _data["inspectionDate"] ? moment(_data["inspectionDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.invoiceId = _data["invoiceId"];
            if (Array.isArray(_data["vehicleInspectionDetails"])) {
                this.vehicleInspectionDetails = [] as any;
                for (let item of _data["vehicleInspectionDetails"])
                    this.vehicleInspectionDetails.push(VehicleInspectionDetail.fromJS(item));
            }
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionHeader {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        if (Array.isArray(this.vehicleInspectionDetails)) {
            data["vehicleInspectionDetails"] = [];
            for (let item of this.vehicleInspectionDetails)
                data["vehicleInspectionDetails"].push(item.toJSON());
        }
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["transactionStatusId"] = this.transactionStatusId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionHeader {
        const json = this.toJSON();
        let result = new VehicleInspectionHeader();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionHeader {
    gateEntryId: number | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    invoiceId: number | undefined;
    vehicleInspectionDetails: VehicleInspectionDetail[] | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    transactionStatusId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class ChecklistTypeMaster implements IChecklistTypeMaster {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    vehicleInspectionHeader: VehicleInspectionHeader[] | undefined;
    materialInspectionRelationDetails: MaterialInspectionRelationDetail[] | undefined;
    wmCalibrationHeaders: WMCalibrationHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IChecklistTypeMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistTypeCode = _data["checklistTypeCode"];
            this.checklistName = _data["checklistName"];
            this.subPlantId = _data["subPlantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["vehicleInspectionHeader"])) {
                this.vehicleInspectionHeader = [] as any;
                for (let item of _data["vehicleInspectionHeader"])
                    this.vehicleInspectionHeader.push(VehicleInspectionHeader.fromJS(item));
            }
            if (Array.isArray(_data["materialInspectionRelationDetails"])) {
                this.materialInspectionRelationDetails = [] as any;
                for (let item of _data["materialInspectionRelationDetails"])
                    this.materialInspectionRelationDetails.push(MaterialInspectionRelationDetail.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationHeaders"])) {
                this.wmCalibrationHeaders = [] as any;
                for (let item of _data["wmCalibrationHeaders"])
                    this.wmCalibrationHeaders.push(WMCalibrationHeader.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChecklistTypeMaster {
        data = typeof data === 'object' ? data : {};
        let result = new ChecklistTypeMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistTypeCode"] = this.checklistTypeCode;
        data["checklistName"] = this.checklistName;
        data["subPlantId"] = this.subPlantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.vehicleInspectionHeader)) {
            data["vehicleInspectionHeader"] = [];
            for (let item of this.vehicleInspectionHeader)
                data["vehicleInspectionHeader"].push(item.toJSON());
        }
        if (Array.isArray(this.materialInspectionRelationDetails)) {
            data["materialInspectionRelationDetails"] = [];
            for (let item of this.materialInspectionRelationDetails)
                data["materialInspectionRelationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationHeaders)) {
            data["wmCalibrationHeaders"] = [];
            for (let item of this.wmCalibrationHeaders)
                data["wmCalibrationHeaders"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChecklistTypeMaster {
        const json = this.toJSON();
        let result = new ChecklistTypeMaster();
        result.init(json);
        return result;
    }
}

export interface IChecklistTypeMaster {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    tenantId: number | undefined;
    vehicleInspectionHeader: VehicleInspectionHeader[] | undefined;
    materialInspectionRelationDetails: MaterialInspectionRelationDetail[] | undefined;
    wmCalibrationHeaders: WMCalibrationHeader[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class PlantMaster implements IPlantMaster {
    tenantId: number | undefined;
    plantName: string | undefined;
    plantId: string | undefined;
    masterPlantId: number | undefined;
    plantTypeId: number | undefined;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    users: User[] | undefined;
    gateMasters: GateMaster[] | undefined;
    locationMasters: LocationMaster[] | undefined;
    masterPlants: PlantMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    equipmentMasters: EquipmentMaster[] | undefined;
    handlingUnitMasters: HandlingUnitMaster[] | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    departmentMasters: DepartmentMaster[] | undefined;
    areaMasters: AreaMaster[] | undefined;
    weighingMachineMasters: WeighingMachineMaster[] | undefined;
    purchaseOrders: PurchaseOrder[] | undefined;
    checklistTypeMasters: ChecklistTypeMaster[] | undefined;
    userPlants: UserPlants[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IPlantMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.masterPlantId = _data["masterPlantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.taxRegistrationNo = _data["taxRegistrationNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.website = _data["website"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users.push(User.fromJS(item));
            }
            if (Array.isArray(_data["gateMasters"])) {
                this.gateMasters = [] as any;
                for (let item of _data["gateMasters"])
                    this.gateMasters.push(GateMaster.fromJS(item));
            }
            if (Array.isArray(_data["locationMasters"])) {
                this.locationMasters = [] as any;
                for (let item of _data["locationMasters"])
                    this.locationMasters.push(LocationMaster.fromJS(item));
            }
            if (Array.isArray(_data["masterPlants"])) {
                this.masterPlants = [] as any;
                for (let item of _data["masterPlants"])
                    this.masterPlants.push(PlantMaster.fromJS(item));
            }
            if (Array.isArray(_data["cubicleMasters"])) {
                this.cubicleMasters = [] as any;
                for (let item of _data["cubicleMasters"])
                    this.cubicleMasters.push(CubicleMaster.fromJS(item));
            }
            if (Array.isArray(_data["equipmentMasters"])) {
                this.equipmentMasters = [] as any;
                for (let item of _data["equipmentMasters"])
                    this.equipmentMasters.push(EquipmentMaster.fromJS(item));
            }
            if (Array.isArray(_data["handlingUnitMasters"])) {
                this.handlingUnitMasters = [] as any;
                for (let item of _data["handlingUnitMasters"])
                    this.handlingUnitMasters.push(HandlingUnitMaster.fromJS(item));
            }
            if (Array.isArray(_data["standardWeightBoxMasters"])) {
                this.standardWeightBoxMasters = [] as any;
                for (let item of _data["standardWeightBoxMasters"])
                    this.standardWeightBoxMasters.push(StandardWeightBoxMaster.fromJS(item));
            }
            if (Array.isArray(_data["standardWeightMasters"])) {
                this.standardWeightMasters = [] as any;
                for (let item of _data["standardWeightMasters"])
                    this.standardWeightMasters.push(StandardWeightMaster.fromJS(item));
            }
            if (Array.isArray(_data["departmentMasters"])) {
                this.departmentMasters = [] as any;
                for (let item of _data["departmentMasters"])
                    this.departmentMasters.push(DepartmentMaster.fromJS(item));
            }
            if (Array.isArray(_data["areaMasters"])) {
                this.areaMasters = [] as any;
                for (let item of _data["areaMasters"])
                    this.areaMasters.push(AreaMaster.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineMasters"])) {
                this.weighingMachineMasters = [] as any;
                for (let item of _data["weighingMachineMasters"])
                    this.weighingMachineMasters.push(WeighingMachineMaster.fromJS(item));
            }
            if (Array.isArray(_data["purchaseOrders"])) {
                this.purchaseOrders = [] as any;
                for (let item of _data["purchaseOrders"])
                    this.purchaseOrders.push(PurchaseOrder.fromJS(item));
            }
            if (Array.isArray(_data["checklistTypeMasters"])) {
                this.checklistTypeMasters = [] as any;
                for (let item of _data["checklistTypeMasters"])
                    this.checklistTypeMasters.push(ChecklistTypeMaster.fromJS(item));
            }
            if (Array.isArray(_data["userPlants"])) {
                this.userPlants = [] as any;
                for (let item of _data["userPlants"])
                    this.userPlants.push(UserPlants.fromJS(item));
            }
            this.approvalStatusId = _data["approvalStatusId"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlantMaster {
        data = typeof data === 'object' ? data : {};
        let result = new PlantMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["masterPlantId"] = this.masterPlantId;
        data["plantTypeId"] = this.plantTypeId;
        data["taxRegistrationNo"] = this.taxRegistrationNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["website"] = this.website;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.gateMasters)) {
            data["gateMasters"] = [];
            for (let item of this.gateMasters)
                data["gateMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.locationMasters)) {
            data["locationMasters"] = [];
            for (let item of this.locationMasters)
                data["locationMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.masterPlants)) {
            data["masterPlants"] = [];
            for (let item of this.masterPlants)
                data["masterPlants"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleMasters)) {
            data["cubicleMasters"] = [];
            for (let item of this.cubicleMasters)
                data["cubicleMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentMasters)) {
            data["equipmentMasters"] = [];
            for (let item of this.equipmentMasters)
                data["equipmentMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.handlingUnitMasters)) {
            data["handlingUnitMasters"] = [];
            for (let item of this.handlingUnitMasters)
                data["handlingUnitMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.standardWeightBoxMasters)) {
            data["standardWeightBoxMasters"] = [];
            for (let item of this.standardWeightBoxMasters)
                data["standardWeightBoxMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.standardWeightMasters)) {
            data["standardWeightMasters"] = [];
            for (let item of this.standardWeightMasters)
                data["standardWeightMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.departmentMasters)) {
            data["departmentMasters"] = [];
            for (let item of this.departmentMasters)
                data["departmentMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.areaMasters)) {
            data["areaMasters"] = [];
            for (let item of this.areaMasters)
                data["areaMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineMasters)) {
            data["weighingMachineMasters"] = [];
            for (let item of this.weighingMachineMasters)
                data["weighingMachineMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseOrders)) {
            data["purchaseOrders"] = [];
            for (let item of this.purchaseOrders)
                data["purchaseOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.checklistTypeMasters)) {
            data["checklistTypeMasters"] = [];
            for (let item of this.checklistTypeMasters)
                data["checklistTypeMasters"].push(item.toJSON());
        }
        if (Array.isArray(this.userPlants)) {
            data["userPlants"] = [];
            for (let item of this.userPlants)
                data["userPlants"].push(item.toJSON());
        }
        data["approvalStatusId"] = this.approvalStatusId;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): PlantMaster {
        const json = this.toJSON();
        let result = new PlantMaster();
        result.init(json);
        return result;
    }
}

export interface IPlantMaster {
    tenantId: number | undefined;
    plantName: string | undefined;
    plantId: string | undefined;
    masterPlantId: number | undefined;
    plantTypeId: number | undefined;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    users: User[] | undefined;
    gateMasters: GateMaster[] | undefined;
    locationMasters: LocationMaster[] | undefined;
    masterPlants: PlantMaster[] | undefined;
    cubicleMasters: CubicleMaster[] | undefined;
    equipmentMasters: EquipmentMaster[] | undefined;
    handlingUnitMasters: HandlingUnitMaster[] | undefined;
    standardWeightBoxMasters: StandardWeightBoxMaster[] | undefined;
    standardWeightMasters: StandardWeightMaster[] | undefined;
    departmentMasters: DepartmentMaster[] | undefined;
    areaMasters: AreaMaster[] | undefined;
    weighingMachineMasters: WeighingMachineMaster[] | undefined;
    purchaseOrders: PurchaseOrder[] | undefined;
    checklistTypeMasters: ChecklistTypeMaster[] | undefined;
    userPlants: UserPlants[] | undefined;
    approvalStatusId: number;
    approvalStatusDescription: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class UserPlants implements IUserPlants {
    userId: number;
    plantId: number;
    tenantId: number | undefined;
    plantMaster: PlantMaster;
    user: User;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IUserPlants) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.plantId = _data["plantId"];
            this.tenantId = _data["tenantId"];
            this.plantMaster = _data["plantMaster"] ? PlantMaster.fromJS(_data["plantMaster"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPlants {
        data = typeof data === 'object' ? data : {};
        let result = new UserPlants();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["plantId"] = this.plantId;
        data["tenantId"] = this.tenantId;
        data["plantMaster"] = this.plantMaster ? this.plantMaster.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPlants {
        const json = this.toJSON();
        let result = new UserPlants();
        result.init(json);
        return result;
    }
}

export interface IUserPlants {
    userId: number;
    plantId: number;
    tenantId: number | undefined;
    plantMaster: PlantMaster;
    user: User;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    emailAddress: string | undefined;
    name: string;
    surname: string;
    employeeCode: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    accessFailedCount: number;
    lockoutEndDateUtc: moment.Moment | undefined;
    isLockoutEnabled: boolean;
    isLockout: boolean;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    isEmailConfirmed: boolean;
    users: User;
    approvalStatusId: number;
    reportingManagerId: number | undefined;
    plantId: number | undefined;
    modeId: number | undefined;
    designationId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    userPlants: UserPlants[] | undefined;
    approvalStatusDescription: string | undefined;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    readonly fullName: string | undefined;
    password: string;
    phoneNumber: string | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isActive: boolean;
    isDeleted: boolean;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.employeeCode = _data["employeeCode"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.isLockout = _data["isLockout"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.users = _data["users"] ? User.fromJS(_data["users"]) : <any>undefined;
            this.approvalStatusId = _data["approvalStatusId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.plantId = _data["plantId"];
            this.modeId = _data["modeId"];
            this.designationId = _data["designationId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["userPlants"])) {
                this.userPlants = [] as any;
                for (let item of _data["userPlants"])
                    this.userPlants.push(UserPlants.fromJS(item));
            }
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.passwordStatus = _data["passwordStatus"];
            this.passwordResetTime = _data["passwordResetTime"] ? moment(_data["passwordResetTime"].toString()) : <any>undefined;
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["employeeCode"] = this.employeeCode;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["isLockout"] = this.isLockout;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        data["approvalStatusId"] = this.approvalStatusId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["plantId"] = this.plantId;
        data["modeId"] = this.modeId;
        data["designationId"] = this.designationId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.userPlants)) {
            data["userPlants"] = [];
            for (let item of this.userPlants)
                data["userPlants"].push(item.toJSON());
        }
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["passwordStatus"] = this.passwordStatus;
        data["passwordResetTime"] = this.passwordResetTime ? this.passwordResetTime.toISOString() : <any>undefined;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    emailAddress: string | undefined;
    name: string;
    surname: string;
    employeeCode: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    accessFailedCount: number;
    lockoutEndDateUtc: moment.Moment | undefined;
    isLockoutEnabled: boolean;
    isLockout: boolean;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    isEmailConfirmed: boolean;
    users: User;
    approvalStatusId: number;
    reportingManagerId: number | undefined;
    plantId: number | undefined;
    modeId: number | undefined;
    designationId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    description: string | undefined;
    userPlants: UserPlants[] | undefined;
    approvalStatusDescription: string | undefined;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    fullName: string | undefined;
    password: string;
    phoneNumber: string | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isActive: boolean;
    isDeleted: boolean;
    id: number;
}

export class CubicleAssignmentDetail implements ICubicleAssignmentDetail {
    cubicleAssignmentHeaderId: number | undefined;
    tenantId: number | undefined;
    processOrderId: number | undefined;
    processOrderMaterialId: number | undefined;
    cubicleId: number | undefined;
    statusId: number | undefined;
    inspectionLotId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleAssignmentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.tenantId = _data["tenantId"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderMaterialId = _data["processOrderMaterialId"];
            this.cubicleId = _data["cubicleId"];
            this.statusId = _data["statusId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["tenantId"] = this.tenantId;
        data["processOrderId"] = this.processOrderId;
        data["processOrderMaterialId"] = this.processOrderMaterialId;
        data["cubicleId"] = this.cubicleId;
        data["statusId"] = this.statusId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentDetail {
        const json = this.toJSON();
        let result = new CubicleAssignmentDetail();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentDetail {
    cubicleAssignmentHeaderId: number | undefined;
    tenantId: number | undefined;
    processOrderId: number | undefined;
    processOrderMaterialId: number | undefined;
    cubicleId: number | undefined;
    statusId: number | undefined;
    inspectionLotId: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CubicleAssignmentHeader implements ICubicleAssignmentHeader {
    groupId: string;
    cubicleAssignmentDate: moment.Moment;
    productCode: string | undefined;
    tenantId: number | undefined;
    groupStatusId: number | undefined;
    isSampling: boolean;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICubicleAssignmentHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.cubicleAssignmentDate = _data["cubicleAssignmentDate"] ? moment(_data["cubicleAssignmentDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
            this.tenantId = _data["tenantId"];
            this.groupStatusId = _data["groupStatusId"];
            this.isSampling = _data["isSampling"];
            if (Array.isArray(_data["cubicleAssignmentDetails"])) {
                this.cubicleAssignmentDetails = [] as any;
                for (let item of _data["cubicleAssignmentDetails"])
                    this.cubicleAssignmentDetails.push(CubicleAssignmentDetail.fromJS(item));
            }
            if (Array.isArray(_data["equipmentAssignments"])) {
                this.equipmentAssignments = [] as any;
                for (let item of _data["equipmentAssignments"])
                    this.equipmentAssignments.push(EquipmentAssignment.fromJS(item));
            }
            if (Array.isArray(_data["lineClearanceTransactions"])) {
                this.lineClearanceTransactions = [] as any;
                for (let item of _data["lineClearanceTransactions"])
                    this.lineClearanceTransactions.push(LineClearanceTransaction.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentHeader {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["cubicleAssignmentDate"] = this.cubicleAssignmentDate ? this.cubicleAssignmentDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["tenantId"] = this.tenantId;
        data["groupStatusId"] = this.groupStatusId;
        data["isSampling"] = this.isSampling;
        if (Array.isArray(this.cubicleAssignmentDetails)) {
            data["cubicleAssignmentDetails"] = [];
            for (let item of this.cubicleAssignmentDetails)
                data["cubicleAssignmentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentAssignments)) {
            data["equipmentAssignments"] = [];
            for (let item of this.equipmentAssignments)
                data["equipmentAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.lineClearanceTransactions)) {
            data["lineClearanceTransactions"] = [];
            for (let item of this.lineClearanceTransactions)
                data["lineClearanceTransactions"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentHeader {
        const json = this.toJSON();
        let result = new CubicleAssignmentHeader();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentHeader {
    groupId: string;
    cubicleAssignmentDate: moment.Moment;
    productCode: string | undefined;
    tenantId: number | undefined;
    groupStatusId: number | undefined;
    isSampling: boolean;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    equipmentAssignments: EquipmentAssignment[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class EquipmentCleaningCheckpoint implements IEquipmentCleaningCheckpoint {
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    equipmentCleaningTransactionId: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentCleaningCheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkPointId = _data["checkPointId"];
            this.observation = _data["observation"];
            this.remark = _data["remark"];
            this.equipmentCleaningTransactionId = _data["equipmentCleaningTransactionId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentCleaningCheckpoint {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentCleaningCheckpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkPointId"] = this.checkPointId;
        data["observation"] = this.observation;
        data["remark"] = this.remark;
        data["equipmentCleaningTransactionId"] = this.equipmentCleaningTransactionId;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentCleaningCheckpoint {
        const json = this.toJSON();
        let result = new EquipmentCleaningCheckpoint();
        result.init(json);
        return result;
    }
}

export interface IEquipmentCleaningCheckpoint {
    checkPointId: number;
    observation: string | undefined;
    remark: string | undefined;
    equipmentCleaningTransactionId: number;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class EquipmentCleaningTransaction implements IEquipmentCleaningTransaction {
    cleaningDate: moment.Moment;
    equipmentId: number;
    cubicleId: number | undefined;
    areaId: number | undefined;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    tenantId: number | undefined;
    doneBy: string | undefined;
    isSampling: boolean;
    remark: string | undefined;
    equipmentCleaningCheckpoints: EquipmentCleaningCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentCleaningTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.equipmentId = _data["equipmentId"];
            this.cubicleId = _data["cubicleId"];
            this.areaId = _data["areaId"];
            this.cleaningTypeId = _data["cleaningTypeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            this.tenantId = _data["tenantId"];
            this.doneBy = _data["doneBy"];
            this.isSampling = _data["isSampling"];
            this.remark = _data["remark"];
            if (Array.isArray(_data["equipmentCleaningCheckpoints"])) {
                this.equipmentCleaningCheckpoints = [] as any;
                for (let item of _data["equipmentCleaningCheckpoints"])
                    this.equipmentCleaningCheckpoints.push(EquipmentCleaningCheckpoint.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentCleaningTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentCleaningTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["equipmentId"] = this.equipmentId;
        data["cubicleId"] = this.cubicleId;
        data["areaId"] = this.areaId;
        data["cleaningTypeId"] = this.cleaningTypeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        data["tenantId"] = this.tenantId;
        data["doneBy"] = this.doneBy;
        data["isSampling"] = this.isSampling;
        data["remark"] = this.remark;
        if (Array.isArray(this.equipmentCleaningCheckpoints)) {
            data["equipmentCleaningCheckpoints"] = [];
            for (let item of this.equipmentCleaningCheckpoints)
                data["equipmentCleaningCheckpoints"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentCleaningTransaction {
        const json = this.toJSON();
        let result = new EquipmentCleaningTransaction();
        result.init(json);
        return result;
    }
}

export interface IEquipmentCleaningTransaction {
    cleaningDate: moment.Moment;
    equipmentId: number;
    cubicleId: number | undefined;
    areaId: number | undefined;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    tenantId: number | undefined;
    doneBy: string | undefined;
    isSampling: boolean;
    remark: string | undefined;
    equipmentCleaningCheckpoints: EquipmentCleaningCheckpoint[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class EquipmentCleaningStatus implements IEquipmentCleaningStatus {
    cleaningDate: moment.Moment;
    equipmentId: number;
    statusId: number;
    tenantId: number | undefined;
    isSampling: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentCleaningStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.equipmentId = _data["equipmentId"];
            this.statusId = _data["statusId"];
            this.tenantId = _data["tenantId"];
            this.isSampling = _data["isSampling"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentCleaningStatus {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentCleaningStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["equipmentId"] = this.equipmentId;
        data["statusId"] = this.statusId;
        data["tenantId"] = this.tenantId;
        data["isSampling"] = this.isSampling;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentCleaningStatus {
        const json = this.toJSON();
        let result = new EquipmentCleaningStatus();
        result.init(json);
        return result;
    }
}

export interface IEquipmentCleaningStatus {
    cleaningDate: moment.Moment;
    equipmentId: number;
    statusId: number;
    tenantId: number | undefined;
    isSampling: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class ReturnToVendorDetail implements IReturnToVendorDetail {
    returnToVendorHeaderId: number | undefined;
    containerMaterialBarcode: string;
    uom: string | undefined;
    qty: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IReturnToVendorDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.returnToVendorHeaderId = _data["returnToVendorHeaderId"];
            this.containerMaterialBarcode = _data["containerMaterialBarcode"];
            this.uom = _data["uom"];
            this.qty = _data["qty"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReturnToVendorDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnToVendorDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnToVendorHeaderId"] = this.returnToVendorHeaderId;
        data["containerMaterialBarcode"] = this.containerMaterialBarcode;
        data["uom"] = this.uom;
        data["qty"] = this.qty;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReturnToVendorDetail {
        const json = this.toJSON();
        let result = new ReturnToVendorDetail();
        result.init(json);
        return result;
    }
}

export interface IReturnToVendorDetail {
    returnToVendorHeaderId: number | undefined;
    containerMaterialBarcode: string;
    uom: string | undefined;
    qty: number | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class ReturnToVendorHeader implements IReturnToVendorHeader {
    materialDocumentNo: string;
    materialCode: string;
    sapBatchNumber: string;
    tenantId: number | undefined;
    statusId: number;
    qty: number | undefined;
    arNo: string | undefined;
    uom: string | undefined;
    returnToVendorDetails: ReturnToVendorDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IReturnToVendorHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocumentNo = _data["materialDocumentNo"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.tenantId = _data["tenantId"];
            this.statusId = _data["statusId"];
            this.qty = _data["qty"];
            this.arNo = _data["arNo"];
            this.uom = _data["uom"];
            if (Array.isArray(_data["returnToVendorDetails"])) {
                this.returnToVendorDetails = [] as any;
                for (let item of _data["returnToVendorDetails"])
                    this.returnToVendorDetails.push(ReturnToVendorDetail.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReturnToVendorHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnToVendorHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocumentNo"] = this.materialDocumentNo;
        data["materialCode"] = this.materialCode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["tenantId"] = this.tenantId;
        data["statusId"] = this.statusId;
        data["qty"] = this.qty;
        data["arNo"] = this.arNo;
        data["uom"] = this.uom;
        if (Array.isArray(this.returnToVendorDetails)) {
            data["returnToVendorDetails"] = [];
            for (let item of this.returnToVendorDetails)
                data["returnToVendorDetails"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReturnToVendorHeader {
        const json = this.toJSON();
        let result = new ReturnToVendorHeader();
        result.init(json);
        return result;
    }
}

export interface IReturnToVendorHeader {
    materialDocumentNo: string;
    materialCode: string;
    sapBatchNumber: string;
    tenantId: number | undefined;
    statusId: number;
    qty: number | undefined;
    arNo: string | undefined;
    uom: string | undefined;
    returnToVendorDetails: ReturnToVendorDetail[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class StatusMaster implements IStatusMaster {
    status: string | undefined;
    moduleId: number;
    subModuleId: number;
    cubicleAssignmentHeaders: CubicleAssignmentHeader[] | undefined;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    cubicleCleaningTransactions: CubicleCleaningTransaction[] | undefined;
    cubicleCleaningDailyStatuses: CubicleCleaningDailyStatus[] | undefined;
    equipmentCleaningTransactions: EquipmentCleaningTransaction[] | undefined;
    equipmentCleaningStatuses: EquipmentCleaningStatus[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    dispensingHeaders: DispensingHeader[] | undefined;
    stageOutHeader: StageOutHeader[] | undefined;
    returnToVendorHeaders: ReturnToVendorHeader[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IStatusMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            if (Array.isArray(_data["cubicleAssignmentHeaders"])) {
                this.cubicleAssignmentHeaders = [] as any;
                for (let item of _data["cubicleAssignmentHeaders"])
                    this.cubicleAssignmentHeaders.push(CubicleAssignmentHeader.fromJS(item));
            }
            if (Array.isArray(_data["cubicleAssignmentDetails"])) {
                this.cubicleAssignmentDetails = [] as any;
                for (let item of _data["cubicleAssignmentDetails"])
                    this.cubicleAssignmentDetails.push(CubicleAssignmentDetail.fromJS(item));
            }
            if (Array.isArray(_data["cubicleCleaningTransactions"])) {
                this.cubicleCleaningTransactions = [] as any;
                for (let item of _data["cubicleCleaningTransactions"])
                    this.cubicleCleaningTransactions.push(CubicleCleaningTransaction.fromJS(item));
            }
            if (Array.isArray(_data["cubicleCleaningDailyStatuses"])) {
                this.cubicleCleaningDailyStatuses = [] as any;
                for (let item of _data["cubicleCleaningDailyStatuses"])
                    this.cubicleCleaningDailyStatuses.push(CubicleCleaningDailyStatus.fromJS(item));
            }
            if (Array.isArray(_data["equipmentCleaningTransactions"])) {
                this.equipmentCleaningTransactions = [] as any;
                for (let item of _data["equipmentCleaningTransactions"])
                    this.equipmentCleaningTransactions.push(EquipmentCleaningTransaction.fromJS(item));
            }
            if (Array.isArray(_data["equipmentCleaningStatuses"])) {
                this.equipmentCleaningStatuses = [] as any;
                for (let item of _data["equipmentCleaningStatuses"])
                    this.equipmentCleaningStatuses.push(EquipmentCleaningStatus.fromJS(item));
            }
            if (Array.isArray(_data["lineClearanceTransactions"])) {
                this.lineClearanceTransactions = [] as any;
                for (let item of _data["lineClearanceTransactions"])
                    this.lineClearanceTransactions.push(LineClearanceTransaction.fromJS(item));
            }
            if (Array.isArray(_data["dispensingHeaders"])) {
                this.dispensingHeaders = [] as any;
                for (let item of _data["dispensingHeaders"])
                    this.dispensingHeaders.push(DispensingHeader.fromJS(item));
            }
            if (Array.isArray(_data["stageOutHeader"])) {
                this.stageOutHeader = [] as any;
                for (let item of _data["stageOutHeader"])
                    this.stageOutHeader.push(StageOutHeader.fromJS(item));
            }
            if (Array.isArray(_data["returnToVendorHeaders"])) {
                this.returnToVendorHeaders = [] as any;
                for (let item of _data["returnToVendorHeaders"])
                    this.returnToVendorHeaders.push(ReturnToVendorHeader.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StatusMaster {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        if (Array.isArray(this.cubicleAssignmentHeaders)) {
            data["cubicleAssignmentHeaders"] = [];
            for (let item of this.cubicleAssignmentHeaders)
                data["cubicleAssignmentHeaders"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleAssignmentDetails)) {
            data["cubicleAssignmentDetails"] = [];
            for (let item of this.cubicleAssignmentDetails)
                data["cubicleAssignmentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleCleaningTransactions)) {
            data["cubicleCleaningTransactions"] = [];
            for (let item of this.cubicleCleaningTransactions)
                data["cubicleCleaningTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleCleaningDailyStatuses)) {
            data["cubicleCleaningDailyStatuses"] = [];
            for (let item of this.cubicleCleaningDailyStatuses)
                data["cubicleCleaningDailyStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentCleaningTransactions)) {
            data["equipmentCleaningTransactions"] = [];
            for (let item of this.equipmentCleaningTransactions)
                data["equipmentCleaningTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentCleaningStatuses)) {
            data["equipmentCleaningStatuses"] = [];
            for (let item of this.equipmentCleaningStatuses)
                data["equipmentCleaningStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.lineClearanceTransactions)) {
            data["lineClearanceTransactions"] = [];
            for (let item of this.lineClearanceTransactions)
                data["lineClearanceTransactions"].push(item.toJSON());
        }
        if (Array.isArray(this.dispensingHeaders)) {
            data["dispensingHeaders"] = [];
            for (let item of this.dispensingHeaders)
                data["dispensingHeaders"].push(item.toJSON());
        }
        if (Array.isArray(this.stageOutHeader)) {
            data["stageOutHeader"] = [];
            for (let item of this.stageOutHeader)
                data["stageOutHeader"].push(item.toJSON());
        }
        if (Array.isArray(this.returnToVendorHeaders)) {
            data["returnToVendorHeaders"] = [];
            for (let item of this.returnToVendorHeaders)
                data["returnToVendorHeaders"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): StatusMaster {
        const json = this.toJSON();
        let result = new StatusMaster();
        result.init(json);
        return result;
    }
}

export interface IStatusMaster {
    status: string | undefined;
    moduleId: number;
    subModuleId: number;
    cubicleAssignmentHeaders: CubicleAssignmentHeader[] | undefined;
    cubicleAssignmentDetails: CubicleAssignmentDetail[] | undefined;
    cubicleCleaningTransactions: CubicleCleaningTransaction[] | undefined;
    cubicleCleaningDailyStatuses: CubicleCleaningDailyStatus[] | undefined;
    equipmentCleaningTransactions: EquipmentCleaningTransaction[] | undefined;
    equipmentCleaningStatuses: EquipmentCleaningStatus[] | undefined;
    lineClearanceTransactions: LineClearanceTransaction[] | undefined;
    dispensingHeaders: DispensingHeader[] | undefined;
    stageOutHeader: StageOutHeader[] | undefined;
    returnToVendorHeaders: ReturnToVendorHeader[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class BarcodeValidationDto implements IBarcodeValidationDto {
    isValid: boolean;
    validationMessage: string | undefined;

    constructor(data?: IBarcodeValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.validationMessage = _data["validationMessage"];
        }
    }

    static fromJS(data: any): BarcodeValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodeValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["validationMessage"] = this.validationMessage;
        return data; 
    }

    clone(): BarcodeValidationDto {
        const json = this.toJSON();
        let result = new BarcodeValidationDto();
        result.init(json);
        return result;
    }
}

export interface IBarcodeValidationDto {
    isValid: boolean;
    validationMessage: string | undefined;
}

export class AtesttableMasterDto implements IAtesttableMasterDto {
    testfield1: string | undefined;
    testfield2: string | undefined;
    testfield3: string | undefined;
    testfield4: string | undefined;
    id: number;

    constructor(data?: IAtesttableMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testfield1 = _data["testfield1"];
            this.testfield2 = _data["testfield2"];
            this.testfield3 = _data["testfield3"];
            this.testfield4 = _data["testfield4"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AtesttableMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AtesttableMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testfield1"] = this.testfield1;
        data["testfield2"] = this.testfield2;
        data["testfield3"] = this.testfield3;
        data["testfield4"] = this.testfield4;
        data["id"] = this.id;
        return data; 
    }

    clone(): AtesttableMasterDto {
        const json = this.toJSON();
        let result = new AtesttableMasterDto();
        result.init(json);
        return result;
    }
}

export interface IAtesttableMasterDto {
    testfield1: string | undefined;
    testfield2: string | undefined;
    testfield3: string | undefined;
    testfield4: string | undefined;
    id: number;
}

export class PutAwayBinToBinTransferDto implements IPutAwayBinToBinTransferDto {
    transactionId: string;
    isUnloaded: boolean;
    materialTransferTypeId: number;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    palletId: number | undefined;
    locationId: number | undefined;
    materialId: number | undefined;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerId: number | undefined;
    putAwayHeaderId: number | undefined;
    id: number;

    constructor(data?: IPutAwayBinToBinTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.isUnloaded = _data["isUnloaded"];
            this.materialTransferTypeId = _data["materialTransferTypeId"];
            this.locationBarcode = _data["locationBarcode"];
            this.palletBarcode = _data["palletBarcode"];
            this.materialDescription = _data["materialDescription"];
            this.palletId = _data["palletId"];
            this.locationId = _data["locationId"];
            this.materialId = _data["materialId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.containerNo = _data["containerNo"];
            this.containerId = _data["containerId"];
            this.putAwayHeaderId = _data["putAwayHeaderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PutAwayBinToBinTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutAwayBinToBinTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["isUnloaded"] = this.isUnloaded;
        data["materialTransferTypeId"] = this.materialTransferTypeId;
        data["locationBarcode"] = this.locationBarcode;
        data["palletBarcode"] = this.palletBarcode;
        data["materialDescription"] = this.materialDescription;
        data["palletId"] = this.palletId;
        data["locationId"] = this.locationId;
        data["materialId"] = this.materialId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["containerNo"] = this.containerNo;
        data["containerId"] = this.containerId;
        data["putAwayHeaderId"] = this.putAwayHeaderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PutAwayBinToBinTransferDto {
        const json = this.toJSON();
        let result = new PutAwayBinToBinTransferDto();
        result.init(json);
        return result;
    }
}

export interface IPutAwayBinToBinTransferDto {
    transactionId: string;
    isUnloaded: boolean;
    materialTransferTypeId: number;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    palletId: number | undefined;
    locationId: number | undefined;
    materialId: number | undefined;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerId: number | undefined;
    putAwayHeaderId: number | undefined;
    id: number;
}

export class PutAwayBinToBinTransferListDto implements IPutAwayBinToBinTransferListDto {
    materialTransferTypeId: number | undefined;
    palletBarcode: string | undefined;
    locationBarCode: string | undefined;
    count: number;
    locationId: number | undefined;
    materialCode: string | undefined;
    transactionId: string;
    palletId: number | undefined;
    materialId: number | undefined;
    plantId: number;
    itemDescription: string | undefined;
    sapBatchNumber: string | undefined;
    id: number;

    constructor(data?: IPutAwayBinToBinTransferListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialTransferTypeId = _data["materialTransferTypeId"];
            this.palletBarcode = _data["palletBarcode"];
            this.locationBarCode = _data["locationBarCode"];
            this.count = _data["count"];
            this.locationId = _data["locationId"];
            this.materialCode = _data["materialCode"];
            this.transactionId = _data["transactionId"];
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.plantId = _data["plantId"];
            this.itemDescription = _data["itemDescription"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PutAwayBinToBinTransferListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutAwayBinToBinTransferListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialTransferTypeId"] = this.materialTransferTypeId;
        data["palletBarcode"] = this.palletBarcode;
        data["locationBarCode"] = this.locationBarCode;
        data["count"] = this.count;
        data["locationId"] = this.locationId;
        data["materialCode"] = this.materialCode;
        data["transactionId"] = this.transactionId;
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["plantId"] = this.plantId;
        data["itemDescription"] = this.itemDescription;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["id"] = this.id;
        return data; 
    }

    clone(): PutAwayBinToBinTransferListDto {
        const json = this.toJSON();
        let result = new PutAwayBinToBinTransferListDto();
        result.init(json);
        return result;
    }
}

export interface IPutAwayBinToBinTransferListDto {
    materialTransferTypeId: number | undefined;
    palletBarcode: string | undefined;
    locationBarCode: string | undefined;
    count: number;
    locationId: number | undefined;
    materialCode: string | undefined;
    transactionId: string;
    palletId: number | undefined;
    materialId: number | undefined;
    plantId: number;
    itemDescription: string | undefined;
    sapBatchNumber: string | undefined;
    id: number;
}

export class PutAwayBinToBinTransferListDtoPagedResultDto implements IPutAwayBinToBinTransferListDtoPagedResultDto {
    totalCount: number;
    items: PutAwayBinToBinTransferListDto[] | undefined;

    constructor(data?: IPutAwayBinToBinTransferListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PutAwayBinToBinTransferListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutAwayBinToBinTransferListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutAwayBinToBinTransferListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PutAwayBinToBinTransferListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PutAwayBinToBinTransferListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPutAwayBinToBinTransferListDtoPagedResultDto {
    totalCount: number;
    items: PutAwayBinToBinTransferListDto[] | undefined;
}

export class CreatePutAwayBinToBinTransferDto implements ICreatePutAwayBinToBinTransferDto {
    transactionId: string;
    isUnloaded: boolean;
    materialTransferTypeId: number;
    putAwayHeaderId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    palletId: number | undefined;
    locationId: number | undefined;
    materialId: number | undefined;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerId: number | undefined;

    constructor(data?: ICreatePutAwayBinToBinTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.isUnloaded = _data["isUnloaded"];
            this.materialTransferTypeId = _data["materialTransferTypeId"];
            this.putAwayHeaderId = _data["putAwayHeaderId"];
            this.locationBarcode = _data["locationBarcode"];
            this.palletBarcode = _data["palletBarcode"];
            this.materialDescription = _data["materialDescription"];
            this.palletId = _data["palletId"];
            this.locationId = _data["locationId"];
            this.materialId = _data["materialId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.containerNo = _data["containerNo"];
            this.containerId = _data["containerId"];
        }
    }

    static fromJS(data: any): CreatePutAwayBinToBinTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePutAwayBinToBinTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["isUnloaded"] = this.isUnloaded;
        data["materialTransferTypeId"] = this.materialTransferTypeId;
        data["putAwayHeaderId"] = this.putAwayHeaderId;
        data["locationBarcode"] = this.locationBarcode;
        data["palletBarcode"] = this.palletBarcode;
        data["materialDescription"] = this.materialDescription;
        data["palletId"] = this.palletId;
        data["locationId"] = this.locationId;
        data["materialId"] = this.materialId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["containerNo"] = this.containerNo;
        data["containerId"] = this.containerId;
        return data; 
    }

    clone(): CreatePutAwayBinToBinTransferDto {
        const json = this.toJSON();
        let result = new CreatePutAwayBinToBinTransferDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePutAwayBinToBinTransferDto {
    transactionId: string;
    isUnloaded: boolean;
    materialTransferTypeId: number;
    putAwayHeaderId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    palletId: number | undefined;
    locationId: number | undefined;
    materialId: number | undefined;
    sapBatchNumber: string | undefined;
    containerNo: number;
    containerId: number | undefined;
}

export class CageLabelPrintingDto implements ICageLabelPrintingDto {
    dispensingId: number;
    dispensingBarcode: string | undefined;
    productID: number;
    productCode: string | undefined;
    productName: string | undefined;
    processorderID: number;
    processOrderNo: string | undefined;
    cubicleID: number;
    cubcileCode: string | undefined;
    noOfContainer: number | undefined;
    cageLabelBarcode: string | undefined;
    printCount: number | undefined;
    printerID: number | undefined;
    isActive: boolean;
    batchNo: string | undefined;
    isPrint: boolean;
    id: number;

    constructor(data?: ICageLabelPrintingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispensingId = _data["dispensingId"];
            this.dispensingBarcode = _data["dispensingBarcode"];
            this.productID = _data["productID"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.processorderID = _data["processorderID"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleID = _data["cubicleID"];
            this.cubcileCode = _data["cubcileCode"];
            this.noOfContainer = _data["noOfContainer"];
            this.cageLabelBarcode = _data["cageLabelBarcode"];
            this.printCount = _data["printCount"];
            this.printerID = _data["printerID"];
            this.isActive = _data["isActive"];
            this.batchNo = _data["batchNo"];
            this.isPrint = _data["isPrint"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CageLabelPrintingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CageLabelPrintingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispensingId"] = this.dispensingId;
        data["dispensingBarcode"] = this.dispensingBarcode;
        data["productID"] = this.productID;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["processorderID"] = this.processorderID;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleID"] = this.cubicleID;
        data["cubcileCode"] = this.cubcileCode;
        data["noOfContainer"] = this.noOfContainer;
        data["cageLabelBarcode"] = this.cageLabelBarcode;
        data["printCount"] = this.printCount;
        data["printerID"] = this.printerID;
        data["isActive"] = this.isActive;
        data["batchNo"] = this.batchNo;
        data["isPrint"] = this.isPrint;
        data["id"] = this.id;
        return data; 
    }

    clone(): CageLabelPrintingDto {
        const json = this.toJSON();
        let result = new CageLabelPrintingDto();
        result.init(json);
        return result;
    }
}

export interface ICageLabelPrintingDto {
    dispensingId: number;
    dispensingBarcode: string | undefined;
    productID: number;
    productCode: string | undefined;
    productName: string | undefined;
    processorderID: number;
    processOrderNo: string | undefined;
    cubicleID: number;
    cubcileCode: string | undefined;
    noOfContainer: number | undefined;
    cageLabelBarcode: string | undefined;
    printCount: number | undefined;
    printerID: number | undefined;
    isActive: boolean;
    batchNo: string | undefined;
    isPrint: boolean;
    id: number;
}

export class CageLabelPrintingListDto implements ICageLabelPrintingListDto {
    dispensingId: number;
    dispensingBarcode: string | undefined;
    productID: number;
    productCode: string | undefined;
    processorderID: number;
    processOrderNo: string | undefined;
    cubicleID: number;
    cubcileCode: string | undefined;
    noOfContainer: number | undefined;
    cageLabelBarcode: string | undefined;
    printCount: number | undefined;
    printerID: number | undefined;
    isActive: boolean;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    uom: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    id: number;

    constructor(data?: ICageLabelPrintingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispensingId = _data["dispensingId"];
            this.dispensingBarcode = _data["dispensingBarcode"];
            this.productID = _data["productID"];
            this.productCode = _data["productCode"];
            this.processorderID = _data["processorderID"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleID = _data["cubicleID"];
            this.cubcileCode = _data["cubcileCode"];
            this.noOfContainer = _data["noOfContainer"];
            this.cageLabelBarcode = _data["cageLabelBarcode"];
            this.printCount = _data["printCount"];
            this.printerID = _data["printerID"];
            this.isActive = _data["isActive"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.uom = _data["uom"];
            this.arNo = _data["arNo"];
            this.productName = _data["productName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CageLabelPrintingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CageLabelPrintingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispensingId"] = this.dispensingId;
        data["dispensingBarcode"] = this.dispensingBarcode;
        data["productID"] = this.productID;
        data["productCode"] = this.productCode;
        data["processorderID"] = this.processorderID;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleID"] = this.cubicleID;
        data["cubcileCode"] = this.cubcileCode;
        data["noOfContainer"] = this.noOfContainer;
        data["cageLabelBarcode"] = this.cageLabelBarcode;
        data["printCount"] = this.printCount;
        data["printerID"] = this.printerID;
        data["isActive"] = this.isActive;
        data["batchNo"] = this.batchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["uom"] = this.uom;
        data["arNo"] = this.arNo;
        data["productName"] = this.productName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CageLabelPrintingListDto {
        const json = this.toJSON();
        let result = new CageLabelPrintingListDto();
        result.init(json);
        return result;
    }
}

export interface ICageLabelPrintingListDto {
    dispensingId: number;
    dispensingBarcode: string | undefined;
    productID: number;
    productCode: string | undefined;
    processorderID: number;
    processOrderNo: string | undefined;
    cubicleID: number;
    cubcileCode: string | undefined;
    noOfContainer: number | undefined;
    cageLabelBarcode: string | undefined;
    printCount: number | undefined;
    printerID: number | undefined;
    isActive: boolean;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    uom: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    id: number;
}

export class CageLabelPrintingListDtoPagedResultDto implements ICageLabelPrintingListDtoPagedResultDto {
    totalCount: number;
    items: CageLabelPrintingListDto[] | undefined;

    constructor(data?: ICageLabelPrintingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CageLabelPrintingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CageLabelPrintingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CageLabelPrintingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CageLabelPrintingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CageLabelPrintingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICageLabelPrintingListDtoPagedResultDto {
    totalCount: number;
    items: CageLabelPrintingListDto[] | undefined;
}

export class SelectListDtoWithPlantId implements ISelectListDtoWithPlantId {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    leastCountDigitAfterDecimal: number | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDtoWithPlantId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.plantId = _data["plantId"];
            this.isActive = _data["isActive"];
            this.isSampling = _data["isSampling"];
            this.isReservationNo = _data["isReservationNo"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDtoWithPlantId {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDtoWithPlantId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["plantId"] = this.plantId;
        data["isActive"] = this.isActive;
        data["isSampling"] = this.isSampling;
        data["isReservationNo"] = this.isReservationNo;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["id"] = this.id;
        return data; 
    }

    clone(): SelectListDtoWithPlantId {
        const json = this.toJSON();
        let result = new SelectListDtoWithPlantId();
        result.init(json);
        return result;
    }
}

export interface ISelectListDtoWithPlantId {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    leastCountDigitAfterDecimal: number | undefined;
    id: any | undefined;
}

export class CalenderDto implements ICalenderDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayTypeId: number;
    holidayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: ICalenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.calenderDate = _data["calenderDate"] ? moment(_data["calenderDate"].toString()) : <any>undefined;
            this.holidayTypeId = _data["holidayTypeId"];
            this.holidayName = _data["holidayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CalenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["calenderDate"] = this.calenderDate ? this.calenderDate.toISOString() : <any>undefined;
        data["holidayTypeId"] = this.holidayTypeId;
        data["holidayName"] = this.holidayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): CalenderDto {
        const json = this.toJSON();
        let result = new CalenderDto();
        result.init(json);
        return result;
    }
}

export interface ICalenderDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayTypeId: number;
    holidayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class CalenderListDto implements ICalenderListDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayTypeId: number;
    approvalStatusId: number;
    holidayName: string | undefined;
    description: string | undefined;
    userEnteredSubPlantId: string | undefined;
    isActive: boolean;
    userEnteredHolidayType: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: ICalenderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.calenderDate = _data["calenderDate"] ? moment(_data["calenderDate"].toString()) : <any>undefined;
            this.holidayTypeId = _data["holidayTypeId"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.holidayName = _data["holidayName"];
            this.description = _data["description"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.isActive = _data["isActive"];
            this.userEnteredHolidayType = _data["userEnteredHolidayType"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CalenderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalenderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["calenderDate"] = this.calenderDate ? this.calenderDate.toISOString() : <any>undefined;
        data["holidayTypeId"] = this.holidayTypeId;
        data["approvalStatusId"] = this.approvalStatusId;
        data["holidayName"] = this.holidayName;
        data["description"] = this.description;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["isActive"] = this.isActive;
        data["userEnteredHolidayType"] = this.userEnteredHolidayType;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): CalenderListDto {
        const json = this.toJSON();
        let result = new CalenderListDto();
        result.init(json);
        return result;
    }
}

export interface ICalenderListDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayTypeId: number;
    approvalStatusId: number;
    holidayName: string | undefined;
    description: string | undefined;
    userEnteredSubPlantId: string | undefined;
    isActive: boolean;
    userEnteredHolidayType: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class CalenderListDtoPagedResultDto implements ICalenderListDtoPagedResultDto {
    totalCount: number;
    items: CalenderListDto[] | undefined;

    constructor(data?: ICalenderListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CalenderListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalenderListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalenderListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CalenderListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CalenderListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICalenderListDtoPagedResultDto {
    totalCount: number;
    items: CalenderListDto[] | undefined;
}

export class CreateCalenderDto implements ICreateCalenderDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayName: string | undefined;
    holidayTypeId: number;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateCalenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.calenderDate = _data["calenderDate"] ? moment(_data["calenderDate"].toString()) : <any>undefined;
            this.holidayName = _data["holidayName"];
            this.holidayTypeId = _data["holidayTypeId"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCalenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCalenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["calenderDate"] = this.calenderDate ? this.calenderDate.toISOString() : <any>undefined;
        data["holidayName"] = this.holidayName;
        data["holidayTypeId"] = this.holidayTypeId;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateCalenderDto {
        const json = this.toJSON();
        let result = new CreateCalenderDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCalenderDto {
    subPlantId: number;
    calenderDate: moment.Moment;
    holidayName: string | undefined;
    holidayTypeId: number;
    description: string | undefined;
    isActive: boolean;
}

export class ChangePasswordDto implements IChangePasswordDto {
    userId: number;
    newPassword: string;
    confirmPassword: string | undefined;
    passwordStatus: number;
    currentUser: number;
    status: boolean;
    userName: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
            this.passwordStatus = _data["passwordStatus"];
            this.currentUser = _data["currentUser"];
            this.status = _data["status"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        data["passwordStatus"] = this.passwordStatus;
        data["currentUser"] = this.currentUser;
        data["status"] = this.status;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    userId: number;
    newPassword: string;
    confirmPassword: string | undefined;
    passwordStatus: number;
    currentUser: number;
    status: boolean;
    userName: string | undefined;
}

export class ChangePasswordSuperAdminDto implements IChangePasswordSuperAdminDto {
    employeeCode: string;
    newPassword: string;

    constructor(data?: IChangePasswordSuperAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeCode = _data["employeeCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordSuperAdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordSuperAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeCode"] = this.employeeCode;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordSuperAdminDto {
        const json = this.toJSON();
        let result = new ChangePasswordSuperAdminDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordSuperAdminDto {
    employeeCode: string;
    newPassword: string;
}

export class ChangePasswordSuperAdminOutputDto implements IChangePasswordSuperAdminOutputDto {
    status: boolean;
    message: string | undefined;

    constructor(data?: IChangePasswordSuperAdminOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ChangePasswordSuperAdminOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordSuperAdminOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data; 
    }

    clone(): ChangePasswordSuperAdminOutputDto {
        const json = this.toJSON();
        let result = new ChangePasswordSuperAdminOutputDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordSuperAdminOutputDto {
    status: boolean;
    message: string | undefined;
}

export class UserDto implements IUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    isDeleted: boolean;
    plants: number[] | undefined;
    designationId: number | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    employeeCode: string | undefined;
    createdOn: moment.Moment;
    roleNames: string[] | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    activeInactiveStatusOfUser: boolean;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(item);
            }
            this.designationId = _data["designationId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.modeId = _data["modeId"];
            this.employeeCode = _data["employeeCode"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.activeInactiveStatusOfUser = _data["activeInactiveStatusOfUser"];
            this.passwordStatus = _data["passwordStatus"];
            this.passwordResetTime = _data["passwordResetTime"] ? moment(_data["passwordResetTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item);
        }
        data["designationId"] = this.designationId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["modeId"] = this.modeId;
        data["employeeCode"] = this.employeeCode;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["activeInactiveStatusOfUser"] = this.activeInactiveStatusOfUser;
        data["passwordStatus"] = this.passwordStatus;
        data["passwordResetTime"] = this.passwordResetTime ? this.passwordResetTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    isDeleted: boolean;
    plants: number[] | undefined;
    designationId: number | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    employeeCode: string | undefined;
    createdOn: moment.Moment;
    roleNames: string[] | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    activeInactiveStatusOfUser: boolean;
    passwordStatus: number;
    passwordResetTime: moment.Moment | undefined;
    id: number;
}

export class WMSPasswordManagerDto implements IWMSPasswordManagerDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IWMSPasswordManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMSPasswordManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WMSPasswordManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMSPasswordManagerDto {
        const json = this.toJSON();
        let result = new WMSPasswordManagerDto();
        result.init(json);
        return result;
    }
}

export interface IWMSPasswordManagerDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    id: number;
}

export class WMSPasswordManagerDetailsDto implements IWMSPasswordManagerDetailsDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment | undefined;
    id: number;

    constructor(data?: IWMSPasswordManagerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? moment(_data["modifiedOn"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WMSPasswordManagerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WMSPasswordManagerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WMSPasswordManagerDetailsDto {
        const json = this.toJSON();
        let result = new WMSPasswordManagerDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IWMSPasswordManagerDetailsDto {
    userName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    createdOn: moment.Moment;
    modifiedOn: moment.Moment | undefined;
    id: number;
}

export class RequestedUsersListDto implements IRequestedUsersListDto {
    userId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    request: string | undefined;
    status: string | undefined;
    roleNames: string | undefined;
    id: number;

    constructor(data?: IRequestedUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.request = _data["request"];
            this.status = _data["status"];
            this.roleNames = _data["roleNames"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestedUsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedUsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["request"] = this.request;
        data["status"] = this.status;
        data["roleNames"] = this.roleNames;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestedUsersListDto {
        const json = this.toJSON();
        let result = new RequestedUsersListDto();
        result.init(json);
        return result;
    }
}

export interface IRequestedUsersListDto {
    userId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    request: string | undefined;
    status: string | undefined;
    roleNames: string | undefined;
    id: number;
}

export class RequestedUsersListDtoPagedResultDto implements IRequestedUsersListDtoPagedResultDto {
    totalCount: number;
    items: RequestedUsersListDto[] | undefined;

    constructor(data?: IRequestedUsersListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RequestedUsersListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestedUsersListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestedUsersListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestedUsersListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RequestedUsersListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRequestedUsersListDtoPagedResultDto {
    totalCount: number;
    items: RequestedUsersListDto[] | undefined;
}

export class ChecklistTypeDto implements IChecklistTypeDto {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IChecklistTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistTypeCode = _data["checklistTypeCode"];
            this.checklistName = _data["checklistName"];
            this.subPlantId = _data["subPlantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChecklistTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChecklistTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistTypeCode"] = this.checklistTypeCode;
        data["checklistName"] = this.checklistName;
        data["subPlantId"] = this.subPlantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChecklistTypeDto {
        const json = this.toJSON();
        let result = new ChecklistTypeDto();
        result.init(json);
        return result;
    }
}

export interface IChecklistTypeDto {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class ChecklistTypeListDto implements IChecklistTypeListDto {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    userEnteredPlantId: string | undefined;
    userEnteredSubModuleName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IChecklistTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistTypeCode = _data["checklistTypeCode"];
            this.checklistName = _data["checklistName"];
            this.subPlantId = _data["subPlantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredSubModuleName = _data["userEnteredSubModuleName"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChecklistTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChecklistTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistTypeCode"] = this.checklistTypeCode;
        data["checklistName"] = this.checklistName;
        data["subPlantId"] = this.subPlantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredSubModuleName"] = this.userEnteredSubModuleName;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChecklistTypeListDto {
        const json = this.toJSON();
        let result = new ChecklistTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IChecklistTypeListDto {
    checklistTypeCode: string | undefined;
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
    userEnteredPlantId: string | undefined;
    userEnteredSubModuleName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class ChecklistTypeListDtoPagedResultDto implements IChecklistTypeListDtoPagedResultDto {
    totalCount: number;
    items: ChecklistTypeListDto[] | undefined;

    constructor(data?: IChecklistTypeListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ChecklistTypeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChecklistTypeListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChecklistTypeListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ChecklistTypeListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ChecklistTypeListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IChecklistTypeListDtoPagedResultDto {
    totalCount: number;
    items: ChecklistTypeListDto[] | undefined;
}

export class CreateChecklistTypeDto implements ICreateChecklistTypeDto {
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;

    constructor(data?: ICreateChecklistTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistName = _data["checklistName"];
            this.subPlantId = _data["subPlantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateChecklistTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChecklistTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistName"] = this.checklistName;
        data["subPlantId"] = this.subPlantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateChecklistTypeDto {
        const json = this.toJSON();
        let result = new CreateChecklistTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateChecklistTypeDto {
    checklistName: string | undefined;
    subPlantId: number | undefined;
    subModuleId: number | undefined;
    isActive: boolean;
}

export class ClientFormsDto implements IClientFormsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment;
    formEndDate: moment.Moment;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment;
    modifiedDate: moment.Moment;
    id: number;

    constructor(data?: IClientFormsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.formName = _data["formName"];
            this.formStartDate = _data["formStartDate"] ? moment(_data["formStartDate"].toString()) : <any>undefined;
            this.formEndDate = _data["formEndDate"] ? moment(_data["formEndDate"].toString()) : <any>undefined;
            this.formJson = _data["formJson"];
            this.isActive = _data["isActive"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? moment(_data["modifiedDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientFormsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFormsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["formName"] = this.formName;
        data["formStartDate"] = this.formStartDate ? this.formStartDate.toISOString() : <any>undefined;
        data["formEndDate"] = this.formEndDate ? this.formEndDate.toISOString() : <any>undefined;
        data["formJson"] = this.formJson;
        data["isActive"] = this.isActive;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientFormsDto {
        const json = this.toJSON();
        let result = new ClientFormsDto();
        result.init(json);
        return result;
    }
}

export interface IClientFormsDto {
    clientId: number;
    formName: string | undefined;
    formStartDate: moment.Moment;
    formEndDate: moment.Moment;
    formJson: string | undefined;
    isActive: boolean;
    creationDate: moment.Moment;
    modifiedDate: moment.Moment;
    id: number;
}

export class ClientFormsDtoPagedResultDto implements IClientFormsDtoPagedResultDto {
    totalCount: number;
    items: ClientFormsDto[] | undefined;

    constructor(data?: IClientFormsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ClientFormsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientFormsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFormsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ClientFormsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ClientFormsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IClientFormsDtoPagedResultDto {
    totalCount: number;
    items: ClientFormsDto[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ConsumptionDetailDto implements IConsumptionDetailDto {
    consumptionId: number | undefined;
    materialBarocdeId: number | undefined;
    productCode: string | undefined;
    lineItemNo: string | undefined;
    processOrderMaterialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    batchNo: string | undefined;
    sapBatchNumber: string | undefined;
    qty: number | undefined;
    unitOfMeasurement: string | undefined;
    unitOfMeasurementId: number | undefined;
    expiryDate: string | undefined;
    retestDate: string | undefined;
    arNo: string | undefined;
    id: number;

    constructor(data?: IConsumptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumptionId = _data["consumptionId"];
            this.materialBarocdeId = _data["materialBarocdeId"];
            this.productCode = _data["productCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.processOrderMaterialId = _data["processOrderMaterialId"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.qty = _data["qty"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.expiryDate = _data["expiryDate"];
            this.retestDate = _data["retestDate"];
            this.arNo = _data["arNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConsumptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumptionId"] = this.consumptionId;
        data["materialBarocdeId"] = this.materialBarocdeId;
        data["productCode"] = this.productCode;
        data["lineItemNo"] = this.lineItemNo;
        data["processOrderMaterialId"] = this.processOrderMaterialId;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["batchNo"] = this.batchNo;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["qty"] = this.qty;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["expiryDate"] = this.expiryDate;
        data["retestDate"] = this.retestDate;
        data["arNo"] = this.arNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): ConsumptionDetailDto {
        const json = this.toJSON();
        let result = new ConsumptionDetailDto();
        result.init(json);
        return result;
    }
}

export interface IConsumptionDetailDto {
    consumptionId: number | undefined;
    materialBarocdeId: number | undefined;
    productCode: string | undefined;
    lineItemNo: string | undefined;
    processOrderMaterialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    batchNo: string | undefined;
    sapBatchNumber: string | undefined;
    qty: number | undefined;
    unitOfMeasurement: string | undefined;
    unitOfMeasurementId: number | undefined;
    expiryDate: string | undefined;
    retestDate: string | undefined;
    arNo: string | undefined;
    id: number;
}

export class CreateConsumptionHeaderDto implements ICreateConsumptionHeaderDto {
    cubicleId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    equipmentId: number | undefined;
    noOfContainer: number | undefined;
    consumptionDetails: ConsumptionDetailDto[] | undefined;

    constructor(data?: ICreateConsumptionHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.equipmentId = _data["equipmentId"];
            this.noOfContainer = _data["noOfContainer"];
            if (Array.isArray(_data["consumptionDetails"])) {
                this.consumptionDetails = [] as any;
                for (let item of _data["consumptionDetails"])
                    this.consumptionDetails.push(ConsumptionDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateConsumptionHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConsumptionHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["equipmentId"] = this.equipmentId;
        data["noOfContainer"] = this.noOfContainer;
        if (Array.isArray(this.consumptionDetails)) {
            data["consumptionDetails"] = [];
            for (let item of this.consumptionDetails)
                data["consumptionDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateConsumptionHeaderDto {
        const json = this.toJSON();
        let result = new CreateConsumptionHeaderDto();
        result.init(json);
        return result;
    }
}

export interface ICreateConsumptionHeaderDto {
    cubicleId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    equipmentId: number | undefined;
    noOfContainer: number | undefined;
    consumptionDetails: ConsumptionDetailDto[] | undefined;
}

export class ConsumptionDto implements IConsumptionDto {
    cubicleId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    equipmentId: number | undefined;
    noOfContainer: number | undefined;
    consumptionDetails: ConsumptionDetailDto[] | undefined;
    id: number;

    constructor(data?: IConsumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.equipmentId = _data["equipmentId"];
            this.noOfContainer = _data["noOfContainer"];
            if (Array.isArray(_data["consumptionDetails"])) {
                this.consumptionDetails = [] as any;
                for (let item of _data["consumptionDetails"])
                    this.consumptionDetails.push(ConsumptionDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConsumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["equipmentId"] = this.equipmentId;
        data["noOfContainer"] = this.noOfContainer;
        if (Array.isArray(this.consumptionDetails)) {
            data["consumptionDetails"] = [];
            for (let item of this.consumptionDetails)
                data["consumptionDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): ConsumptionDto {
        const json = this.toJSON();
        let result = new ConsumptionDto();
        result.init(json);
        return result;
    }
}

export interface IConsumptionDto {
    cubicleId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    equipmentId: number | undefined;
    noOfContainer: number | undefined;
    consumptionDetails: ConsumptionDetailDto[] | undefined;
    id: number;
}

export class ConsumptionListDto implements IConsumptionListDto {
    cubicleId: number | undefined;
    productId: string | undefined;
    cubicalCode: string | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    equipmentId: number | undefined;
    processBarcodeId: number | undefined;
    equipmentBracodeId: number | undefined;
    equipmentNo: string | undefined;
    noOfContainer: number | undefined;
    id: number;

    constructor(data?: IConsumptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.productId = _data["productId"];
            this.cubicalCode = _data["cubicalCode"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.equipmentId = _data["equipmentId"];
            this.processBarcodeId = _data["processBarcodeId"];
            this.equipmentBracodeId = _data["equipmentBracodeId"];
            this.equipmentNo = _data["equipmentNo"];
            this.noOfContainer = _data["noOfContainer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConsumptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["productId"] = this.productId;
        data["cubicalCode"] = this.cubicalCode;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["equipmentId"] = this.equipmentId;
        data["processBarcodeId"] = this.processBarcodeId;
        data["equipmentBracodeId"] = this.equipmentBracodeId;
        data["equipmentNo"] = this.equipmentNo;
        data["noOfContainer"] = this.noOfContainer;
        data["id"] = this.id;
        return data; 
    }

    clone(): ConsumptionListDto {
        const json = this.toJSON();
        let result = new ConsumptionListDto();
        result.init(json);
        return result;
    }
}

export interface IConsumptionListDto {
    cubicleId: number | undefined;
    productId: string | undefined;
    cubicalCode: string | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    equipmentId: number | undefined;
    processBarcodeId: number | undefined;
    equipmentBracodeId: number | undefined;
    equipmentNo: string | undefined;
    noOfContainer: number | undefined;
    id: number;
}

export class ConsumptionListDtoPagedResultDto implements IConsumptionListDtoPagedResultDto {
    totalCount: number;
    items: ConsumptionListDto[] | undefined;

    constructor(data?: IConsumptionListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ConsumptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumptionListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ConsumptionListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ConsumptionListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IConsumptionListDtoPagedResultDto {
    totalCount: number;
    items: ConsumptionListDto[] | undefined;
}

export class CubicleDto implements ICubicleDto {
    plantId: number;
    cubicleCode: string;
    areaId: number;
    slocId: number;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: ICubicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.cubicleCode = _data["cubicleCode"];
            this.areaId = _data["areaId"];
            this.slocId = _data["slocId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["cubicleCode"] = this.cubicleCode;
        data["areaId"] = this.areaId;
        data["slocId"] = this.slocId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleDto {
        const json = this.toJSON();
        let result = new CubicleDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleDto {
    plantId: number;
    cubicleCode: string;
    areaId: number;
    slocId: number;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class CubicleListDto implements ICubicleListDto {
    userEnteredPlantId: string | undefined;
    userEnteredAreaId: string | undefined;
    plantId: number;
    cubicleCode: string | undefined;
    area: number | undefined;
    slocId: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: ICubicleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredAreaId = _data["userEnteredAreaId"];
            this.plantId = _data["plantId"];
            this.cubicleCode = _data["cubicleCode"];
            this.area = _data["area"];
            this.slocId = _data["slocId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredAreaId"] = this.userEnteredAreaId;
        data["plantId"] = this.plantId;
        data["cubicleCode"] = this.cubicleCode;
        data["area"] = this.area;
        data["slocId"] = this.slocId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleListDto {
        const json = this.toJSON();
        let result = new CubicleListDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleListDto {
    userEnteredPlantId: string | undefined;
    userEnteredAreaId: string | undefined;
    plantId: number;
    cubicleCode: string | undefined;
    area: number | undefined;
    slocId: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class CubicleListDtoPagedResultDto implements ICubicleListDtoPagedResultDto {
    totalCount: number;
    items: CubicleListDto[] | undefined;

    constructor(data?: ICubicleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CubicleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CubicleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CubicleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CubicleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleListDtoPagedResultDto {
    totalCount: number;
    items: CubicleListDto[] | undefined;
}

export class CreateCubicleDto implements ICreateCubicleDto {
    plantId: number;
    cubicleCode: string;
    areaId: number;
    slocId: number;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateCubicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.cubicleCode = _data["cubicleCode"];
            this.areaId = _data["areaId"];
            this.slocId = _data["slocId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCubicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCubicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["cubicleCode"] = this.cubicleCode;
        data["areaId"] = this.areaId;
        data["slocId"] = this.slocId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateCubicleDto {
        const json = this.toJSON();
        let result = new CreateCubicleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCubicleDto {
    plantId: number;
    cubicleCode: string;
    areaId: number;
    slocId: number;
    isActive: boolean;
    description: string | undefined;
}

export class CubicleAssignmentDetailsDto implements ICubicleAssignmentDetailsDto {
    cubicleAssignmentHeaderId: number | undefined;
    cubicleId: number | undefined;
    cubicleBarcode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    inspectionLotId: number | undefined;
    inspectionLotNo: string | undefined;
    productCode: string | undefined;
    lineItemNo: string | undefined;
    processOrderMaterialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    batchNo: string | undefined;
    sapBatchNumber: string | undefined;
    qty: number | undefined;
    unitOfMeasurement: string | undefined;
    unitOfMeasurementId: number | undefined;
    expiryDate: string | undefined;
    retestDate: string | undefined;
    arNo: string | undefined;
    isAssigned: boolean;
    tenantId: number | undefined;
    statusId: number | undefined;
    isReservationNo: boolean;
    id: number;

    constructor(data?: ICubicleAssignmentDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.cubicleId = _data["cubicleId"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.inspectionLotNo = _data["inspectionLotNo"];
            this.productCode = _data["productCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.processOrderMaterialId = _data["processOrderMaterialId"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.qty = _data["qty"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.expiryDate = _data["expiryDate"];
            this.retestDate = _data["retestDate"];
            this.arNo = _data["arNo"];
            this.isAssigned = _data["isAssigned"];
            this.tenantId = _data["tenantId"];
            this.statusId = _data["statusId"];
            this.isReservationNo = _data["isReservationNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["cubicleId"] = this.cubicleId;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["inspectionLotId"] = this.inspectionLotId;
        data["inspectionLotNo"] = this.inspectionLotNo;
        data["productCode"] = this.productCode;
        data["lineItemNo"] = this.lineItemNo;
        data["processOrderMaterialId"] = this.processOrderMaterialId;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["batchNo"] = this.batchNo;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["qty"] = this.qty;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["expiryDate"] = this.expiryDate;
        data["retestDate"] = this.retestDate;
        data["arNo"] = this.arNo;
        data["isAssigned"] = this.isAssigned;
        data["tenantId"] = this.tenantId;
        data["statusId"] = this.statusId;
        data["isReservationNo"] = this.isReservationNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentDetailsDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentDetailsDto {
    cubicleAssignmentHeaderId: number | undefined;
    cubicleId: number | undefined;
    cubicleBarcode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    inspectionLotId: number | undefined;
    inspectionLotNo: string | undefined;
    productCode: string | undefined;
    lineItemNo: string | undefined;
    processOrderMaterialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    batchNo: string | undefined;
    sapBatchNumber: string | undefined;
    qty: number | undefined;
    unitOfMeasurement: string | undefined;
    unitOfMeasurementId: number | undefined;
    expiryDate: string | undefined;
    retestDate: string | undefined;
    arNo: string | undefined;
    isAssigned: boolean;
    tenantId: number | undefined;
    statusId: number | undefined;
    isReservationNo: boolean;
    id: number;
}

export class CubicleAssignmentDto implements ICubicleAssignmentDto {
    groupId: string | undefined;
    productCode: string | undefined;
    tenantId: number | undefined;
    cubicleAssignmentDate: moment.Moment;
    isSampling: boolean;
    cubicleAssignmentDetails: CubicleAssignmentDetailsDto[];
    id: number;

    constructor(data?: ICubicleAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cubicleAssignmentDetails = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.productCode = _data["productCode"];
            this.tenantId = _data["tenantId"];
            this.cubicleAssignmentDate = _data["cubicleAssignmentDate"] ? moment(_data["cubicleAssignmentDate"].toString()) : <any>undefined;
            this.isSampling = _data["isSampling"];
            if (Array.isArray(_data["cubicleAssignmentDetails"])) {
                this.cubicleAssignmentDetails = [] as any;
                for (let item of _data["cubicleAssignmentDetails"])
                    this.cubicleAssignmentDetails.push(CubicleAssignmentDetailsDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["productCode"] = this.productCode;
        data["tenantId"] = this.tenantId;
        data["cubicleAssignmentDate"] = this.cubicleAssignmentDate ? this.cubicleAssignmentDate.toISOString() : <any>undefined;
        data["isSampling"] = this.isSampling;
        if (Array.isArray(this.cubicleAssignmentDetails)) {
            data["cubicleAssignmentDetails"] = [];
            for (let item of this.cubicleAssignmentDetails)
                data["cubicleAssignmentDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentDto {
    groupId: string | undefined;
    productCode: string | undefined;
    tenantId: number | undefined;
    cubicleAssignmentDate: moment.Moment;
    isSampling: boolean;
    cubicleAssignmentDetails: CubicleAssignmentDetailsDto[];
    id: number;
}

export class CubicleAssignmentListDto implements ICubicleAssignmentListDto {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    inspectionLotId: number | undefined;
    inspectionLotNo: string | undefined;
    groupStatus: string | undefined;
    groupStatusId: number | undefined;
    groupCode: string | undefined;
    subPlantId: number | undefined;
    id: number;

    constructor(data?: ICubicleAssignmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.inspectionLotNo = _data["inspectionLotNo"];
            this.groupStatus = _data["groupStatus"];
            this.groupStatusId = _data["groupStatusId"];
            this.groupCode = _data["groupCode"];
            this.subPlantId = _data["subPlantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["inspectionLotId"] = this.inspectionLotId;
        data["inspectionLotNo"] = this.inspectionLotNo;
        data["groupStatus"] = this.groupStatus;
        data["groupStatusId"] = this.groupStatusId;
        data["groupCode"] = this.groupCode;
        data["subPlantId"] = this.subPlantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentListDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentListDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentListDto {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    inspectionLotId: number | undefined;
    inspectionLotNo: string | undefined;
    groupStatus: string | undefined;
    groupStatusId: number | undefined;
    groupCode: string | undefined;
    subPlantId: number | undefined;
    id: number;
}

export class CubicleAssignmentListDtoPagedResultDto implements ICubicleAssignmentListDtoPagedResultDto {
    totalCount: number;
    items: CubicleAssignmentListDto[] | undefined;

    constructor(data?: ICubicleAssignmentListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CubicleAssignmentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CubicleAssignmentListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CubicleAssignmentListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentListDtoPagedResultDto {
    totalCount: number;
    items: CubicleAssignmentListDto[] | undefined;
}

export class CreateCubicleAssignmentDto implements ICreateCubicleAssignmentDto {
    groupId: string | undefined;
    productCode: string | undefined;
    tenantId: number | undefined;
    isSampling: boolean;
    cubicleAssignmentDate: moment.Moment;
    cubicleAssignmentDetails: CubicleAssignmentDetailsDto[] | undefined;

    constructor(data?: ICreateCubicleAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.productCode = _data["productCode"];
            this.tenantId = _data["tenantId"];
            this.isSampling = _data["isSampling"];
            this.cubicleAssignmentDate = _data["cubicleAssignmentDate"] ? moment(_data["cubicleAssignmentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["cubicleAssignmentDetails"])) {
                this.cubicleAssignmentDetails = [] as any;
                for (let item of _data["cubicleAssignmentDetails"])
                    this.cubicleAssignmentDetails.push(CubicleAssignmentDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCubicleAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCubicleAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["productCode"] = this.productCode;
        data["tenantId"] = this.tenantId;
        data["isSampling"] = this.isSampling;
        data["cubicleAssignmentDate"] = this.cubicleAssignmentDate ? this.cubicleAssignmentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.cubicleAssignmentDetails)) {
            data["cubicleAssignmentDetails"] = [];
            for (let item of this.cubicleAssignmentDetails)
                data["cubicleAssignmentDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateCubicleAssignmentDto {
        const json = this.toJSON();
        let result = new CreateCubicleAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCubicleAssignmentDto {
    groupId: string | undefined;
    productCode: string | undefined;
    tenantId: number | undefined;
    isSampling: boolean;
    cubicleAssignmentDate: moment.Moment;
    cubicleAssignmentDetails: CubicleAssignmentDetailsDto[] | undefined;
}

export class CreateCubicleAssignmentsDto implements ICreateCubicleAssignmentsDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    equipmentBarcodeId: number;

    constructor(data?: ICreateCubicleAssignmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.equipmentBarcodeId = _data["equipmentBarcodeId"];
        }
    }

    static fromJS(data: any): CreateCubicleAssignmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCubicleAssignmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["equipmentBarcodeId"] = this.equipmentBarcodeId;
        return data; 
    }

    clone(): CreateCubicleAssignmentsDto {
        const json = this.toJSON();
        let result = new CreateCubicleAssignmentsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCubicleAssignmentsDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    equipmentBarcodeId: number;
}

export class CubicleAssignmentsDto implements ICubicleAssignmentsDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    equipmentBarcodeId: number;
    batchNo: string | undefined;
    lotNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    equipmentBarcode: string | undefined;
    equipmentType: string | undefined;
    status: boolean;
    id: number;

    constructor(data?: ICubicleAssignmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.equipmentBarcodeId = _data["equipmentBarcodeId"];
            this.batchNo = _data["batchNo"];
            this.lotNo = _data["lotNo"];
            this.productName = _data["productName"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.equipmentBarcode = _data["equipmentBarcode"];
            this.equipmentType = _data["equipmentType"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["equipmentBarcodeId"] = this.equipmentBarcodeId;
        data["batchNo"] = this.batchNo;
        data["lotNo"] = this.lotNo;
        data["productName"] = this.productName;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["equipmentBarcode"] = this.equipmentBarcode;
        data["equipmentType"] = this.equipmentType;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentsDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentsDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentsDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    equipmentBarcodeId: number;
    batchNo: string | undefined;
    lotNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    equipmentBarcode: string | undefined;
    equipmentType: string | undefined;
    status: boolean;
    id: number;
}

export class CubicleAssignmentsListDto implements ICubicleAssignmentsListDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleCode: string | undefined;
    equipmentBarcodeId: number;
    equipmentCode: string | undefined;
    batchNo: string | undefined;
    lotNo: string | undefined;
    status: boolean;
    id: number;

    constructor(data?: ICubicleAssignmentsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleCode = _data["cubicleCode"];
            this.equipmentBarcodeId = _data["equipmentBarcodeId"];
            this.equipmentCode = _data["equipmentCode"];
            this.batchNo = _data["batchNo"];
            this.lotNo = _data["lotNo"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignmentsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleCode"] = this.cubicleCode;
        data["equipmentBarcodeId"] = this.equipmentBarcodeId;
        data["equipmentCode"] = this.equipmentCode;
        data["batchNo"] = this.batchNo;
        data["lotNo"] = this.lotNo;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignmentsListDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentsListDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentsListDto {
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleCode: string | undefined;
    equipmentBarcodeId: number;
    equipmentCode: string | undefined;
    batchNo: string | undefined;
    lotNo: string | undefined;
    status: boolean;
    id: number;
}

export class CubicleAssignmentsListDtoPagedResultDto implements ICubicleAssignmentsListDtoPagedResultDto {
    totalCount: number;
    items: CubicleAssignmentsListDto[] | undefined;

    constructor(data?: ICubicleAssignmentsListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CubicleAssignmentsListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CubicleAssignmentsListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignmentsListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CubicleAssignmentsListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CubicleAssignmentsListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignmentsListDtoPagedResultDto {
    totalCount: number;
    items: CubicleAssignmentsListDto[] | undefined;
}

export class CreateCubicleCleaningTransactionDto implements ICreateCubicleCleaningTransactionDto {
    cleaningDate: moment.Moment | undefined;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    remark: string | undefined;
    doneBy: string | undefined;
    id: number;

    constructor(data?: ICreateCubicleCleaningTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.typeId = _data["typeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            this.remark = _data["remark"];
            this.doneBy = _data["doneBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCubicleCleaningTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCubicleCleaningTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["typeId"] = this.typeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        data["remark"] = this.remark;
        data["doneBy"] = this.doneBy;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateCubicleCleaningTransactionDto {
        const json = this.toJSON();
        let result = new CreateCubicleCleaningTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCubicleCleaningTransactionDto {
    cleaningDate: moment.Moment | undefined;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    remark: string | undefined;
    doneBy: string | undefined;
    id: number;
}

export class CubicleCleaningTransactionDto implements ICubicleCleaningTransactionDto {
    cleaningDate: moment.Moment;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    cubicleCleaningCheckpoints: CheckpointDto[] | undefined;
    isUncleaned: boolean;
    isVerified: boolean;
    canApproved: boolean;
    cleanerName: string | undefined;
    creatorName: string | undefined;
    doneBy: string | undefined;
    isInValidTransaction: boolean;
    isRejected: boolean;
    remark: string | undefined;
    id: number;

    constructor(data?: ICubicleCleaningTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.typeId = _data["typeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            if (Array.isArray(_data["cubicleCleaningCheckpoints"])) {
                this.cubicleCleaningCheckpoints = [] as any;
                for (let item of _data["cubicleCleaningCheckpoints"])
                    this.cubicleCleaningCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isUncleaned = _data["isUncleaned"];
            this.isVerified = _data["isVerified"];
            this.canApproved = _data["canApproved"];
            this.cleanerName = _data["cleanerName"];
            this.creatorName = _data["creatorName"];
            this.doneBy = _data["doneBy"];
            this.isInValidTransaction = _data["isInValidTransaction"];
            this.isRejected = _data["isRejected"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleCleaningTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleCleaningTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["typeId"] = this.typeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        if (Array.isArray(this.cubicleCleaningCheckpoints)) {
            data["cubicleCleaningCheckpoints"] = [];
            for (let item of this.cubicleCleaningCheckpoints)
                data["cubicleCleaningCheckpoints"].push(item.toJSON());
        }
        data["isUncleaned"] = this.isUncleaned;
        data["isVerified"] = this.isVerified;
        data["canApproved"] = this.canApproved;
        data["cleanerName"] = this.cleanerName;
        data["creatorName"] = this.creatorName;
        data["doneBy"] = this.doneBy;
        data["isInValidTransaction"] = this.isInValidTransaction;
        data["isRejected"] = this.isRejected;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleCleaningTransactionDto {
        const json = this.toJSON();
        let result = new CubicleCleaningTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleCleaningTransactionDto {
    cleaningDate: moment.Moment;
    cubicleId: number;
    typeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    cubicleCleaningCheckpoints: CheckpointDto[] | undefined;
    isUncleaned: boolean;
    isVerified: boolean;
    canApproved: boolean;
    cleanerName: string | undefined;
    creatorName: string | undefined;
    doneBy: string | undefined;
    isInValidTransaction: boolean;
    isRejected: boolean;
    remark: string | undefined;
    id: number;
}

export class DepartmentDto implements IDepartmentDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentCode = _data["departmentCode"];
            this.departmentName = _data["departmentName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentCode"] = this.departmentCode;
        data["departmentName"] = this.departmentName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): DepartmentDto {
        const json = this.toJSON();
        let result = new DepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class DepartmentListDto implements IDepartmentListDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string | undefined;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IDepartmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentCode = _data["departmentCode"];
            this.departmentName = _data["departmentName"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DepartmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentCode"] = this.departmentCode;
        data["departmentName"] = this.departmentName;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): DepartmentListDto {
        const json = this.toJSON();
        let result = new DepartmentListDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentListDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string | undefined;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class DepartmentListDtoPagedResultDto implements IDepartmentListDtoPagedResultDto {
    totalCount: number;
    items: DepartmentListDto[] | undefined;

    constructor(data?: IDepartmentListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepartmentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DepartmentListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DepartmentListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentListDtoPagedResultDto {
    totalCount: number;
    items: DepartmentListDto[] | undefined;
}

export class CreateDepartmentDto implements ICreateDepartmentDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.departmentCode = _data["departmentCode"];
            this.departmentName = _data["departmentName"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["departmentCode"] = this.departmentCode;
        data["departmentName"] = this.departmentName;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateDepartmentDto {
        const json = this.toJSON();
        let result = new CreateDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDepartmentDto {
    subPlantId: number;
    departmentCode: string | undefined;
    departmentName: string;
    isActive: boolean;
    description: string | undefined;
}

export class DestructionDto implements IDestructionDto {
    movementType: string | undefined;
    containerId: number;
    materialContainerBarCode: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    arNo: string | undefined;
    quantity: number | undefined;
    unitOfMeasurement: string | undefined;
    transactionId: string | undefined;
    isSAPPosted: boolean | undefined;
    id: number;

    constructor(data?: IDestructionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementType = _data["movementType"];
            this.containerId = _data["containerId"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.arNo = _data["arNo"];
            this.quantity = _data["quantity"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.transactionId = _data["transactionId"];
            this.isSAPPosted = _data["isSAPPosted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DestructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DestructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementType"] = this.movementType;
        data["containerId"] = this.containerId;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["arNo"] = this.arNo;
        data["quantity"] = this.quantity;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["transactionId"] = this.transactionId;
        data["isSAPPosted"] = this.isSAPPosted;
        data["id"] = this.id;
        return data; 
    }

    clone(): DestructionDto {
        const json = this.toJSON();
        let result = new DestructionDto();
        result.init(json);
        return result;
    }
}

export interface IDestructionDto {
    movementType: string | undefined;
    containerId: number;
    materialContainerBarCode: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    arNo: string | undefined;
    quantity: number | undefined;
    unitOfMeasurement: string | undefined;
    transactionId: string | undefined;
    isSAPPosted: boolean | undefined;
    id: number;
}

export class HTTPResponseDto implements IHTTPResponseDto {
    result: number;
    error: string | undefined;
    resultObject: any | undefined;
    status: string | undefined;

    constructor(data?: IHTTPResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.error = _data["error"];
            this.resultObject = _data["resultObject"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): HTTPResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new HTTPResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["error"] = this.error;
        data["resultObject"] = this.resultObject;
        data["status"] = this.status;
        return data; 
    }

    clone(): HTTPResponseDto {
        const json = this.toJSON();
        let result = new HTTPResponseDto();
        result.init(json);
        return result;
    }
}

export interface IHTTPResponseDto {
    result: number;
    error: string | undefined;
    resultObject: any | undefined;
    status: string | undefined;
}

export class DeviceDto implements IDeviceDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.deviceId = _data["deviceId"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.serialNo = _data["serialNo"];
            this.ipAddress = _data["ipAddress"];
            this.port = _data["port"];
            this.departmentId = _data["departmentId"];
            this.areaId = _data["areaId"];
            this.cubicleId = _data["cubicleId"];
            this.modeId = _data["modeId"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["deviceId"] = this.deviceId;
        data["deviceTypeId"] = this.deviceTypeId;
        data["make"] = this.make;
        data["model"] = this.model;
        data["serialNo"] = this.serialNo;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["departmentId"] = this.departmentId;
        data["areaId"] = this.areaId;
        data["cubicleId"] = this.cubicleId;
        data["modeId"] = this.modeId;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): DeviceDto {
        const json = this.toJSON();
        let result = new DeviceDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class DeviceListDto implements IDeviceListDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    isActive: boolean;
    userEnteredPlantId: string | undefined;
    userEnteredDeviceType: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IDeviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.deviceId = _data["deviceId"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.isActive = _data["isActive"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredDeviceType = _data["userEnteredDeviceType"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["deviceId"] = this.deviceId;
        data["deviceTypeId"] = this.deviceTypeId;
        data["make"] = this.make;
        data["model"] = this.model;
        data["isActive"] = this.isActive;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredDeviceType"] = this.userEnteredDeviceType;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): DeviceListDto {
        const json = this.toJSON();
        let result = new DeviceListDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceListDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    isActive: boolean;
    userEnteredPlantId: string | undefined;
    userEnteredDeviceType: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class DeviceListDtoPagedResultDto implements IDeviceListDtoPagedResultDto {
    totalCount: number;
    items: DeviceListDto[] | undefined;

    constructor(data?: IDeviceListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DeviceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DeviceListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DeviceListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceListDtoPagedResultDto {
    totalCount: number;
    items: DeviceListDto[] | undefined;
}

export class CreateDeviceDto implements ICreateDeviceDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;

    constructor(data?: ICreateDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.deviceId = _data["deviceId"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.serialNo = _data["serialNo"];
            this.ipAddress = _data["ipAddress"];
            this.port = _data["port"];
            this.departmentId = _data["departmentId"];
            this.areaId = _data["areaId"];
            this.cubicleId = _data["cubicleId"];
            this.modeId = _data["modeId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["deviceId"] = this.deviceId;
        data["deviceTypeId"] = this.deviceTypeId;
        data["make"] = this.make;
        data["model"] = this.model;
        data["serialNo"] = this.serialNo;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["departmentId"] = this.departmentId;
        data["areaId"] = this.areaId;
        data["cubicleId"] = this.cubicleId;
        data["modeId"] = this.modeId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateDeviceDto {
        const json = this.toJSON();
        let result = new CreateDeviceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDeviceDto {
    subPlantId: number;
    deviceId: string | undefined;
    deviceTypeId: number | undefined;
    make: string | undefined;
    model: string | undefined;
    serialNo: string | undefined;
    ipAddress: string | undefined;
    port: number | undefined;
    departmentId: number | undefined;
    areaId: number | undefined;
    cubicleId: number | undefined;
    modeId: number | undefined;
    isActive: boolean;
}

export class CubicleBarcodeDto implements ICubicleBarcodeDto {
    value: string | undefined;
    plantId: number | undefined;
    areaCode: string | undefined;
    id: number;

    constructor(data?: ICubicleBarcodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.plantId = _data["plantId"];
            this.areaCode = _data["areaCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleBarcodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleBarcodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["plantId"] = this.plantId;
        data["areaCode"] = this.areaCode;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleBarcodeDto {
        const json = this.toJSON();
        let result = new CubicleBarcodeDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleBarcodeDto {
    value: string | undefined;
    plantId: number | undefined;
    areaCode: string | undefined;
    id: number;
}

export class EquipmentCleaningBarcodeDto implements IEquipmentCleaningBarcodeDto {
    equipmentBarcode: string | undefined;
    equipmentId: number;
    areaId: number | undefined;
    areaBarcode: string | undefined;
    cubicleId: number | undefined;
    cubicleBarcode: string | undefined;
    equipmentTypeId: number;
    plantId: number | undefined;
    status: string | undefined;
    id: number;

    constructor(data?: IEquipmentCleaningBarcodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentBarcode = _data["equipmentBarcode"];
            this.equipmentId = _data["equipmentId"];
            this.areaId = _data["areaId"];
            this.areaBarcode = _data["areaBarcode"];
            this.cubicleId = _data["cubicleId"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.equipmentTypeId = _data["equipmentTypeId"];
            this.plantId = _data["plantId"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentCleaningBarcodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentCleaningBarcodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentBarcode"] = this.equipmentBarcode;
        data["equipmentId"] = this.equipmentId;
        data["areaId"] = this.areaId;
        data["areaBarcode"] = this.areaBarcode;
        data["cubicleId"] = this.cubicleId;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["equipmentTypeId"] = this.equipmentTypeId;
        data["plantId"] = this.plantId;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentCleaningBarcodeDto {
        const json = this.toJSON();
        let result = new EquipmentCleaningBarcodeDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentCleaningBarcodeDto {
    equipmentBarcode: string | undefined;
    equipmentId: number;
    areaId: number | undefined;
    areaBarcode: string | undefined;
    cubicleId: number | undefined;
    cubicleBarcode: string | undefined;
    equipmentTypeId: number;
    plantId: number | undefined;
    status: string | undefined;
    id: number;
}

export class MaterialDispensingInternalDto implements IMaterialDispensingInternalDto {
    conversionUOMName: string | undefined;
    denominator: number | undefined;
    numerator: number | undefined;
    uomId: number | undefined;
    unitOfMeasurementTypeId: number | undefined;
    uomType: string | undefined;
    isPackUOM: boolean;
    doneBy: number | undefined;
    checkedById: number | undefined;

    constructor(data?: IMaterialDispensingInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversionUOMName = _data["conversionUOMName"];
            this.denominator = _data["denominator"];
            this.numerator = _data["numerator"];
            this.uomId = _data["uomId"];
            this.unitOfMeasurementTypeId = _data["unitOfMeasurementTypeId"];
            this.uomType = _data["uomType"];
            this.isPackUOM = _data["isPackUOM"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
        }
    }

    static fromJS(data: any): MaterialDispensingInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDispensingInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversionUOMName"] = this.conversionUOMName;
        data["denominator"] = this.denominator;
        data["numerator"] = this.numerator;
        data["uomId"] = this.uomId;
        data["unitOfMeasurementTypeId"] = this.unitOfMeasurementTypeId;
        data["uomType"] = this.uomType;
        data["isPackUOM"] = this.isPackUOM;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        return data; 
    }

    clone(): MaterialDispensingInternalDto {
        const json = this.toJSON();
        let result = new MaterialDispensingInternalDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDispensingInternalDto {
    conversionUOMName: string | undefined;
    denominator: number | undefined;
    numerator: number | undefined;
    uomId: number | undefined;
    unitOfMeasurementTypeId: number | undefined;
    uomType: string | undefined;
    isPackUOM: boolean;
    doneBy: number | undefined;
    checkedById: number | undefined;
}

export class DispensingUnitOfMeasurementDto implements IDispensingUnitOfMeasurementDto {
    id: number;
    unitOfMeasurement: string | undefined;

    constructor(data?: IDispensingUnitOfMeasurementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
        }
    }

    static fromJS(data: any): DispensingUnitOfMeasurementDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingUnitOfMeasurementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        return data; 
    }

    clone(): DispensingUnitOfMeasurementDto {
        const json = this.toJSON();
        let result = new DispensingUnitOfMeasurementDto();
        result.init(json);
        return result;
    }
}

export interface IDispensingUnitOfMeasurementDto {
    id: number;
    unitOfMeasurement: string | undefined;
}

export class ElogControlsDto implements IElogControlsDto {
    eLogId: number;
    controlID: number;
    controlLabel: string | undefined;
    controlType: string | undefined;
    controlDefaults: string | undefined;
    sequence: number;
    flagIsDefaultSql: boolean;
    dbFieldName: string | undefined;
    dbDataType: string | undefined;
    flagIsMandatory: boolean;
    isActive: boolean;
    id: number;

    constructor(data?: IElogControlsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eLogId = _data["eLogId"];
            this.controlID = _data["controlID"];
            this.controlLabel = _data["controlLabel"];
            this.controlType = _data["controlType"];
            this.controlDefaults = _data["controlDefaults"];
            this.sequence = _data["sequence"];
            this.flagIsDefaultSql = _data["flagIsDefaultSql"];
            this.dbFieldName = _data["dbFieldName"];
            this.dbDataType = _data["dbDataType"];
            this.flagIsMandatory = _data["flagIsMandatory"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ElogControlsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElogControlsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eLogId"] = this.eLogId;
        data["controlID"] = this.controlID;
        data["controlLabel"] = this.controlLabel;
        data["controlType"] = this.controlType;
        data["controlDefaults"] = this.controlDefaults;
        data["sequence"] = this.sequence;
        data["flagIsDefaultSql"] = this.flagIsDefaultSql;
        data["dbFieldName"] = this.dbFieldName;
        data["dbDataType"] = this.dbDataType;
        data["flagIsMandatory"] = this.flagIsMandatory;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ElogControlsDto {
        const json = this.toJSON();
        let result = new ElogControlsDto();
        result.init(json);
        return result;
    }
}

export interface IElogControlsDto {
    eLogId: number;
    controlID: number;
    controlLabel: string | undefined;
    controlType: string | undefined;
    controlDefaults: string | undefined;
    sequence: number;
    flagIsDefaultSql: boolean;
    dbFieldName: string | undefined;
    dbDataType: string | undefined;
    flagIsMandatory: boolean;
    isActive: boolean;
    id: number;
}

export class ElogControlsDtoPagedResultDto implements IElogControlsDtoPagedResultDto {
    totalCount: number;
    items: ElogControlsDto[] | undefined;

    constructor(data?: IElogControlsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ElogControlsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ElogControlsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElogControlsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ElogControlsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ElogControlsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IElogControlsDtoPagedResultDto {
    totalCount: number;
    items: ElogControlsDto[] | undefined;
}

export class EquipmentDto implements IEquipmentDto {
    plantId: number;
    slocId: number;
    equipmentTypeId: number;
    equipmentCode: string;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    cleanHoldTime: number;
    id: number;

    constructor(data?: IEquipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.slocId = _data["slocId"];
            this.equipmentTypeId = _data["equipmentTypeId"];
            this.equipmentCode = _data["equipmentCode"];
            this.name = _data["name"];
            this.alias = _data["alias"];
            this.equipmentModel = _data["equipmentModel"];
            this.description = _data["description"];
            this.isPortable = _data["isPortable"];
            this.dateOfProcurement = _data["dateOfProcurement"] ? moment(_data["dateOfProcurement"].toString()) : <any>undefined;
            this.dateOfInstallation = _data["dateOfInstallation"] ? moment(_data["dateOfInstallation"].toString()) : <any>undefined;
            this.isMaintenanceRequired = _data["isMaintenanceRequired"];
            this.maintenanceScheduleDays = _data["maintenanceScheduleDays"];
            this.communicationType = _data["communicationType"];
            this.vendorName = _data["vendorName"];
            this.vendorDocumentNumber = _data["vendorDocumentNumber"];
            this.supportExpiresOn = _data["supportExpiresOn"] ? moment(_data["supportExpiresOn"].toString()) : <any>undefined;
            this.networkIPAddress = _data["networkIPAddress"];
            this.networkIPPort = _data["networkIPPort"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.cleanHoldTime = _data["cleanHoldTime"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["slocId"] = this.slocId;
        data["equipmentTypeId"] = this.equipmentTypeId;
        data["equipmentCode"] = this.equipmentCode;
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["equipmentModel"] = this.equipmentModel;
        data["description"] = this.description;
        data["isPortable"] = this.isPortable;
        data["dateOfProcurement"] = this.dateOfProcurement ? this.dateOfProcurement.toISOString() : <any>undefined;
        data["dateOfInstallation"] = this.dateOfInstallation ? this.dateOfInstallation.toISOString() : <any>undefined;
        data["isMaintenanceRequired"] = this.isMaintenanceRequired;
        data["maintenanceScheduleDays"] = this.maintenanceScheduleDays;
        data["communicationType"] = this.communicationType;
        data["vendorName"] = this.vendorName;
        data["vendorDocumentNumber"] = this.vendorDocumentNumber;
        data["supportExpiresOn"] = this.supportExpiresOn ? this.supportExpiresOn.toISOString() : <any>undefined;
        data["networkIPAddress"] = this.networkIPAddress;
        data["networkIPPort"] = this.networkIPPort;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["cleanHoldTime"] = this.cleanHoldTime;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentDto {
        const json = this.toJSON();
        let result = new EquipmentDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentDto {
    plantId: number;
    slocId: number;
    equipmentTypeId: number;
    equipmentCode: string;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    cleanHoldTime: number;
    id: number;
}

export class EquipmentListDto implements IEquipmentListDto {
    plantId: number;
    userEnteredPlantId: string | undefined;
    userEnteredEquipment: string | undefined;
    slocId: number | undefined;
    equipmentTypeId: number | undefined;
    equipmentCode: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IEquipmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredEquipment = _data["userEnteredEquipment"];
            this.slocId = _data["slocId"];
            this.equipmentTypeId = _data["equipmentTypeId"];
            this.equipmentCode = _data["equipmentCode"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredEquipment"] = this.userEnteredEquipment;
        data["slocId"] = this.slocId;
        data["equipmentTypeId"] = this.equipmentTypeId;
        data["equipmentCode"] = this.equipmentCode;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentListDto {
        const json = this.toJSON();
        let result = new EquipmentListDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentListDto {
    plantId: number;
    userEnteredPlantId: string | undefined;
    userEnteredEquipment: string | undefined;
    slocId: number | undefined;
    equipmentTypeId: number | undefined;
    equipmentCode: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class EquipmentListDtoPagedResultDto implements IEquipmentListDtoPagedResultDto {
    totalCount: number;
    items: EquipmentListDto[] | undefined;

    constructor(data?: IEquipmentListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EquipmentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EquipmentListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EquipmentListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EquipmentListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentListDtoPagedResultDto {
    totalCount: number;
    items: EquipmentListDto[] | undefined;
}

export class CreateEquipmentDto implements ICreateEquipmentDto {
    plantId: number;
    slocId: number;
    equipmentTypeId: number;
    equipmentCode: string;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    cleanHoldTime: number;

    constructor(data?: ICreateEquipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.slocId = _data["slocId"];
            this.equipmentTypeId = _data["equipmentTypeId"];
            this.equipmentCode = _data["equipmentCode"];
            this.name = _data["name"];
            this.alias = _data["alias"];
            this.equipmentModel = _data["equipmentModel"];
            this.description = _data["description"];
            this.isPortable = _data["isPortable"];
            this.dateOfProcurement = _data["dateOfProcurement"] ? moment(_data["dateOfProcurement"].toString()) : <any>undefined;
            this.dateOfInstallation = _data["dateOfInstallation"] ? moment(_data["dateOfInstallation"].toString()) : <any>undefined;
            this.isMaintenanceRequired = _data["isMaintenanceRequired"];
            this.maintenanceScheduleDays = _data["maintenanceScheduleDays"];
            this.communicationType = _data["communicationType"];
            this.vendorName = _data["vendorName"];
            this.vendorDocumentNumber = _data["vendorDocumentNumber"];
            this.supportExpiresOn = _data["supportExpiresOn"] ? moment(_data["supportExpiresOn"].toString()) : <any>undefined;
            this.networkIPAddress = _data["networkIPAddress"];
            this.networkIPPort = _data["networkIPPort"];
            this.isActive = _data["isActive"];
            this.cleanHoldTime = _data["cleanHoldTime"];
        }
    }

    static fromJS(data: any): CreateEquipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["slocId"] = this.slocId;
        data["equipmentTypeId"] = this.equipmentTypeId;
        data["equipmentCode"] = this.equipmentCode;
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["equipmentModel"] = this.equipmentModel;
        data["description"] = this.description;
        data["isPortable"] = this.isPortable;
        data["dateOfProcurement"] = this.dateOfProcurement ? this.dateOfProcurement.toISOString() : <any>undefined;
        data["dateOfInstallation"] = this.dateOfInstallation ? this.dateOfInstallation.toISOString() : <any>undefined;
        data["isMaintenanceRequired"] = this.isMaintenanceRequired;
        data["maintenanceScheduleDays"] = this.maintenanceScheduleDays;
        data["communicationType"] = this.communicationType;
        data["vendorName"] = this.vendorName;
        data["vendorDocumentNumber"] = this.vendorDocumentNumber;
        data["supportExpiresOn"] = this.supportExpiresOn ? this.supportExpiresOn.toISOString() : <any>undefined;
        data["networkIPAddress"] = this.networkIPAddress;
        data["networkIPPort"] = this.networkIPPort;
        data["isActive"] = this.isActive;
        data["cleanHoldTime"] = this.cleanHoldTime;
        return data; 
    }

    clone(): CreateEquipmentDto {
        const json = this.toJSON();
        let result = new CreateEquipmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEquipmentDto {
    plantId: number;
    slocId: number;
    equipmentTypeId: number;
    equipmentCode: string;
    name: string | undefined;
    alias: string | undefined;
    equipmentModel: string | undefined;
    description: string | undefined;
    isPortable: boolean | undefined;
    dateOfProcurement: moment.Moment | undefined;
    dateOfInstallation: moment.Moment | undefined;
    isMaintenanceRequired: boolean | undefined;
    maintenanceScheduleDays: number | undefined;
    communicationType: number | undefined;
    vendorName: string | undefined;
    vendorDocumentNumber: string | undefined;
    supportExpiresOn: moment.Moment | undefined;
    networkIPAddress: string | undefined;
    networkIPPort: number | undefined;
    isActive: boolean;
    cleanHoldTime: number;
}

export class EquipmentNameDto implements IEquipmentNameDto {
    equipmentId: number;
    equipmentBarCode: string | undefined;
    equipmentName: string | undefined;
    isAssignedOrDeAssigned: boolean;
    isSampling: boolean;
    equipmentType: string | undefined;
    id: number;

    constructor(data?: IEquipmentNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentBarCode = _data["equipmentBarCode"];
            this.equipmentName = _data["equipmentName"];
            this.isAssignedOrDeAssigned = _data["isAssignedOrDeAssigned"];
            this.isSampling = _data["isSampling"];
            this.equipmentType = _data["equipmentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentBarCode"] = this.equipmentBarCode;
        data["equipmentName"] = this.equipmentName;
        data["isAssignedOrDeAssigned"] = this.isAssignedOrDeAssigned;
        data["isSampling"] = this.isSampling;
        data["equipmentType"] = this.equipmentType;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentNameDto {
        const json = this.toJSON();
        let result = new EquipmentNameDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentNameDto {
    equipmentId: number;
    equipmentBarCode: string | undefined;
    equipmentName: string | undefined;
    isAssignedOrDeAssigned: boolean;
    isSampling: boolean;
    equipmentType: string | undefined;
    id: number;
}

export class EquipmentAssignmentDto implements IEquipmentAssignmentDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    productCode: string | undefined;
    productDescription: string | undefined;
    batchNumber: string | undefined;
    plantId: number;
    cubicleAssignmentHeaderId: number | undefined;
    lstEquipments: EquipmentNameDto[] | undefined;
    fixedEquipments: EquipmentNameDto[] | undefined;
    sapBatchNo: string | undefined;
    isReservationNo: boolean;

    constructor(data?: IEquipmentAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.batchNumber = _data["batchNumber"];
            this.plantId = _data["plantId"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            if (Array.isArray(_data["lstEquipments"])) {
                this.lstEquipments = [] as any;
                for (let item of _data["lstEquipments"])
                    this.lstEquipments.push(EquipmentNameDto.fromJS(item));
            }
            if (Array.isArray(_data["fixedEquipments"])) {
                this.fixedEquipments = [] as any;
                for (let item of _data["fixedEquipments"])
                    this.fixedEquipments.push(EquipmentNameDto.fromJS(item));
            }
            this.sapBatchNo = _data["sapBatchNo"];
            this.isReservationNo = _data["isReservationNo"];
        }
    }

    static fromJS(data: any): EquipmentAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["batchNumber"] = this.batchNumber;
        data["plantId"] = this.plantId;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        if (Array.isArray(this.lstEquipments)) {
            data["lstEquipments"] = [];
            for (let item of this.lstEquipments)
                data["lstEquipments"].push(item.toJSON());
        }
        if (Array.isArray(this.fixedEquipments)) {
            data["fixedEquipments"] = [];
            for (let item of this.fixedEquipments)
                data["fixedEquipments"].push(item.toJSON());
        }
        data["sapBatchNo"] = this.sapBatchNo;
        data["isReservationNo"] = this.isReservationNo;
        return data; 
    }

    clone(): EquipmentAssignmentDto {
        const json = this.toJSON();
        let result = new EquipmentAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentAssignmentDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    productCode: string | undefined;
    productDescription: string | undefined;
    batchNumber: string | undefined;
    plantId: number;
    cubicleAssignmentHeaderId: number | undefined;
    lstEquipments: EquipmentNameDto[] | undefined;
    fixedEquipments: EquipmentNameDto[] | undefined;
    sapBatchNo: string | undefined;
    isReservationNo: boolean;
}

export class CreateEquipmentCleaningTransactionDto implements ICreateEquipmentCleaningTransactionDto {
    cleaningDate: moment.Moment | undefined;
    equipmentId: number;
    cubicleId: number | undefined;
    areaId: number | undefined;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    doneBy: string | undefined;
    remark: string | undefined;
    id: number;

    constructor(data?: ICreateEquipmentCleaningTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.equipmentId = _data["equipmentId"];
            this.cubicleId = _data["cubicleId"];
            this.areaId = _data["areaId"];
            this.cleaningTypeId = _data["cleaningTypeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            this.doneBy = _data["doneBy"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateEquipmentCleaningTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentCleaningTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["equipmentId"] = this.equipmentId;
        data["cubicleId"] = this.cubicleId;
        data["areaId"] = this.areaId;
        data["cleaningTypeId"] = this.cleaningTypeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        data["doneBy"] = this.doneBy;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateEquipmentCleaningTransactionDto {
        const json = this.toJSON();
        let result = new CreateEquipmentCleaningTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEquipmentCleaningTransactionDto {
    cleaningDate: moment.Moment | undefined;
    equipmentId: number;
    cubicleId: number | undefined;
    areaId: number | undefined;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment | undefined;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    doneBy: string | undefined;
    remark: string | undefined;
    id: number;
}

export class EquipmentCleaningTransactionDto implements IEquipmentCleaningTransactionDto {
    cleaningDate: moment.Moment;
    equipmentId: number;
    cubicleId: number;
    areaId: number;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    remark: string | undefined;
    equipmentCleaningCheckpoints: CheckpointDto[] | undefined;
    isUncleaned: boolean;
    isVerified: boolean;
    isRejected: boolean;
    canApproved: boolean;
    cleanerName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    doneBy: string | undefined;
    id: number;

    constructor(data?: IEquipmentCleaningTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.equipmentId = _data["equipmentId"];
            this.cubicleId = _data["cubicleId"];
            this.areaId = _data["areaId"];
            this.cleaningTypeId = _data["cleaningTypeId"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.verifiedTime = _data["verifiedTime"] ? moment(_data["verifiedTime"].toString()) : <any>undefined;
            this.cleanerId = _data["cleanerId"];
            this.verifierId = _data["verifierId"];
            this.remark = _data["remark"];
            if (Array.isArray(_data["equipmentCleaningCheckpoints"])) {
                this.equipmentCleaningCheckpoints = [] as any;
                for (let item of _data["equipmentCleaningCheckpoints"])
                    this.equipmentCleaningCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isUncleaned = _data["isUncleaned"];
            this.isVerified = _data["isVerified"];
            this.isRejected = _data["isRejected"];
            this.canApproved = _data["canApproved"];
            this.cleanerName = _data["cleanerName"];
            this.creatorName = _data["creatorName"];
            this.isInValidTransaction = _data["isInValidTransaction"];
            this.doneBy = _data["doneBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentCleaningTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentCleaningTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["equipmentId"] = this.equipmentId;
        data["cubicleId"] = this.cubicleId;
        data["areaId"] = this.areaId;
        data["cleaningTypeId"] = this.cleaningTypeId;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["verifiedTime"] = this.verifiedTime ? this.verifiedTime.toISOString() : <any>undefined;
        data["cleanerId"] = this.cleanerId;
        data["verifierId"] = this.verifierId;
        data["remark"] = this.remark;
        if (Array.isArray(this.equipmentCleaningCheckpoints)) {
            data["equipmentCleaningCheckpoints"] = [];
            for (let item of this.equipmentCleaningCheckpoints)
                data["equipmentCleaningCheckpoints"].push(item.toJSON());
        }
        data["isUncleaned"] = this.isUncleaned;
        data["isVerified"] = this.isVerified;
        data["isRejected"] = this.isRejected;
        data["canApproved"] = this.canApproved;
        data["cleanerName"] = this.cleanerName;
        data["creatorName"] = this.creatorName;
        data["isInValidTransaction"] = this.isInValidTransaction;
        data["doneBy"] = this.doneBy;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentCleaningTransactionDto {
        const json = this.toJSON();
        let result = new EquipmentCleaningTransactionDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentCleaningTransactionDto {
    cleaningDate: moment.Moment;
    equipmentId: number;
    cubicleId: number;
    areaId: number;
    cleaningTypeId: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    verifiedTime: moment.Moment | undefined;
    cleanerId: number;
    verifierId: number | undefined;
    remark: string | undefined;
    equipmentCleaningCheckpoints: CheckpointDto[] | undefined;
    isUncleaned: boolean;
    isVerified: boolean;
    isRejected: boolean;
    canApproved: boolean;
    cleanerName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    doneBy: string | undefined;
    id: number;
}

export class CreateEquipmentUsageLogDto implements ICreateEquipmentUsageLogDto {
    activityId: number;
    operatorName: string;
    equipmentType: string;
    equipmentBracodeId: number;
    processBarcodeId: number;
    remarks: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    isActive: boolean;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    equipmentUsageLogLists: CheckpointDto[] | undefined;

    constructor(data?: ICreateEquipmentUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.operatorName = _data["operatorName"];
            this.equipmentType = _data["equipmentType"];
            this.equipmentBracodeId = _data["equipmentBracodeId"];
            this.processBarcodeId = _data["processBarcodeId"];
            this.remarks = _data["remarks"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.approvedBy = _data["approvedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["equipmentUsageLogLists"])) {
                this.equipmentUsageLogLists = [] as any;
                for (let item of _data["equipmentUsageLogLists"])
                    this.equipmentUsageLogLists.push(CheckpointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEquipmentUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["operatorName"] = this.operatorName;
        data["equipmentType"] = this.equipmentType;
        data["equipmentBracodeId"] = this.equipmentBracodeId;
        data["processBarcodeId"] = this.processBarcodeId;
        data["remarks"] = this.remarks;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["approvedBy"] = this.approvedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.equipmentUsageLogLists)) {
            data["equipmentUsageLogLists"] = [];
            for (let item of this.equipmentUsageLogLists)
                data["equipmentUsageLogLists"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateEquipmentUsageLogDto {
        const json = this.toJSON();
        let result = new CreateEquipmentUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEquipmentUsageLogDto {
    activityId: number;
    operatorName: string;
    equipmentType: string;
    equipmentBracodeId: number;
    processBarcodeId: number;
    remarks: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    isActive: boolean;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    equipmentUsageLogLists: CheckpointDto[] | undefined;
}

export class EquipmentUsageLogDto implements IEquipmentUsageLogDto {
    activityId: number;
    operatorName: string;
    equipmentType: string;
    equipmentBracodeId: number;
    processBarcodeId: number;
    remarks: string;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    isActive: boolean;
    equipmentUsageLogLists: CheckpointDto[] | undefined;
    cubicalCode: string | undefined;
    equipmentCode: string | undefined;
    status: boolean;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IEquipmentUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.operatorName = _data["operatorName"];
            this.equipmentType = _data["equipmentType"];
            this.equipmentBracodeId = _data["equipmentBracodeId"];
            this.processBarcodeId = _data["processBarcodeId"];
            this.remarks = _data["remarks"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["equipmentUsageLogLists"])) {
                this.equipmentUsageLogLists = [] as any;
                for (let item of _data["equipmentUsageLogLists"])
                    this.equipmentUsageLogLists.push(CheckpointDto.fromJS(item));
            }
            this.cubicalCode = _data["cubicalCode"];
            this.equipmentCode = _data["equipmentCode"];
            this.status = _data["status"];
            this.approvedBy = _data["approvedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isApproved = _data["isApproved"];
            this.isRejected = _data["isRejected"];
            this.canApproved = _data["canApproved"];
            this.canVerified = _data["canVerified"];
            this.approvedByName = _data["approvedByName"];
            this.creatorName = _data["creatorName"];
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["operatorName"] = this.operatorName;
        data["equipmentType"] = this.equipmentType;
        data["equipmentBracodeId"] = this.equipmentBracodeId;
        data["processBarcodeId"] = this.processBarcodeId;
        data["remarks"] = this.remarks;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.equipmentUsageLogLists)) {
            data["equipmentUsageLogLists"] = [];
            for (let item of this.equipmentUsageLogLists)
                data["equipmentUsageLogLists"].push(item.toJSON());
        }
        data["cubicalCode"] = this.cubicalCode;
        data["equipmentCode"] = this.equipmentCode;
        data["status"] = this.status;
        data["approvedBy"] = this.approvedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isApproved"] = this.isApproved;
        data["isRejected"] = this.isRejected;
        data["canApproved"] = this.canApproved;
        data["canVerified"] = this.canVerified;
        data["approvedByName"] = this.approvedByName;
        data["creatorName"] = this.creatorName;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentUsageLogDto {
        const json = this.toJSON();
        let result = new EquipmentUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentUsageLogDto {
    activityId: number;
    operatorName: string;
    equipmentType: string;
    equipmentBracodeId: number;
    processBarcodeId: number;
    remarks: string;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    isActive: boolean;
    equipmentUsageLogLists: CheckpointDto[] | undefined;
    cubicalCode: string | undefined;
    equipmentCode: string | undefined;
    status: boolean;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    creatorUserId: number | undefined;
    id: number;
}

export class UpdateEquipmentUsageLogDto implements IUpdateEquipmentUsageLogDto {
    endTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    equipmentUsageLogLists: CheckpointDto[] | undefined;
    id: number;

    constructor(data?: IUpdateEquipmentUsageLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.approvedBy = _data["approvedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.isApproved = _data["isApproved"];
            this.isRejected = _data["isRejected"];
            if (Array.isArray(_data["equipmentUsageLogLists"])) {
                this.equipmentUsageLogLists = [] as any;
                for (let item of _data["equipmentUsageLogLists"])
                    this.equipmentUsageLogLists.push(CheckpointDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateEquipmentUsageLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEquipmentUsageLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["approvedBy"] = this.approvedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["isApproved"] = this.isApproved;
        data["isRejected"] = this.isRejected;
        if (Array.isArray(this.equipmentUsageLogLists)) {
            data["equipmentUsageLogLists"] = [];
            for (let item of this.equipmentUsageLogLists)
                data["equipmentUsageLogLists"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateEquipmentUsageLogDto {
        const json = this.toJSON();
        let result = new UpdateEquipmentUsageLogDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEquipmentUsageLogDto {
    endTime: moment.Moment | undefined;
    remarks: string | undefined;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    isApproved: boolean;
    isRejected: boolean;
    equipmentUsageLogLists: CheckpointDto[] | undefined;
    id: number;
}

export class EquipmentUsageLogListDto implements IEquipmentUsageLogListDto {
    activityId: number | undefined;
    activityName: string | undefined;
    operatorName: string | undefined;
    equipmentType: string | undefined;
    equipmentBracodeId: number | undefined;
    equipmentBracodeName: string | undefined;
    processBarcodeId: number | undefined;
    processBarcodeName: string | undefined;
    startTime: moment.Moment | undefined;
    endtTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    id: number;

    constructor(data?: IEquipmentUsageLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.operatorName = _data["operatorName"];
            this.equipmentType = _data["equipmentType"];
            this.equipmentBracodeId = _data["equipmentBracodeId"];
            this.equipmentBracodeName = _data["equipmentBracodeName"];
            this.processBarcodeId = _data["processBarcodeId"];
            this.processBarcodeName = _data["processBarcodeName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endtTime = _data["endtTime"] ? moment(_data["endtTime"].toString()) : <any>undefined;
            this.approvedBy = _data["approvedBy"];
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentUsageLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentUsageLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["operatorName"] = this.operatorName;
        data["equipmentType"] = this.equipmentType;
        data["equipmentBracodeId"] = this.equipmentBracodeId;
        data["equipmentBracodeName"] = this.equipmentBracodeName;
        data["processBarcodeId"] = this.processBarcodeId;
        data["processBarcodeName"] = this.processBarcodeName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endtTime"] = this.endtTime ? this.endtTime.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentUsageLogListDto {
        const json = this.toJSON();
        let result = new EquipmentUsageLogListDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentUsageLogListDto {
    activityId: number | undefined;
    activityName: string | undefined;
    operatorName: string | undefined;
    equipmentType: string | undefined;
    equipmentBracodeId: number | undefined;
    equipmentBracodeName: string | undefined;
    processBarcodeId: number | undefined;
    processBarcodeName: string | undefined;
    startTime: moment.Moment | undefined;
    endtTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    approvedTime: moment.Moment | undefined;
    statusId: number | undefined;
    id: number;
}

export class EquipmentUsageLogListDtoPagedResultDto implements IEquipmentUsageLogListDtoPagedResultDto {
    totalCount: number;
    items: EquipmentUsageLogListDto[] | undefined;

    constructor(data?: IEquipmentUsageLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EquipmentUsageLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EquipmentUsageLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentUsageLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EquipmentUsageLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EquipmentUsageLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEquipmentUsageLogListDtoPagedResultDto {
    totalCount: number;
    items: EquipmentUsageLogListDto[] | undefined;
}

export class FgPickingDto implements IFgPickingDto {
    obd: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    shipperCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;

    constructor(data?: IFgPickingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.productBatchNo = _data["productBatchNo"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.suggestedLocationId = _data["suggestedLocationId"];
            this.locationId = _data["locationId"];
            this.locationBarcode = _data["locationBarcode"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.shipperCount = _data["shipperCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FgPickingDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPickingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["productBatchNo"] = this.productBatchNo;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["suggestedLocationId"] = this.suggestedLocationId;
        data["locationId"] = this.locationId;
        data["locationBarcode"] = this.locationBarcode;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["shipperCount"] = this.shipperCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): FgPickingDto {
        const json = this.toJSON();
        let result = new FgPickingDto();
        result.init(json);
        return result;
    }
}

export interface IFgPickingDto {
    obd: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    shipperCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;
}

export class FgPickingListDto implements IFgPickingListDto {
    obd: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    shipperCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;

    constructor(data?: IFgPickingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.productBatchNo = _data["productBatchNo"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.suggestedLocationId = _data["suggestedLocationId"];
            this.locationId = _data["locationId"];
            this.locationBarcode = _data["locationBarcode"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.shipperCount = _data["shipperCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FgPickingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPickingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["productBatchNo"] = this.productBatchNo;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["suggestedLocationId"] = this.suggestedLocationId;
        data["locationId"] = this.locationId;
        data["locationBarcode"] = this.locationBarcode;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["shipperCount"] = this.shipperCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): FgPickingListDto {
        const json = this.toJSON();
        let result = new FgPickingListDto();
        result.init(json);
        return result;
    }
}

export interface IFgPickingListDto {
    obd: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    shipperCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;
}

export class FgPickingListDtoPagedResultDto implements IFgPickingListDtoPagedResultDto {
    totalCount: number;
    items: FgPickingListDto[] | undefined;

    constructor(data?: IFgPickingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FgPickingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FgPickingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPickingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FgPickingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FgPickingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFgPickingListDtoPagedResultDto {
    totalCount: number;
    items: FgPickingListDto[] | undefined;
}

export class OBDDetailDto implements IOBDDetailDto {
    obd: string | undefined;
    lineItemNo: string | undefined;
    productCode: string | undefined;
    productDesc: string | undefined;
    productBatchNo: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;

    constructor(data?: IOBDDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.lineItemNo = _data["lineItemNo"];
            this.productCode = _data["productCode"];
            this.productDesc = _data["productDesc"];
            this.productBatchNo = _data["productBatchNo"];
            this.arNo = _data["arNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.qty = _data["qty"];
            this.uom = _data["uom"];
            this.customerName = _data["customerName"];
            this.customerAddress = _data["customerAddress"];
        }
    }

    static fromJS(data: any): OBDDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OBDDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["lineItemNo"] = this.lineItemNo;
        data["productCode"] = this.productCode;
        data["productDesc"] = this.productDesc;
        data["productBatchNo"] = this.productBatchNo;
        data["arNo"] = this.arNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["qty"] = this.qty;
        data["uom"] = this.uom;
        data["customerName"] = this.customerName;
        data["customerAddress"] = this.customerAddress;
        return data; 
    }

    clone(): OBDDetailDto {
        const json = this.toJSON();
        let result = new OBDDetailDto();
        result.init(json);
        return result;
    }
}

export interface IOBDDetailDto {
    obd: string | undefined;
    lineItemNo: string | undefined;
    productCode: string | undefined;
    productDesc: string | undefined;
    productBatchNo: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
}

export class FgPutAwayDto implements IFgPutAwayDto {
    palletId: number | undefined;
    palletBarcode: string | undefined;
    palletCount: number;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    isActive: boolean;
    isPicked: boolean;
    huCode: string | undefined;
    plantId: number | undefined;
    productBatchNo: string | undefined;
    id: number;

    constructor(data?: IFgPutAwayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletId = _data["palletId"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.locationId = _data["locationId"];
            this.locationBarcode = _data["locationBarcode"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.productBatchNo = _data["productBatchNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FgPutAwayDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPutAwayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletId"] = this.palletId;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["locationId"] = this.locationId;
        data["locationBarcode"] = this.locationBarcode;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["productBatchNo"] = this.productBatchNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): FgPutAwayDto {
        const json = this.toJSON();
        let result = new FgPutAwayDto();
        result.init(json);
        return result;
    }
}

export interface IFgPutAwayDto {
    palletId: number | undefined;
    palletBarcode: string | undefined;
    palletCount: number;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    isActive: boolean;
    isPicked: boolean;
    huCode: string | undefined;
    plantId: number | undefined;
    productBatchNo: string | undefined;
    id: number;
}

export class FgPutAwayListDto implements IFgPutAwayListDto {
    palletId: number | undefined;
    palletBarcode: string | undefined;
    palletCount: number;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    isActive: boolean;
    isPicked: boolean;
    huCode: string | undefined;
    plantId: number | undefined;
    productBatchNo: string | undefined;
    id: number;

    constructor(data?: IFgPutAwayListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletId = _data["palletId"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.locationId = _data["locationId"];
            this.locationBarcode = _data["locationBarcode"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.productBatchNo = _data["productBatchNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FgPutAwayListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPutAwayListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletId"] = this.palletId;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["locationId"] = this.locationId;
        data["locationBarcode"] = this.locationBarcode;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["productBatchNo"] = this.productBatchNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): FgPutAwayListDto {
        const json = this.toJSON();
        let result = new FgPutAwayListDto();
        result.init(json);
        return result;
    }
}

export interface IFgPutAwayListDto {
    palletId: number | undefined;
    palletBarcode: string | undefined;
    palletCount: number;
    locationId: number | undefined;
    locationBarcode: string | undefined;
    isActive: boolean;
    isPicked: boolean;
    huCode: string | undefined;
    plantId: number | undefined;
    productBatchNo: string | undefined;
    id: number;
}

export class FgPutAwayListDtoPagedResultDto implements IFgPutAwayListDtoPagedResultDto {
    totalCount: number;
    items: FgPutAwayListDto[] | undefined;

    constructor(data?: IFgPutAwayListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FgPutAwayListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FgPutAwayListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FgPutAwayListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FgPutAwayListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FgPutAwayListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFgPutAwayListDtoPagedResultDto {
    totalCount: number;
    items: FgPutAwayListDto[] | undefined;
}

export class GateDto implements IGateDto {
    plantId: number;
    gateCode: string;
    name: string;
    aliasName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IGateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.gateCode = _data["gateCode"];
            this.name = _data["name"];
            this.aliasName = _data["aliasName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["gateCode"] = this.gateCode;
        data["name"] = this.name;
        data["aliasName"] = this.aliasName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateDto {
        const json = this.toJSON();
        let result = new GateDto();
        result.init(json);
        return result;
    }
}

export interface IGateDto {
    plantId: number;
    gateCode: string;
    name: string;
    aliasName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class GateListDto implements IGateListDto {
    plantId: number;
    gateCode: string | undefined;
    plantName: string | undefined;
    userEnteredPlantId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IGateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.gateCode = _data["gateCode"];
            this.plantName = _data["plantName"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["gateCode"] = this.gateCode;
        data["plantName"] = this.plantName;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateListDto {
        const json = this.toJSON();
        let result = new GateListDto();
        result.init(json);
        return result;
    }
}

export interface IGateListDto {
    plantId: number;
    gateCode: string | undefined;
    plantName: string | undefined;
    userEnteredPlantId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class GateListDtoPagedResultDto implements IGateListDtoPagedResultDto {
    totalCount: number;
    items: GateListDto[] | undefined;

    constructor(data?: IGateListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GateListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GateListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GateListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GateListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGateListDtoPagedResultDto {
    totalCount: number;
    items: GateListDto[] | undefined;
}

export class CreateGateDto implements ICreateGateDto {
    plantId: number;
    gateCode: string;
    name: string;
    aliasName: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateGateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.gateCode = _data["gateCode"];
            this.name = _data["name"];
            this.aliasName = _data["aliasName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateGateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["gateCode"] = this.gateCode;
        data["name"] = this.name;
        data["aliasName"] = this.aliasName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateGateDto {
        const json = this.toJSON();
        let result = new CreateGateDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGateDto {
    plantId: number;
    gateCode: string;
    name: string;
    aliasName: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class MaterialInternalDto implements IMaterialInternalDto {
    number: string | undefined;
    code: string | undefined;
    description: string | undefined;
    quantity: number;
    invoiceQuantity: number | undefined;
    pickedInvoiceQuantity: number | undefined;
    balanceQuantity: number | undefined;
    uom: string | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    id: number;

    constructor(data?: IMaterialInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.invoiceQuantity = _data["invoiceQuantity"];
            this.pickedInvoiceQuantity = _data["pickedInvoiceQuantity"];
            this.balanceQuantity = _data["balanceQuantity"];
            this.uom = _data["uom"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["code"] = this.code;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["invoiceQuantity"] = this.invoiceQuantity;
        data["pickedInvoiceQuantity"] = this.pickedInvoiceQuantity;
        data["balanceQuantity"] = this.balanceQuantity;
        data["uom"] = this.uom;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialInternalDto {
        const json = this.toJSON();
        let result = new MaterialInternalDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialInternalDto {
    number: string | undefined;
    code: string | undefined;
    description: string | undefined;
    quantity: number;
    invoiceQuantity: number | undefined;
    pickedInvoiceQuantity: number | undefined;
    balanceQuantity: number | undefined;
    uom: string | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    id: number;
}

export class InvoiceDto implements IInvoiceDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    vendorName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    lrNo: string | undefined;
    lrDate: moment.Moment | undefined;
    driverName: string;
    vehicleNumber: string;
    transporterName: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    plantId: number | undefined;
    vendorBatchNo: string | undefined;
    manufacturer: string | undefined;
    manufacturerCode: string | undefined;
    deliveryNote: string | undefined;
    billofLanding: string | undefined;
    vendorCode: string | undefined;
    id: number;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.vendorName = _data["vendorName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.lrNo = _data["lrNo"];
            this.lrDate = _data["lrDate"] ? moment(_data["lrDate"].toString()) : <any>undefined;
            this.driverName = _data["driverName"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.transporterName = _data["transporterName"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.plantId = _data["plantId"];
            this.vendorBatchNo = _data["vendorBatchNo"];
            this.manufacturer = _data["manufacturer"];
            this.manufacturerCode = _data["manufacturerCode"];
            this.deliveryNote = _data["deliveryNote"];
            this.billofLanding = _data["billofLanding"];
            this.vendorCode = _data["vendorCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["vendorName"] = this.vendorName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["lrNo"] = this.lrNo;
        data["lrDate"] = this.lrDate ? this.lrDate.toISOString() : <any>undefined;
        data["driverName"] = this.driverName;
        data["vehicleNumber"] = this.vehicleNumber;
        data["transporterName"] = this.transporterName;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["plantId"] = this.plantId;
        data["vendorBatchNo"] = this.vendorBatchNo;
        data["manufacturer"] = this.manufacturer;
        data["manufacturerCode"] = this.manufacturerCode;
        data["deliveryNote"] = this.deliveryNote;
        data["billofLanding"] = this.billofLanding;
        data["vendorCode"] = this.vendorCode;
        data["id"] = this.id;
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    vendorName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    lrNo: string | undefined;
    lrDate: moment.Moment | undefined;
    driverName: string;
    vehicleNumber: string;
    transporterName: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    plantId: number | undefined;
    vendorBatchNo: string | undefined;
    manufacturer: string | undefined;
    manufacturerCode: string | undefined;
    deliveryNote: string | undefined;
    billofLanding: string | undefined;
    vendorCode: string | undefined;
    id: number;
}

export class GateEntryDto implements IGateEntryDto {
    gatePassNo: string | undefined;
    tenantId: number | undefined;
    materials: MaterialInternalDto[];
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    invoiceDto: InvoiceDto;
    plantId: number | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    transactionstatusId: number | undefined;
    id: number;

    constructor(data?: IGateEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.materials = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatePassNo = _data["gatePassNo"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials.push(MaterialInternalDto.fromJS(item));
            }
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.invoiceDto = _data["invoiceDto"] ? InvoiceDto.fromJS(_data["invoiceDto"]) : <any>undefined;
            this.plantId = _data["plantId"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.transactionstatusId = _data["transactionstatusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GateEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatePassNo"] = this.gatePassNo;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["invoiceDto"] = this.invoiceDto ? this.invoiceDto.toJSON() : <any>undefined;
        data["plantId"] = this.plantId;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["transactionstatusId"] = this.transactionstatusId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateEntryDto {
        const json = this.toJSON();
        let result = new GateEntryDto();
        result.init(json);
        return result;
    }
}

export interface IGateEntryDto {
    gatePassNo: string | undefined;
    tenantId: number | undefined;
    materials: MaterialInternalDto[];
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    invoiceDto: InvoiceDto;
    plantId: number | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    transactionstatusId: number | undefined;
    id: number;
}

export class GateEntryListDto implements IGateEntryListDto {
    gatePassNumber: string | undefined;
    purchaseOrderId: number;
    userEnteredPurchaseOrderNumber: string | undefined;
    isActive: boolean;
    subPlantId: number;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;

    constructor(data?: IGateEntryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatePassNumber = _data["gatePassNumber"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.userEnteredPurchaseOrderNumber = _data["userEnteredPurchaseOrderNumber"];
            this.isActive = _data["isActive"];
            this.subPlantId = _data["subPlantId"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GateEntryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateEntryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatePassNumber"] = this.gatePassNumber;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["userEnteredPurchaseOrderNumber"] = this.userEnteredPurchaseOrderNumber;
        data["isActive"] = this.isActive;
        data["subPlantId"] = this.subPlantId;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateEntryListDto {
        const json = this.toJSON();
        let result = new GateEntryListDto();
        result.init(json);
        return result;
    }
}

export interface IGateEntryListDto {
    gatePassNumber: string | undefined;
    purchaseOrderId: number;
    userEnteredPurchaseOrderNumber: string | undefined;
    isActive: boolean;
    subPlantId: number;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;
}

export class GateEntryListDtoPagedResultDto implements IGateEntryListDtoPagedResultDto {
    totalCount: number;
    items: GateEntryListDto[] | undefined;

    constructor(data?: IGateEntryListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GateEntryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GateEntryListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateEntryListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GateEntryListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GateEntryListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGateEntryListDtoPagedResultDto {
    totalCount: number;
    items: GateEntryListDto[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    vendorName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    lrNo: string | undefined;
    lrDate: moment.Moment | undefined;
    driverName: string;
    vehicleNumber: string;
    transporterName: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    vendorBatchNo: string | undefined;
    manufacturer: string | undefined;
    manufacturerCode: string | undefined;
    deliveryNote: string | undefined;
    billofLanding: string | undefined;
    vendorCode: string | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.vendorName = _data["vendorName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.lrNo = _data["lrNo"];
            this.lrDate = _data["lrDate"] ? moment(_data["lrDate"].toString()) : <any>undefined;
            this.driverName = _data["driverName"];
            this.vehicleNumber = _data["vehicleNumber"];
            this.transporterName = _data["transporterName"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.vendorBatchNo = _data["vendorBatchNo"];
            this.manufacturer = _data["manufacturer"];
            this.manufacturerCode = _data["manufacturerCode"];
            this.deliveryNote = _data["deliveryNote"];
            this.billofLanding = _data["billofLanding"];
            this.vendorCode = _data["vendorCode"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["vendorName"] = this.vendorName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["lrNo"] = this.lrNo;
        data["lrDate"] = this.lrDate ? this.lrDate.toISOString() : <any>undefined;
        data["driverName"] = this.driverName;
        data["vehicleNumber"] = this.vehicleNumber;
        data["transporterName"] = this.transporterName;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["vendorBatchNo"] = this.vendorBatchNo;
        data["manufacturer"] = this.manufacturer;
        data["manufacturerCode"] = this.manufacturerCode;
        data["deliveryNote"] = this.deliveryNote;
        data["billofLanding"] = this.billofLanding;
        data["vendorCode"] = this.vendorCode;
        return data; 
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    vendorName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    lrNo: string | undefined;
    lrDate: moment.Moment | undefined;
    driverName: string;
    vehicleNumber: string;
    transporterName: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    vendorBatchNo: string | undefined;
    manufacturer: string | undefined;
    manufacturerCode: string | undefined;
    deliveryNote: string | undefined;
    billofLanding: string | undefined;
    vendorCode: string | undefined;
}

export class CreateGateEntryDto implements ICreateGateEntryDto {
    gatePassNo: string | undefined;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    invoiceDto: CreateInvoiceDto;
    materials: MaterialInternalDto[] | undefined;

    constructor(data?: ICreateGateEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatePassNo = _data["gatePassNo"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.invoiceDto = _data["invoiceDto"] ? CreateInvoiceDto.fromJS(_data["invoiceDto"]) : <any>undefined;
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials.push(MaterialInternalDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGateEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGateEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatePassNo"] = this.gatePassNo;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["invoiceDto"] = this.invoiceDto ? this.invoiceDto.toJSON() : <any>undefined;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateGateEntryDto {
        const json = this.toJSON();
        let result = new CreateGateEntryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGateEntryDto {
    gatePassNo: string | undefined;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    invoiceDto: CreateInvoiceDto;
    materials: MaterialInternalDto[] | undefined;
}

export class UpdateGateEntryDto implements IUpdateGateEntryDto {
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;

    constructor(data?: IUpdateGateEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateGateEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGateEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateGateEntryDto {
        const json = this.toJSON();
        let result = new UpdateGateEntryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateGateEntryDto {
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;
}

export class GRNPostingQtyDetailsDto implements IGRNPostingQtyDetailsDto {
    grnDetailId: number;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    isDamaged: string | undefined;
    id: number;

    constructor(data?: IGRNPostingQtyDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnDetailId = _data["grnDetailId"];
            this.totalQty = _data["totalQty"];
            this.noOfContainer = _data["noOfContainer"];
            this.qtyPerContainer = _data["qtyPerContainer"];
            this.totalQtyInDecimal = _data["totalQtyInDecimal"];
            this.qtyPerContainerInDecimal = _data["qtyPerContainerInDecimal"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.isDamaged = _data["isDamaged"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNPostingQtyDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNPostingQtyDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnDetailId"] = this.grnDetailId;
        data["totalQty"] = this.totalQty;
        data["noOfContainer"] = this.noOfContainer;
        data["qtyPerContainer"] = this.qtyPerContainer;
        data["totalQtyInDecimal"] = this.totalQtyInDecimal;
        data["qtyPerContainerInDecimal"] = this.qtyPerContainerInDecimal;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["isDamaged"] = this.isDamaged;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNPostingQtyDetailsDto {
        const json = this.toJSON();
        let result = new GRNPostingQtyDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IGRNPostingQtyDetailsDto {
    grnDetailId: number;
    totalQty: number;
    noOfContainer: number;
    qtyPerContainer: number;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    isDamaged: string | undefined;
    id: number;
}

export class GRNPostingDetailsDto implements IGRNPostingDetailsDto {
    grnHeaderId: number | undefined;
    sapBatchNumber: string | undefined;
    tenantId: number | undefined;
    formArrayIndex: number | undefined;
    isSelected: boolean;
    invoiceNo: string | undefined;
    invoiceId: number | undefined;
    materialId: number | undefined;
    parentRow: number | undefined;
    materialCode: string | undefined;
    itemCode: string | undefined;
    mfgBatchNoId: number | undefined;
    manufacturedBatchNo: string | undefined;
    consignmentQty: number | undefined;
    consignmentQtyUnit: string | undefined;
    grnQtyDetails: GRNPostingQtyDetailsDto[] | undefined;
    totalQty: number | undefined;
    noOfContainer: number | undefined;
    qtyPerContainer: number | undefined;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    lineItem: string | undefined;
    itemDescription: string | undefined;
    grnPreparedBy: string | undefined;
    invoiceQty: number | undefined;
    materialConsignmentId: number;
    materialRelationId: number | undefined;
    isDamaged: string | undefined;
    uom: string | undefined;
    id: number;

    constructor(data?: IGRNPostingDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnHeaderId = _data["grnHeaderId"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.tenantId = _data["tenantId"];
            this.formArrayIndex = _data["formArrayIndex"];
            this.isSelected = _data["isSelected"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceId = _data["invoiceId"];
            this.materialId = _data["materialId"];
            this.parentRow = _data["parentRow"];
            this.materialCode = _data["materialCode"];
            this.itemCode = _data["itemCode"];
            this.mfgBatchNoId = _data["mfgBatchNoId"];
            this.manufacturedBatchNo = _data["manufacturedBatchNo"];
            this.consignmentQty = _data["consignmentQty"];
            this.consignmentQtyUnit = _data["consignmentQtyUnit"];
            if (Array.isArray(_data["grnQtyDetails"])) {
                this.grnQtyDetails = [] as any;
                for (let item of _data["grnQtyDetails"])
                    this.grnQtyDetails.push(GRNPostingQtyDetailsDto.fromJS(item));
            }
            this.totalQty = _data["totalQty"];
            this.noOfContainer = _data["noOfContainer"];
            this.qtyPerContainer = _data["qtyPerContainer"];
            this.totalQtyInDecimal = _data["totalQtyInDecimal"];
            this.qtyPerContainerInDecimal = _data["qtyPerContainerInDecimal"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.lineItem = _data["lineItem"];
            this.itemDescription = _data["itemDescription"];
            this.grnPreparedBy = _data["grnPreparedBy"];
            this.invoiceQty = _data["invoiceQty"];
            this.materialConsignmentId = _data["materialConsignmentId"];
            this.materialRelationId = _data["materialRelationId"];
            this.isDamaged = _data["isDamaged"];
            this.uom = _data["uom"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNPostingDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNPostingDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnHeaderId"] = this.grnHeaderId;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["tenantId"] = this.tenantId;
        data["formArrayIndex"] = this.formArrayIndex;
        data["isSelected"] = this.isSelected;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceId"] = this.invoiceId;
        data["materialId"] = this.materialId;
        data["parentRow"] = this.parentRow;
        data["materialCode"] = this.materialCode;
        data["itemCode"] = this.itemCode;
        data["mfgBatchNoId"] = this.mfgBatchNoId;
        data["manufacturedBatchNo"] = this.manufacturedBatchNo;
        data["consignmentQty"] = this.consignmentQty;
        data["consignmentQtyUnit"] = this.consignmentQtyUnit;
        if (Array.isArray(this.grnQtyDetails)) {
            data["grnQtyDetails"] = [];
            for (let item of this.grnQtyDetails)
                data["grnQtyDetails"].push(item.toJSON());
        }
        data["totalQty"] = this.totalQty;
        data["noOfContainer"] = this.noOfContainer;
        data["qtyPerContainer"] = this.qtyPerContainer;
        data["totalQtyInDecimal"] = this.totalQtyInDecimal;
        data["qtyPerContainerInDecimal"] = this.qtyPerContainerInDecimal;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["lineItem"] = this.lineItem;
        data["itemDescription"] = this.itemDescription;
        data["grnPreparedBy"] = this.grnPreparedBy;
        data["invoiceQty"] = this.invoiceQty;
        data["materialConsignmentId"] = this.materialConsignmentId;
        data["materialRelationId"] = this.materialRelationId;
        data["isDamaged"] = this.isDamaged;
        data["uom"] = this.uom;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNPostingDetailsDto {
        const json = this.toJSON();
        let result = new GRNPostingDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IGRNPostingDetailsDto {
    grnHeaderId: number | undefined;
    sapBatchNumber: string | undefined;
    tenantId: number | undefined;
    formArrayIndex: number | undefined;
    isSelected: boolean;
    invoiceNo: string | undefined;
    invoiceId: number | undefined;
    materialId: number | undefined;
    parentRow: number | undefined;
    materialCode: string | undefined;
    itemCode: string | undefined;
    mfgBatchNoId: number | undefined;
    manufacturedBatchNo: string | undefined;
    consignmentQty: number | undefined;
    consignmentQtyUnit: string | undefined;
    grnQtyDetails: GRNPostingQtyDetailsDto[] | undefined;
    totalQty: number | undefined;
    noOfContainer: number | undefined;
    qtyPerContainer: number | undefined;
    totalQtyInDecimal: string | undefined;
    qtyPerContainerInDecimal: string | undefined;
    discrepancyRemark: string | undefined;
    lineItem: string | undefined;
    itemDescription: string | undefined;
    grnPreparedBy: string | undefined;
    invoiceQty: number | undefined;
    materialConsignmentId: number;
    materialRelationId: number | undefined;
    isDamaged: string | undefined;
    uom: string | undefined;
    id: number;
}

export class GRNPostingDto implements IGRNPostingDto {
    grnPostingNumber: string;
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    tenantId: number | undefined;
    grnPostingDate: moment.Moment;
    grnDetails: GRNPostingDetailsDto[] | undefined;
    id: number;

    constructor(data?: IGRNPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnPostingNumber = _data["grnPostingNumber"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.tenantId = _data["tenantId"];
            this.grnPostingDate = _data["grnPostingDate"] ? moment(_data["grnPostingDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["grnDetails"])) {
                this.grnDetails = [] as any;
                for (let item of _data["grnDetails"])
                    this.grnDetails.push(GRNPostingDetailsDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnPostingNumber"] = this.grnPostingNumber;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["invoiceNo"] = this.invoiceNo;
        data["tenantId"] = this.tenantId;
        data["grnPostingDate"] = this.grnPostingDate ? this.grnPostingDate.toISOString() : <any>undefined;
        if (Array.isArray(this.grnDetails)) {
            data["grnDetails"] = [];
            for (let item of this.grnDetails)
                data["grnDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNPostingDto {
        const json = this.toJSON();
        let result = new GRNPostingDto();
        result.init(json);
        return result;
    }
}

export interface IGRNPostingDto {
    grnPostingNumber: string;
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    tenantId: number | undefined;
    grnPostingDate: moment.Moment;
    grnDetails: GRNPostingDetailsDto[] | undefined;
    id: number;
}

export class GRNPostingListDto implements IGRNPostingListDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    grnPostingNumber: string | undefined;
    subPlantId: number;
    id: number;

    constructor(data?: IGRNPostingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.grnPostingNumber = _data["grnPostingNumber"];
            this.subPlantId = _data["subPlantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNPostingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNPostingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["grnPostingNumber"] = this.grnPostingNumber;
        data["subPlantId"] = this.subPlantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNPostingListDto {
        const json = this.toJSON();
        let result = new GRNPostingListDto();
        result.init(json);
        return result;
    }
}

export interface IGRNPostingListDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    grnPostingNumber: string | undefined;
    subPlantId: number;
    id: number;
}

export class GRNPostingListDtoPagedResultDto implements IGRNPostingListDtoPagedResultDto {
    totalCount: number;
    items: GRNPostingListDto[] | undefined;

    constructor(data?: IGRNPostingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GRNPostingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GRNPostingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNPostingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GRNPostingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GRNPostingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGRNPostingListDtoPagedResultDto {
    totalCount: number;
    items: GRNPostingListDto[] | undefined;
}

export class CreateGRNPostingDto implements ICreateGRNPostingDto {
    grnPostingNumber: string | undefined;
    purchaseOrderId: number | undefined;
    tenantId: number | undefined;
    grnPostingDate: moment.Moment;
    grnDetails: GRNPostingDetailsDto[] | undefined;

    constructor(data?: ICreateGRNPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnPostingNumber = _data["grnPostingNumber"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.tenantId = _data["tenantId"];
            this.grnPostingDate = _data["grnPostingDate"] ? moment(_data["grnPostingDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["grnDetails"])) {
                this.grnDetails = [] as any;
                for (let item of _data["grnDetails"])
                    this.grnDetails.push(GRNPostingDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGRNPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGRNPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnPostingNumber"] = this.grnPostingNumber;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["tenantId"] = this.tenantId;
        data["grnPostingDate"] = this.grnPostingDate ? this.grnPostingDate.toISOString() : <any>undefined;
        if (Array.isArray(this.grnDetails)) {
            data["grnDetails"] = [];
            for (let item of this.grnDetails)
                data["grnDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateGRNPostingDto {
        const json = this.toJSON();
        let result = new CreateGRNPostingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGRNPostingDto {
    grnPostingNumber: string | undefined;
    purchaseOrderId: number | undefined;
    tenantId: number | undefined;
    grnPostingDate: moment.Moment;
    grnDetails: GRNPostingDetailsDto[] | undefined;
}

export class MaterialLabelGRNQuantityDto implements IMaterialLabelGRNQuantityDto {
    grnQuantityId: number;
    numberOfContainers: number;
    totalQty: number;
    qtyPerContainer: number;

    constructor(data?: IMaterialLabelGRNQuantityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnQuantityId = _data["grnQuantityId"];
            this.numberOfContainers = _data["numberOfContainers"];
            this.totalQty = _data["totalQty"];
            this.qtyPerContainer = _data["qtyPerContainer"];
        }
    }

    static fromJS(data: any): MaterialLabelGRNQuantityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialLabelGRNQuantityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnQuantityId"] = this.grnQuantityId;
        data["numberOfContainers"] = this.numberOfContainers;
        data["totalQty"] = this.totalQty;
        data["qtyPerContainer"] = this.qtyPerContainer;
        return data; 
    }

    clone(): MaterialLabelGRNQuantityDto {
        const json = this.toJSON();
        let result = new MaterialLabelGRNQuantityDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialLabelGRNQuantityDto {
    grnQuantityId: number;
    numberOfContainers: number;
    totalQty: number;
    qtyPerContainer: number;
}

export class GRNMaterialLabelPrintingDto implements IGRNMaterialLabelPrintingDto {
    grnHeaderId: number;
    materialLabelPrintHeaderId: number;
    isAlreadyPrinted: boolean;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    manufacturingBatchNo: string | undefined;
    sapBatchNo: string | undefined;
    manufacturingDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    packDetails: string | undefined;
    numberOfContainers: number;
    totalQty: number;
    printerId: number | undefined;
    comment: string | undefined;
    rangePrint: string | undefined;
    lstMaterialLabelGRNQuantity: MaterialLabelGRNQuantityDto[] | undefined;
    id: number;

    constructor(data?: IGRNMaterialLabelPrintingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnHeaderId = _data["grnHeaderId"];
            this.materialLabelPrintHeaderId = _data["materialLabelPrintHeaderId"];
            this.isAlreadyPrinted = _data["isAlreadyPrinted"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.manufacturingBatchNo = _data["manufacturingBatchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.manufacturingDate = _data["manufacturingDate"] ? moment(_data["manufacturingDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.packDetails = _data["packDetails"];
            this.numberOfContainers = _data["numberOfContainers"];
            this.totalQty = _data["totalQty"];
            this.printerId = _data["printerId"];
            this.comment = _data["comment"];
            this.rangePrint = _data["rangePrint"];
            if (Array.isArray(_data["lstMaterialLabelGRNQuantity"])) {
                this.lstMaterialLabelGRNQuantity = [] as any;
                for (let item of _data["lstMaterialLabelGRNQuantity"])
                    this.lstMaterialLabelGRNQuantity.push(MaterialLabelGRNQuantityDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNMaterialLabelPrintingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNMaterialLabelPrintingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnHeaderId"] = this.grnHeaderId;
        data["materialLabelPrintHeaderId"] = this.materialLabelPrintHeaderId;
        data["isAlreadyPrinted"] = this.isAlreadyPrinted;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["manufacturingBatchNo"] = this.manufacturingBatchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["manufacturingDate"] = this.manufacturingDate ? this.manufacturingDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["packDetails"] = this.packDetails;
        data["numberOfContainers"] = this.numberOfContainers;
        data["totalQty"] = this.totalQty;
        data["printerId"] = this.printerId;
        data["comment"] = this.comment;
        data["rangePrint"] = this.rangePrint;
        if (Array.isArray(this.lstMaterialLabelGRNQuantity)) {
            data["lstMaterialLabelGRNQuantity"] = [];
            for (let item of this.lstMaterialLabelGRNQuantity)
                data["lstMaterialLabelGRNQuantity"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNMaterialLabelPrintingDto {
        const json = this.toJSON();
        let result = new GRNMaterialLabelPrintingDto();
        result.init(json);
        return result;
    }
}

export interface IGRNMaterialLabelPrintingDto {
    grnHeaderId: number;
    materialLabelPrintHeaderId: number;
    isAlreadyPrinted: boolean;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    manufacturingBatchNo: string | undefined;
    sapBatchNo: string | undefined;
    manufacturingDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    packDetails: string | undefined;
    numberOfContainers: number;
    totalQty: number;
    printerId: number | undefined;
    comment: string | undefined;
    rangePrint: string | undefined;
    lstMaterialLabelGRNQuantity: MaterialLabelGRNQuantityDto[] | undefined;
    id: number;
}

export class GRNMaterialLabelPrintingListDto implements IGRNMaterialLabelPrintingListDto {
    grnNo: string | undefined;
    grnMaterialLabelPrintings: GRNMaterialLabelPrintingDto[] | undefined;
    id: number;

    constructor(data?: IGRNMaterialLabelPrintingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grnNo = _data["grnNo"];
            if (Array.isArray(_data["grnMaterialLabelPrintings"])) {
                this.grnMaterialLabelPrintings = [] as any;
                for (let item of _data["grnMaterialLabelPrintings"])
                    this.grnMaterialLabelPrintings.push(GRNMaterialLabelPrintingDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GRNMaterialLabelPrintingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GRNMaterialLabelPrintingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grnNo"] = this.grnNo;
        if (Array.isArray(this.grnMaterialLabelPrintings)) {
            data["grnMaterialLabelPrintings"] = [];
            for (let item of this.grnMaterialLabelPrintings)
                data["grnMaterialLabelPrintings"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GRNMaterialLabelPrintingListDto {
        const json = this.toJSON();
        let result = new GRNMaterialLabelPrintingListDto();
        result.init(json);
        return result;
    }
}

export interface IGRNMaterialLabelPrintingListDto {
    grnNo: string | undefined;
    grnMaterialLabelPrintings: GRNMaterialLabelPrintingDto[] | undefined;
    id: number;
}

export class HandlingUnitDto implements IHandlingUnitDto {
    plantId: number;
    huCode: string;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IHandlingUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.handlingUnitTypeId = _data["handlingUnitTypeId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HandlingUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandlingUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["handlingUnitTypeId"] = this.handlingUnitTypeId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): HandlingUnitDto {
        const json = this.toJSON();
        let result = new HandlingUnitDto();
        result.init(json);
        return result;
    }
}

export interface IHandlingUnitDto {
    plantId: number;
    huCode: string;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class HandlingUnitListDto implements IHandlingUnitListDto {
    plantId: number | undefined;
    userEnteredPlantId: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    userEnteredHandlingUnit: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IHandlingUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.handlingUnitTypeId = _data["handlingUnitTypeId"];
            this.userEnteredHandlingUnit = _data["userEnteredHandlingUnit"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HandlingUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandlingUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["handlingUnitTypeId"] = this.handlingUnitTypeId;
        data["userEnteredHandlingUnit"] = this.userEnteredHandlingUnit;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): HandlingUnitListDto {
        const json = this.toJSON();
        let result = new HandlingUnitListDto();
        result.init(json);
        return result;
    }
}

export interface IHandlingUnitListDto {
    plantId: number | undefined;
    userEnteredPlantId: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    userEnteredHandlingUnit: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class HandlingUnitListDtoPagedResultDto implements IHandlingUnitListDtoPagedResultDto {
    totalCount: number;
    items: HandlingUnitListDto[] | undefined;

    constructor(data?: IHandlingUnitListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HandlingUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HandlingUnitListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandlingUnitListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HandlingUnitListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HandlingUnitListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHandlingUnitListDtoPagedResultDto {
    totalCount: number;
    items: HandlingUnitListDto[] | undefined;
}

export class CreateHandlingUnitDto implements ICreateHandlingUnitDto {
    plantId: number;
    huCode: string;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateHandlingUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.handlingUnitTypeId = _data["handlingUnitTypeId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateHandlingUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHandlingUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["handlingUnitTypeId"] = this.handlingUnitTypeId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateHandlingUnitDto {
        const json = this.toJSON();
        let result = new CreateHandlingUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHandlingUnitDto {
    plantId: number;
    huCode: string;
    name: string | undefined;
    handlingUnitTypeId: number | undefined;
    isActive: boolean;
    description: string | undefined;
}

export class Connection implements IConnection {
    ipAddress: string;
    port: number;

    constructor(data?: IConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): Connection {
        data = typeof data === 'object' ? data : {};
        let result = new Connection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        return data; 
    }

    clone(): Connection {
        const json = this.toJSON();
        let result = new Connection();
        result.init(json);
        return result;
    }
}

export interface IConnection {
    ipAddress: string;
    port: number;
}

export class InspectionChecklistDto implements IInspectionChecklistDto {
    checklistCode: string | undefined;
    name: string;
    plantId: number;
    subModuleId: number;
    isActive: boolean;
    description: string | undefined;
    version: number;
    versionString: string | undefined;
    formatNumber: string | undefined;
    checklistTypeId: number;
    modeId: number;
    checkpoints: CheckpointDto[];
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IInspectionChecklistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checkpoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistCode = _data["checklistCode"];
            this.name = _data["name"];
            this.plantId = _data["plantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.version = _data["version"];
            this.versionString = _data["versionString"];
            this.formatNumber = _data["formatNumber"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.modeId = _data["modeId"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints.push(CheckpointDto.fromJS(item));
            }
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InspectionChecklistDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionChecklistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistCode"] = this.checklistCode;
        data["name"] = this.name;
        data["plantId"] = this.plantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["version"] = this.version;
        data["versionString"] = this.versionString;
        data["formatNumber"] = this.formatNumber;
        data["checklistTypeId"] = this.checklistTypeId;
        data["modeId"] = this.modeId;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item.toJSON());
        }
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): InspectionChecklistDto {
        const json = this.toJSON();
        let result = new InspectionChecklistDto();
        result.init(json);
        return result;
    }
}

export interface IInspectionChecklistDto {
    checklistCode: string | undefined;
    name: string;
    plantId: number;
    subModuleId: number;
    isActive: boolean;
    description: string | undefined;
    version: number;
    versionString: string | undefined;
    formatNumber: string | undefined;
    checklistTypeId: number;
    modeId: number;
    checkpoints: CheckpointDto[];
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class InspectionChecklistListDto implements IInspectionChecklistListDto {
    checklistCode: string | undefined;
    name: string | undefined;
    plantId: number;
    subModuleId: number;
    userEnteredPlantId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IInspectionChecklistListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistCode = _data["checklistCode"];
            this.name = _data["name"];
            this.plantId = _data["plantId"];
            this.subModuleId = _data["subModuleId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredSubModuleId = _data["userEnteredSubModuleId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InspectionChecklistListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionChecklistListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistCode"] = this.checklistCode;
        data["name"] = this.name;
        data["plantId"] = this.plantId;
        data["subModuleId"] = this.subModuleId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredSubModuleId"] = this.userEnteredSubModuleId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): InspectionChecklistListDto {
        const json = this.toJSON();
        let result = new InspectionChecklistListDto();
        result.init(json);
        return result;
    }
}

export interface IInspectionChecklistListDto {
    checklistCode: string | undefined;
    name: string | undefined;
    plantId: number;
    subModuleId: number;
    userEnteredPlantId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class InspectionChecklistListDtoPagedResultDto implements IInspectionChecklistListDtoPagedResultDto {
    totalCount: number;
    items: InspectionChecklistListDto[] | undefined;

    constructor(data?: IInspectionChecklistListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InspectionChecklistListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InspectionChecklistListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionChecklistListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): InspectionChecklistListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InspectionChecklistListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInspectionChecklistListDtoPagedResultDto {
    totalCount: number;
    items: InspectionChecklistListDto[] | undefined;
}

export class CreateInspectionChecklistDto implements ICreateInspectionChecklistDto {
    checklistCode: string | undefined;
    name: string;
    plantId: number;
    subModuleId: number;
    isActive: boolean;
    description: string | undefined;
    version: number;
    formatNumber: string | undefined;
    checklistTypeId: number;
    modeId: number;
    checkpoints: CheckpointDto[];

    constructor(data?: ICreateInspectionChecklistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checkpoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checklistCode = _data["checklistCode"];
            this.name = _data["name"];
            this.plantId = _data["plantId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.version = _data["version"];
            this.formatNumber = _data["formatNumber"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.modeId = _data["modeId"];
            if (Array.isArray(_data["checkpoints"])) {
                this.checkpoints = [] as any;
                for (let item of _data["checkpoints"])
                    this.checkpoints.push(CheckpointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInspectionChecklistDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInspectionChecklistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checklistCode"] = this.checklistCode;
        data["name"] = this.name;
        data["plantId"] = this.plantId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["version"] = this.version;
        data["formatNumber"] = this.formatNumber;
        data["checklistTypeId"] = this.checklistTypeId;
        data["modeId"] = this.modeId;
        if (Array.isArray(this.checkpoints)) {
            data["checkpoints"] = [];
            for (let item of this.checkpoints)
                data["checkpoints"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateInspectionChecklistDto {
        const json = this.toJSON();
        let result = new CreateInspectionChecklistDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInspectionChecklistDto {
    checklistCode: string | undefined;
    name: string;
    plantId: number;
    subModuleId: number;
    isActive: boolean;
    description: string | undefined;
    version: number;
    formatNumber: string | undefined;
    checklistTypeId: number;
    modeId: number;
    checkpoints: CheckpointDto[];
}

export class EquipmentUsageLogList implements IEquipmentUsageLogList {
    equipmentUsageHeaderId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IEquipmentUsageLogList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentUsageHeaderId = _data["equipmentUsageHeaderId"];
            this.checkpointId = _data["checkpointId"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EquipmentUsageLogList {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentUsageLogList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentUsageHeaderId"] = this.equipmentUsageHeaderId;
        data["checkpointId"] = this.checkpointId;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EquipmentUsageLogList {
        const json = this.toJSON();
        let result = new EquipmentUsageLogList();
        result.init(json);
        return result;
    }
}

export interface IEquipmentUsageLogList {
    equipmentUsageHeaderId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class AreaUsageListLog implements IAreaUsageListLog {
    areaUsageHeaderId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IAreaUsageListLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaUsageHeaderId = _data["areaUsageHeaderId"];
            this.checkpointId = _data["checkpointId"];
            this.observation = _data["observation"];
            this.discrepancyRemark = _data["discrepancyRemark"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AreaUsageListLog {
        data = typeof data === 'object' ? data : {};
        let result = new AreaUsageListLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaUsageHeaderId"] = this.areaUsageHeaderId;
        data["checkpointId"] = this.checkpointId;
        data["observation"] = this.observation;
        data["discrepancyRemark"] = this.discrepancyRemark;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): AreaUsageListLog {
        const json = this.toJSON();
        let result = new AreaUsageListLog();
        result.init(json);
        return result;
    }
}

export interface IAreaUsageListLog {
    areaUsageHeaderId: number | undefined;
    checkpointId: number | undefined;
    observation: string;
    discrepancyRemark: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CheckpointMaster implements ICheckpointMaster {
    inspectionChecklistId: number | undefined;
    checkpointName: string;
    checkpointTypeId: number;
    modeId: number;
    tenantId: number | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    vehicleInspectionDetails: VehicleInspectionDetail[] | undefined;
    materialChecklistDetails: MaterialChecklistDetail[] | undefined;
    wmCalibrationCheckpoints: WMCalibrationCheckpoint[] | undefined;
    cubicleCleaningCheckpoints: CubicleCleaningCheckpoint[] | undefined;
    lineClearanceCheckpoints: LineClearanceCheckpoint[] | undefined;
    equipmentUsageLogList: EquipmentUsageLogList[] | undefined;
    areaUsageListLog: AreaUsageListLog[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: ICheckpointMaster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.checkpointName = _data["checkpointName"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.modeId = _data["modeId"];
            this.tenantId = _data["tenantId"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            if (Array.isArray(_data["vehicleInspectionDetails"])) {
                this.vehicleInspectionDetails = [] as any;
                for (let item of _data["vehicleInspectionDetails"])
                    this.vehicleInspectionDetails.push(VehicleInspectionDetail.fromJS(item));
            }
            if (Array.isArray(_data["materialChecklistDetails"])) {
                this.materialChecklistDetails = [] as any;
                for (let item of _data["materialChecklistDetails"])
                    this.materialChecklistDetails.push(MaterialChecklistDetail.fromJS(item));
            }
            if (Array.isArray(_data["wmCalibrationCheckpoints"])) {
                this.wmCalibrationCheckpoints = [] as any;
                for (let item of _data["wmCalibrationCheckpoints"])
                    this.wmCalibrationCheckpoints.push(WMCalibrationCheckpoint.fromJS(item));
            }
            if (Array.isArray(_data["cubicleCleaningCheckpoints"])) {
                this.cubicleCleaningCheckpoints = [] as any;
                for (let item of _data["cubicleCleaningCheckpoints"])
                    this.cubicleCleaningCheckpoints.push(CubicleCleaningCheckpoint.fromJS(item));
            }
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(LineClearanceCheckpoint.fromJS(item));
            }
            if (Array.isArray(_data["equipmentUsageLogList"])) {
                this.equipmentUsageLogList = [] as any;
                for (let item of _data["equipmentUsageLogList"])
                    this.equipmentUsageLogList.push(EquipmentUsageLogList.fromJS(item));
            }
            if (Array.isArray(_data["areaUsageListLog"])) {
                this.areaUsageListLog = [] as any;
                for (let item of _data["areaUsageListLog"])
                    this.areaUsageListLog.push(AreaUsageListLog.fromJS(item));
            }
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CheckpointMaster {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointMaster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["checkpointName"] = this.checkpointName;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["modeId"] = this.modeId;
        data["tenantId"] = this.tenantId;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        if (Array.isArray(this.vehicleInspectionDetails)) {
            data["vehicleInspectionDetails"] = [];
            for (let item of this.vehicleInspectionDetails)
                data["vehicleInspectionDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.materialChecklistDetails)) {
            data["materialChecklistDetails"] = [];
            for (let item of this.materialChecklistDetails)
                data["materialChecklistDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.wmCalibrationCheckpoints)) {
            data["wmCalibrationCheckpoints"] = [];
            for (let item of this.wmCalibrationCheckpoints)
                data["wmCalibrationCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.cubicleCleaningCheckpoints)) {
            data["cubicleCleaningCheckpoints"] = [];
            for (let item of this.cubicleCleaningCheckpoints)
                data["cubicleCleaningCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.equipmentUsageLogList)) {
            data["equipmentUsageLogList"] = [];
            for (let item of this.equipmentUsageLogList)
                data["equipmentUsageLogList"].push(item.toJSON());
        }
        if (Array.isArray(this.areaUsageListLog)) {
            data["areaUsageListLog"] = [];
            for (let item of this.areaUsageListLog)
                data["areaUsageListLog"].push(item.toJSON());
        }
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CheckpointMaster {
        const json = this.toJSON();
        let result = new CheckpointMaster();
        result.init(json);
        return result;
    }
}

export interface ICheckpointMaster {
    inspectionChecklistId: number | undefined;
    checkpointName: string;
    checkpointTypeId: number;
    modeId: number;
    tenantId: number | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    vehicleInspectionDetails: VehicleInspectionDetail[] | undefined;
    materialChecklistDetails: MaterialChecklistDetail[] | undefined;
    wmCalibrationCheckpoints: WMCalibrationCheckpoint[] | undefined;
    cubicleCleaningCheckpoints: CubicleCleaningCheckpoint[] | undefined;
    lineClearanceCheckpoints: LineClearanceCheckpoint[] | undefined;
    equipmentUsageLogList: EquipmentUsageLogList[] | undefined;
    areaUsageListLog: AreaUsageListLog[] | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class MaterialSelectWithDescriptionDto implements IMaterialSelectWithDescriptionDto {
    value: string | undefined;
    description: string | undefined;
    selfLife: number | undefined;
    purchaseOrderDeliverSchedule: number;
    id: number;

    constructor(data?: IMaterialSelectWithDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.description = _data["description"];
            this.selfLife = _data["selfLife"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialSelectWithDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialSelectWithDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["description"] = this.description;
        data["selfLife"] = this.selfLife;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialSelectWithDescriptionDto {
        const json = this.toJSON();
        let result = new MaterialSelectWithDescriptionDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialSelectWithDescriptionDto {
    value: string | undefined;
    description: string | undefined;
    selfLife: number | undefined;
    purchaseOrderDeliverSchedule: number;
    id: number;
}

export class WeighingMachineSelectWithDetailsDto implements IWeighingMachineSelectWithDetailsDto {
    weighingMachineCode: string | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    subPlantId: number | undefined;
    weight: number | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    id: number;

    constructor(data?: IWeighingMachineSelectWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.subPlantId = _data["subPlantId"];
            this.weight = _data["weight"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineSelectWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineSelectWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["subPlantId"] = this.subPlantId;
        data["weight"] = this.weight;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineSelectWithDetailsDto {
        const json = this.toJSON();
        let result = new WeighingMachineSelectWithDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineSelectWithDetailsDto {
    weighingMachineCode: string | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    subPlantId: number | undefined;
    weight: number | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    id: number;
}

export class MaterialConsignmentDto implements IMaterialConsignmentDto {
    manufacturedBatchNo: string | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    qtyAsPerInvoice: number | undefined;
    qtyAsPerInvoiceInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    sequenceId: number | undefined;
    materialRelationId: number | undefined;
    remainingDaysLeftForExpiry: number;
    remainingDaysLeftForRetest: number;
    statusForExpiry: string | undefined;
    statusForRetest: string | undefined;
    id: number;

    constructor(data?: IMaterialConsignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.manufacturedBatchNo = _data["manufacturedBatchNo"];
            this.manufacturedDate = _data["manufacturedDate"] ? moment(_data["manufacturedDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.qtyAsPerInvoice = _data["qtyAsPerInvoice"];
            this.qtyAsPerInvoiceInDecimal = _data["qtyAsPerInvoiceInDecimal"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.sequenceId = _data["sequenceId"];
            this.materialRelationId = _data["materialRelationId"];
            this.remainingDaysLeftForExpiry = _data["remainingDaysLeftForExpiry"];
            this.remainingDaysLeftForRetest = _data["remainingDaysLeftForRetest"];
            this.statusForExpiry = _data["statusForExpiry"];
            this.statusForRetest = _data["statusForRetest"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialConsignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialConsignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["manufacturedBatchNo"] = this.manufacturedBatchNo;
        data["manufacturedDate"] = this.manufacturedDate ? this.manufacturedDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["qtyAsPerInvoice"] = this.qtyAsPerInvoice;
        data["qtyAsPerInvoiceInDecimal"] = this.qtyAsPerInvoiceInDecimal;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["sequenceId"] = this.sequenceId;
        data["materialRelationId"] = this.materialRelationId;
        data["remainingDaysLeftForExpiry"] = this.remainingDaysLeftForExpiry;
        data["remainingDaysLeftForRetest"] = this.remainingDaysLeftForRetest;
        data["statusForExpiry"] = this.statusForExpiry;
        data["statusForRetest"] = this.statusForRetest;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialConsignmentDto {
        const json = this.toJSON();
        let result = new MaterialConsignmentDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialConsignmentDto {
    manufacturedBatchNo: string | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    retestDate: moment.Moment | undefined;
    qtyAsPerInvoice: number | undefined;
    qtyAsPerInvoiceInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    sequenceId: number | undefined;
    materialRelationId: number | undefined;
    remainingDaysLeftForExpiry: number;
    remainingDaysLeftForRetest: number;
    statusForExpiry: string | undefined;
    statusForRetest: string | undefined;
    id: number;
}

export class MaterialBarcodePrintingDto implements IMaterialBarcodePrintingDto {
    materialBarcode: string | undefined;
    containerNumber: number;
    sapBatchNumber: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    plantId: number | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    id: number | undefined;

    constructor(data?: IMaterialBarcodePrintingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialBarcode = _data["materialBarcode"];
            this.containerNumber = _data["containerNumber"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.grnDetailId = _data["grnDetailId"];
            this.containerId = _data["containerId"];
            this.plantId = _data["plantId"];
            this.palletBarcode = _data["palletBarcode"];
            this.materialDescription = _data["materialDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialBarcodePrintingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialBarcodePrintingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialBarcode"] = this.materialBarcode;
        data["containerNumber"] = this.containerNumber;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["grnDetailId"] = this.grnDetailId;
        data["containerId"] = this.containerId;
        data["plantId"] = this.plantId;
        data["palletBarcode"] = this.palletBarcode;
        data["materialDescription"] = this.materialDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialBarcodePrintingDto {
        const json = this.toJSON();
        let result = new MaterialBarcodePrintingDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialBarcodePrintingDto {
    materialBarcode: string | undefined;
    containerNumber: number;
    sapBatchNumber: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    plantId: number | undefined;
    palletBarcode: string | undefined;
    materialDescription: string | undefined;
    id: number | undefined;
}

export class UnitOfMeasurementListDto implements IUnitOfMeasurementListDto {
    uomCode: string | undefined;
    name: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string | undefined;
    isActive: boolean;
    userEnteredUOMType: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    actualUom: string | undefined;
    id: number;

    constructor(data?: IUnitOfMeasurementListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uomCode = _data["uomCode"];
            this.name = _data["name"];
            this.unitOfMeasurementTypeId = _data["unitOfMeasurementTypeId"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.isActive = _data["isActive"];
            this.userEnteredUOMType = _data["userEnteredUOMType"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.actualUom = _data["actualUom"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UnitOfMeasurementListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitOfMeasurementListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uomCode"] = this.uomCode;
        data["name"] = this.name;
        data["unitOfMeasurementTypeId"] = this.unitOfMeasurementTypeId;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["isActive"] = this.isActive;
        data["userEnteredUOMType"] = this.userEnteredUOMType;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["actualUom"] = this.actualUom;
        data["id"] = this.id;
        return data; 
    }

    clone(): UnitOfMeasurementListDto {
        const json = this.toJSON();
        let result = new UnitOfMeasurementListDto();
        result.init(json);
        return result;
    }
}

export interface IUnitOfMeasurementListDto {
    uomCode: string | undefined;
    name: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string | undefined;
    isActive: boolean;
    userEnteredUOMType: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    actualUom: string | undefined;
    id: number;
}

export class PurchaseOrderInternalDto implements IPurchaseOrderInternalDto {
    plantId: number;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    materials: MaterialInternalDto[] | undefined;
    purchaseOrderDeliverSchedule: number;
    id: number;

    constructor(data?: IPurchaseOrderInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.purchaseOrderDate = _data["purchaseOrderDate"] ? moment(_data["purchaseOrderDate"].toString()) : <any>undefined;
            this.vendorName = _data["vendorName"];
            this.vendorCode = _data["vendorCode"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials.push(MaterialInternalDto.fromJS(item));
            }
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseOrderInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["purchaseOrderDate"] = this.purchaseOrderDate ? this.purchaseOrderDate.toISOString() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["vendorCode"] = this.vendorCode;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["id"] = this.id;
        return data; 
    }

    clone(): PurchaseOrderInternalDto {
        const json = this.toJSON();
        let result = new PurchaseOrderInternalDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderInternalDto {
    plantId: number;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    materials: MaterialInternalDto[] | undefined;
    purchaseOrderDeliverSchedule: number;
    id: number;
}

export class IssueToProductionDto implements IIssueToProductionDto {
    processOrderNo: string | undefined;
    materialCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    product: string | undefined;
    productBatch: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    dispensedQty: number | undefined;
    uom: string | undefined;
    mvtType: string | undefined;
    storage_location: string | undefined;
    materialIssueNoteNo: string | undefined;
    isSelected: boolean;
    tenantId: number | undefined;
    dispensingHeaderId: number | undefined;
    id: number;

    constructor(data?: IIssueToProductionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderNo = _data["processOrderNo"];
            this.materialCode = _data["materialCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialDescription = _data["materialDescription"];
            this.product = _data["product"];
            this.productBatch = _data["productBatch"];
            this.arNo = _data["arNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.dispensedQty = _data["dispensedQty"];
            this.uom = _data["uom"];
            this.mvtType = _data["mvtType"];
            this.storage_location = _data["storage_location"];
            this.materialIssueNoteNo = _data["materialIssueNoteNo"];
            this.isSelected = _data["isSelected"];
            this.tenantId = _data["tenantId"];
            this.dispensingHeaderId = _data["dispensingHeaderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IssueToProductionDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssueToProductionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderNo"] = this.processOrderNo;
        data["materialCode"] = this.materialCode;
        data["lineItemNo"] = this.lineItemNo;
        data["materialDescription"] = this.materialDescription;
        data["product"] = this.product;
        data["productBatch"] = this.productBatch;
        data["arNo"] = this.arNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["dispensedQty"] = this.dispensedQty;
        data["uom"] = this.uom;
        data["mvtType"] = this.mvtType;
        data["storage_location"] = this.storage_location;
        data["materialIssueNoteNo"] = this.materialIssueNoteNo;
        data["isSelected"] = this.isSelected;
        data["tenantId"] = this.tenantId;
        data["dispensingHeaderId"] = this.dispensingHeaderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): IssueToProductionDto {
        const json = this.toJSON();
        let result = new IssueToProductionDto();
        result.init(json);
        return result;
    }
}

export interface IIssueToProductionDto {
    processOrderNo: string | undefined;
    materialCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    product: string | undefined;
    productBatch: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    dispensedQty: number | undefined;
    uom: string | undefined;
    mvtType: string | undefined;
    storage_location: string | undefined;
    materialIssueNoteNo: string | undefined;
    isSelected: boolean;
    tenantId: number | undefined;
    dispensingHeaderId: number | undefined;
    id: number;
}

export class CreateIssueToProductionDto implements ICreateIssueToProductionDto {
    issueToProductionDetails: IssueToProductionDto[] | undefined;

    constructor(data?: ICreateIssueToProductionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueToProductionDetails"])) {
                this.issueToProductionDetails = [] as any;
                for (let item of _data["issueToProductionDetails"])
                    this.issueToProductionDetails.push(IssueToProductionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateIssueToProductionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIssueToProductionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueToProductionDetails)) {
            data["issueToProductionDetails"] = [];
            for (let item of this.issueToProductionDetails)
                data["issueToProductionDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateIssueToProductionDto {
        const json = this.toJSON();
        let result = new CreateIssueToProductionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateIssueToProductionDto {
    issueToProductionDetails: IssueToProductionDto[] | undefined;
}

export class CreateLineClearanceTransactionDto implements ICreateLineClearanceTransactionDto {
    lineClearanceDate: moment.Moment;
    cubicleId: number;
    areaId: number;
    groupId: number;
    groupName: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifierBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    canApproved: boolean;
    id: number;

    constructor(data?: ICreateLineClearanceTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineClearanceDate = _data["lineClearanceDate"] ? moment(_data["lineClearanceDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.areaId = _data["areaId"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.approvedBy = _data["approvedBy"];
            this.verifierBy = _data["verifierBy"];
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isVerified = _data["isVerified"];
            this.canApproved = _data["canApproved"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateLineClearanceTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLineClearanceTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineClearanceDate"] = this.lineClearanceDate ? this.lineClearanceDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["areaId"] = this.areaId;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["verifierBy"] = this.verifierBy;
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        data["isVerified"] = this.isVerified;
        data["canApproved"] = this.canApproved;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateLineClearanceTransactionDto {
        const json = this.toJSON();
        let result = new CreateLineClearanceTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateLineClearanceTransactionDto {
    lineClearanceDate: moment.Moment;
    cubicleId: number;
    areaId: number;
    groupId: number;
    groupName: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifierBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    canApproved: boolean;
    id: number;
}

export class LineClearanceTransactionDto implements ILineClearanceTransactionDto {
    clearanceDate: moment.Moment;
    cubicleId: number;
    areaId: number;
    groupId: number;
    groupName: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    isApproved: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    id: number;

    constructor(data?: ILineClearanceTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.cubicleId = _data["cubicleId"];
            this.areaId = _data["areaId"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isVerified = _data["isVerified"];
            this.isApproved = _data["isApproved"];
            this.canApproved = _data["canApproved"];
            this.canVerified = _data["canVerified"];
            this.approvedByName = _data["approvedByName"];
            this.creatorName = _data["creatorName"];
            this.isInValidTransaction = _data["isInValidTransaction"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LineClearanceTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LineClearanceTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["cubicleId"] = this.cubicleId;
        data["areaId"] = this.areaId;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        data["isVerified"] = this.isVerified;
        data["isApproved"] = this.isApproved;
        data["canApproved"] = this.canApproved;
        data["canVerified"] = this.canVerified;
        data["approvedByName"] = this.approvedByName;
        data["creatorName"] = this.creatorName;
        data["isInValidTransaction"] = this.isInValidTransaction;
        data["id"] = this.id;
        return data; 
    }

    clone(): LineClearanceTransactionDto {
        const json = this.toJSON();
        let result = new LineClearanceTransactionDto();
        result.init(json);
        return result;
    }
}

export interface ILineClearanceTransactionDto {
    clearanceDate: moment.Moment;
    cubicleId: number;
    areaId: number;
    groupId: number;
    groupName: number;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    isApproved: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    id: number;
}

export class LoadingDto implements ILoadingDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;

    constructor(data?: ILoadingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.putawayId = _data["putawayId"];
            this.pickingId = _data["pickingId"];
            this.productBatchNo = _data["productBatchNo"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.customerName = _data["customerName"];
            this.customerAddress = _data["customerAddress"];
            this.transportName = _data["transportName"];
            this.vehicleNo = _data["vehicleNo"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LoadingDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["putawayId"] = this.putawayId;
        data["pickingId"] = this.pickingId;
        data["productBatchNo"] = this.productBatchNo;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["customerName"] = this.customerName;
        data["customerAddress"] = this.customerAddress;
        data["transportName"] = this.transportName;
        data["vehicleNo"] = this.vehicleNo;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LoadingDto {
        const json = this.toJSON();
        let result = new LoadingDto();
        result.init(json);
        return result;
    }
}

export interface ILoadingDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;
}

export class LoadingListDto implements ILoadingListDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;

    constructor(data?: ILoadingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.putawayId = _data["putawayId"];
            this.pickingId = _data["pickingId"];
            this.productBatchNo = _data["productBatchNo"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.customerName = _data["customerName"];
            this.customerAddress = _data["customerAddress"];
            this.transportName = _data["transportName"];
            this.vehicleNo = _data["vehicleNo"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LoadingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["putawayId"] = this.putawayId;
        data["pickingId"] = this.pickingId;
        data["productBatchNo"] = this.productBatchNo;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["customerName"] = this.customerName;
        data["customerAddress"] = this.customerAddress;
        data["transportName"] = this.transportName;
        data["vehicleNo"] = this.vehicleNo;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LoadingListDto {
        const json = this.toJSON();
        let result = new LoadingListDto();
        result.init(json);
        return result;
    }
}

export interface ILoadingListDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    id: number;
}

export class LoadingListDtoPagedResultDto implements ILoadingListDtoPagedResultDto {
    totalCount: number;
    items: LoadingListDto[] | undefined;

    constructor(data?: ILoadingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LoadingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoadingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LoadingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LoadingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILoadingListDtoPagedResultDto {
    totalCount: number;
    items: LoadingListDto[] | undefined;
}

export class LocationDto implements ILocationDto {
    locationCode: string;
    storageLocationType: string;
    areaId: number;
    plantId: number;
    departmentId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCode = _data["locationCode"];
            this.storageLocationType = _data["storageLocationType"];
            this.areaId = _data["areaId"];
            this.plantId = _data["plantId"];
            this.departmentId = _data["departmentId"];
            this.zone = _data["zone"];
            this.locationTemperature = _data["locationTemperature"];
            this.locationTemperatureUL = _data["locationTemperatureUL"];
            this.temperatureUnit = _data["temperatureUnit"];
            this.slocType = _data["slocType"];
            this.levelId = _data["levelId"];
            this.description = _data["description"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCode"] = this.locationCode;
        data["storageLocationType"] = this.storageLocationType;
        data["areaId"] = this.areaId;
        data["plantId"] = this.plantId;
        data["departmentId"] = this.departmentId;
        data["zone"] = this.zone;
        data["locationTemperature"] = this.locationTemperature;
        data["locationTemperatureUL"] = this.locationTemperatureUL;
        data["temperatureUnit"] = this.temperatureUnit;
        data["slocType"] = this.slocType;
        data["levelId"] = this.levelId;
        data["description"] = this.description;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): LocationDto {
        const json = this.toJSON();
        let result = new LocationDto();
        result.init(json);
        return result;
    }
}

export interface ILocationDto {
    locationCode: string;
    storageLocationType: string;
    areaId: number;
    plantId: number;
    departmentId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class LocationListDto implements ILocationListDto {
    locationCode: string | undefined;
    storageLocationType: string | undefined;
    area: number;
    plantId: number;
    departmentId: number;
    userEnteredPlantId: string | undefined;
    userEnteredAreaId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: ILocationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCode = _data["locationCode"];
            this.storageLocationType = _data["storageLocationType"];
            this.area = _data["area"];
            this.plantId = _data["plantId"];
            this.departmentId = _data["departmentId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.userEnteredAreaId = _data["userEnteredAreaId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LocationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCode"] = this.locationCode;
        data["storageLocationType"] = this.storageLocationType;
        data["area"] = this.area;
        data["plantId"] = this.plantId;
        data["departmentId"] = this.departmentId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["userEnteredAreaId"] = this.userEnteredAreaId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): LocationListDto {
        const json = this.toJSON();
        let result = new LocationListDto();
        result.init(json);
        return result;
    }
}

export interface ILocationListDto {
    locationCode: string | undefined;
    storageLocationType: string | undefined;
    area: number;
    plantId: number;
    departmentId: number;
    userEnteredPlantId: string | undefined;
    userEnteredAreaId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class LocationListDtoPagedResultDto implements ILocationListDtoPagedResultDto {
    totalCount: number;
    items: LocationListDto[] | undefined;

    constructor(data?: ILocationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LocationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LocationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILocationListDtoPagedResultDto {
    totalCount: number;
    items: LocationListDto[] | undefined;
}

export class CreateLocationDto implements ICreateLocationDto {
    locationCode: string;
    storageLocationType: string;
    areaId: number;
    plantId: number;
    departmentId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCode = _data["locationCode"];
            this.storageLocationType = _data["storageLocationType"];
            this.areaId = _data["areaId"];
            this.plantId = _data["plantId"];
            this.departmentId = _data["departmentId"];
            this.zone = _data["zone"];
            this.locationTemperature = _data["locationTemperature"];
            this.locationTemperatureUL = _data["locationTemperatureUL"];
            this.temperatureUnit = _data["temperatureUnit"];
            this.slocType = _data["slocType"];
            this.levelId = _data["levelId"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCode"] = this.locationCode;
        data["storageLocationType"] = this.storageLocationType;
        data["areaId"] = this.areaId;
        data["plantId"] = this.plantId;
        data["departmentId"] = this.departmentId;
        data["zone"] = this.zone;
        data["locationTemperature"] = this.locationTemperature;
        data["locationTemperatureUL"] = this.locationTemperatureUL;
        data["temperatureUnit"] = this.temperatureUnit;
        data["slocType"] = this.slocType;
        data["levelId"] = this.levelId;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateLocationDto {
        const json = this.toJSON();
        let result = new CreateLocationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateLocationDto {
    locationCode: string;
    storageLocationType: string;
    areaId: number;
    plantId: number;
    departmentId: number;
    zone: string | undefined;
    locationTemperature: number | undefined;
    locationTemperatureUL: number | undefined;
    temperatureUnit: number | undefined;
    slocType: string | undefined;
    levelId: number | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class SAPMaterial implements ISAPMaterial {
    materialCode: string;
    materialDescription: string | undefined;
    baseUOM: string;
    grade: string;
    denominator: number;
    numerator: number;
    conversionUOM: string;
    materialType: string;
    flag: number | undefined;

    constructor(data?: ISAPMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.baseUOM = _data["baseUOM"];
            this.grade = _data["grade"];
            this.denominator = _data["denominator"];
            this.numerator = _data["numerator"];
            this.conversionUOM = _data["conversionUOM"];
            this.materialType = _data["materialType"];
            this.flag = _data["flag"];
        }
    }

    static fromJS(data: any): SAPMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new SAPMaterial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["baseUOM"] = this.baseUOM;
        data["grade"] = this.grade;
        data["denominator"] = this.denominator;
        data["numerator"] = this.numerator;
        data["conversionUOM"] = this.conversionUOM;
        data["materialType"] = this.materialType;
        data["flag"] = this.flag;
        return data; 
    }

    clone(): SAPMaterial {
        const json = this.toJSON();
        let result = new SAPMaterial();
        result.init(json);
        return result;
    }
}

export interface ISAPMaterial {
    materialCode: string;
    materialDescription: string | undefined;
    baseUOM: string;
    grade: string;
    denominator: number;
    numerator: number;
    conversionUOM: string;
    materialType: string;
    flag: number | undefined;
}

export class MaterialDispensingDto implements IMaterialDispensingDto {
    rlafId: number;
    rlafCode: string | undefined;
    processOrderId: number;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    requiredQty: number | undefined;
    balanceQty: number | undefined;
    baseUnitOfMeasurement: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    dispensingBarcode: string | undefined;
    checkedBy: string | undefined;
    materialContainerId: number | undefined;
    isVerified: number | undefined;
    verified: boolean;
    verifiedBy: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    materialBatchDispensingHeaderId: number | undefined;
    materialBatchDispensingContainerDetailsId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    deviceId: number | undefined;
    reprintDeviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    statusId: number | undefined;
    sapbBatchNumberSelectList: SelectListDto[] | undefined;
    isPackUOM: boolean;
    isController: boolean;
    materialContainerBalanceQuantity: number | undefined;
    materialDispensingDetailIdToReprint: number;
    isAnySAPBatchNoExistForHeader: boolean;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    issueIndicator: boolean;
    isSampling: boolean;
    readonly requiredQuantityWithUOM: string | undefined;
    readonly balanceQuantityWithUOM: string | undefined;
    noOfContainers: number;
    id: number;

    constructor(data?: IMaterialDispensingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rlafId = _data["rlafId"];
            this.rlafCode = _data["rlafCode"];
            this.processOrderId = _data["processOrderId"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.requiredQty = _data["requiredQty"];
            this.balanceQty = _data["balanceQty"];
            this.baseUnitOfMeasurement = _data["baseUnitOfMeasurement"];
            this.baseUnitOfMeasurementId = _data["baseUnitOfMeasurementId"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.dispensingBarcode = _data["dispensingBarcode"];
            this.checkedBy = _data["checkedBy"];
            this.materialContainerId = _data["materialContainerId"];
            this.isVerified = _data["isVerified"];
            this.verified = _data["verified"];
            this.verifiedBy = _data["verifiedBy"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
            this.printed = _data["printed"];
            this.materialBatchDispensingHeaderId = _data["materialBatchDispensingHeaderId"];
            this.materialBatchDispensingContainerDetailsId = _data["materialBatchDispensingContainerDetailsId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            if (Array.isArray(_data["suggestedBalanceIds"])) {
                this.suggestedBalanceIds = [] as any;
                for (let item of _data["suggestedBalanceIds"])
                    this.suggestedBalanceIds.push(SelectListDto.fromJS(item));
            }
            this.commsSepratedSuggestedBalanceIds = _data["commsSepratedSuggestedBalanceIds"];
            this.balanceCode = _data["balanceCode"];
            this.balanceId = _data["balanceId"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.grossWeight = _data["grossWeight"];
            this.noOfPacks = _data["noOfPacks"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.deviceId = _data["deviceId"];
            this.reprintDeviceId = _data["reprintDeviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["sapbBatchNumberSelectList"])) {
                this.sapbBatchNumberSelectList = [] as any;
                for (let item of _data["sapbBatchNumberSelectList"])
                    this.sapbBatchNumberSelectList.push(SelectListDto.fromJS(item));
            }
            this.isPackUOM = _data["isPackUOM"];
            this.isController = _data["isController"];
            this.materialContainerBalanceQuantity = _data["materialContainerBalanceQuantity"];
            this.materialDispensingDetailIdToReprint = _data["materialDispensingDetailIdToReprint"];
            this.isAnySAPBatchNoExistForHeader = _data["isAnySAPBatchNoExistForHeader"];
            this.convertedNoOfPack = _data["convertedNoOfPack"];
            this.convertedNetWeight = _data["convertedNetWeight"];
            this.issueIndicator = _data["issueIndicator"];
            this.isSampling = _data["isSampling"];
            (<any>this).requiredQuantityWithUOM = _data["requiredQuantityWithUOM"];
            (<any>this).balanceQuantityWithUOM = _data["balanceQuantityWithUOM"];
            this.noOfContainers = _data["noOfContainers"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialDispensingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDispensingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rlafId"] = this.rlafId;
        data["rlafCode"] = this.rlafCode;
        data["processOrderId"] = this.processOrderId;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["requiredQty"] = this.requiredQty;
        data["balanceQty"] = this.balanceQty;
        data["baseUnitOfMeasurement"] = this.baseUnitOfMeasurement;
        data["baseUnitOfMeasurementId"] = this.baseUnitOfMeasurementId;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["dispensingBarcode"] = this.dispensingBarcode;
        data["checkedBy"] = this.checkedBy;
        data["materialContainerId"] = this.materialContainerId;
        data["isVerified"] = this.isVerified;
        data["verified"] = this.verified;
        data["verifiedBy"] = this.verifiedBy;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        data["printed"] = this.printed;
        data["materialBatchDispensingHeaderId"] = this.materialBatchDispensingHeaderId;
        data["materialBatchDispensingContainerDetailsId"] = this.materialBatchDispensingContainerDetailsId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        if (Array.isArray(this.suggestedBalanceIds)) {
            data["suggestedBalanceIds"] = [];
            for (let item of this.suggestedBalanceIds)
                data["suggestedBalanceIds"].push(item.toJSON());
        }
        data["commsSepratedSuggestedBalanceIds"] = this.commsSepratedSuggestedBalanceIds;
        data["balanceCode"] = this.balanceCode;
        data["balanceId"] = this.balanceId;
        data["isGrossWeight"] = this.isGrossWeight;
        data["grossWeight"] = this.grossWeight;
        data["noOfPacks"] = this.noOfPacks;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["deviceId"] = this.deviceId;
        data["reprintDeviceId"] = this.reprintDeviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.sapbBatchNumberSelectList)) {
            data["sapbBatchNumberSelectList"] = [];
            for (let item of this.sapbBatchNumberSelectList)
                data["sapbBatchNumberSelectList"].push(item.toJSON());
        }
        data["isPackUOM"] = this.isPackUOM;
        data["isController"] = this.isController;
        data["materialContainerBalanceQuantity"] = this.materialContainerBalanceQuantity;
        data["materialDispensingDetailIdToReprint"] = this.materialDispensingDetailIdToReprint;
        data["isAnySAPBatchNoExistForHeader"] = this.isAnySAPBatchNoExistForHeader;
        data["convertedNoOfPack"] = this.convertedNoOfPack;
        data["convertedNetWeight"] = this.convertedNetWeight;
        data["issueIndicator"] = this.issueIndicator;
        data["isSampling"] = this.isSampling;
        data["requiredQuantityWithUOM"] = this.requiredQuantityWithUOM;
        data["balanceQuantityWithUOM"] = this.balanceQuantityWithUOM;
        data["noOfContainers"] = this.noOfContainers;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialDispensingDto {
        const json = this.toJSON();
        let result = new MaterialDispensingDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDispensingDto {
    rlafId: number;
    rlafCode: string | undefined;
    processOrderId: number;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    requiredQty: number | undefined;
    balanceQty: number | undefined;
    baseUnitOfMeasurement: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    dispensingBarcode: string | undefined;
    checkedBy: string | undefined;
    materialContainerId: number | undefined;
    isVerified: number | undefined;
    verified: boolean;
    verifiedBy: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    materialBatchDispensingHeaderId: number | undefined;
    materialBatchDispensingContainerDetailsId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    deviceId: number | undefined;
    reprintDeviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    statusId: number | undefined;
    sapbBatchNumberSelectList: SelectListDto[] | undefined;
    isPackUOM: boolean;
    isController: boolean;
    materialContainerBalanceQuantity: number | undefined;
    materialDispensingDetailIdToReprint: number;
    isAnySAPBatchNoExistForHeader: boolean;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    issueIndicator: boolean;
    isSampling: boolean;
    requiredQuantityWithUOM: string | undefined;
    balanceQuantityWithUOM: string | undefined;
    noOfContainers: number;
    id: number;
}

export class GetDespensingDetailsStatus implements IGetDespensingDetailsStatus {
    dispensingHeaderId: number | undefined;
    sapBatchNo: string | undefined;
    containerMaterialBarcode: string | undefined;
    dispenseBarcode: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    id: number | undefined;
    printed: boolean;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    noOfContainers: number;

    constructor(data?: IGetDespensingDetailsStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispensingHeaderId = _data["dispensingHeaderId"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.containerMaterialBarcode = _data["containerMaterialBarcode"];
            this.dispenseBarcode = _data["dispenseBarcode"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
            this.id = _data["id"];
            this.printed = _data["printed"];
            this.balanceCode = _data["balanceCode"];
            this.balanceId = _data["balanceId"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.grossWeight = _data["grossWeight"];
            this.noOfPacks = _data["noOfPacks"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.noOfContainers = _data["noOfContainers"];
        }
    }

    static fromJS(data: any): GetDespensingDetailsStatus {
        data = typeof data === 'object' ? data : {};
        let result = new GetDespensingDetailsStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispensingHeaderId"] = this.dispensingHeaderId;
        data["sapBatchNo"] = this.sapBatchNo;
        data["containerMaterialBarcode"] = this.containerMaterialBarcode;
        data["dispenseBarcode"] = this.dispenseBarcode;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        data["id"] = this.id;
        data["printed"] = this.printed;
        data["balanceCode"] = this.balanceCode;
        data["balanceId"] = this.balanceId;
        data["isGrossWeight"] = this.isGrossWeight;
        data["grossWeight"] = this.grossWeight;
        data["noOfPacks"] = this.noOfPacks;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["noOfContainers"] = this.noOfContainers;
        return data; 
    }

    clone(): GetDespensingDetailsStatus {
        const json = this.toJSON();
        let result = new GetDespensingDetailsStatus();
        result.init(json);
        return result;
    }
}

export interface IGetDespensingDetailsStatus {
    dispensingHeaderId: number | undefined;
    sapBatchNo: string | undefined;
    containerMaterialBarcode: string | undefined;
    dispenseBarcode: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    id: number | undefined;
    printed: boolean;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    noOfContainers: number;
}

export class MaterialDispensingDetailDto implements IMaterialDispensingDetailDto {
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    unitOfMeasurement: string | undefined;
    dispensingContainerBarcode: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    readonly grossWeightWithUOM: string | undefined;
    readonly netWeightWithUOM: string | undefined;
    readonly tareWeightWithUOM: string | undefined;
    readonly noOfPacksWithUOM: string | undefined;
    id: number;

    constructor(data?: IMaterialDispensingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noOfPacks = _data["noOfPacks"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.dispensingContainerBarcode = _data["dispensingContainerBarcode"];
            this.doneBy = _data["doneBy"];
            this.checkedById = _data["checkedById"];
            this.printed = _data["printed"];
            (<any>this).grossWeightWithUOM = _data["grossWeightWithUOM"];
            (<any>this).netWeightWithUOM = _data["netWeightWithUOM"];
            (<any>this).tareWeightWithUOM = _data["tareWeightWithUOM"];
            (<any>this).noOfPacksWithUOM = _data["noOfPacksWithUOM"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialDispensingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDispensingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noOfPacks"] = this.noOfPacks;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["dispensingContainerBarcode"] = this.dispensingContainerBarcode;
        data["doneBy"] = this.doneBy;
        data["checkedById"] = this.checkedById;
        data["printed"] = this.printed;
        data["grossWeightWithUOM"] = this.grossWeightWithUOM;
        data["netWeightWithUOM"] = this.netWeightWithUOM;
        data["tareWeightWithUOM"] = this.tareWeightWithUOM;
        data["noOfPacksWithUOM"] = this.noOfPacksWithUOM;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialDispensingDetailDto {
        const json = this.toJSON();
        let result = new MaterialDispensingDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDispensingDetailDto {
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    unitOfMeasurement: string | undefined;
    dispensingContainerBarcode: string | undefined;
    doneBy: number | undefined;
    checkedById: number | undefined;
    printed: boolean;
    grossWeightWithUOM: string | undefined;
    netWeightWithUOM: string | undefined;
    tareWeightWithUOM: string | undefined;
    noOfPacksWithUOM: string | undefined;
    id: number;
}

export class MaterialDamageDto implements IMaterialDamageDto {
    materialRelationId: number | undefined;
    sequenceId: number;
    containerNo: string | undefined;
    remark: string | undefined;
    quantity: number | undefined;
    quantityInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    id: number;

    constructor(data?: IMaterialDamageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialRelationId = _data["materialRelationId"];
            this.sequenceId = _data["sequenceId"];
            this.containerNo = _data["containerNo"];
            this.remark = _data["remark"];
            this.quantity = _data["quantity"];
            this.quantityInDecimal = _data["quantityInDecimal"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialDamageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDamageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRelationId"] = this.materialRelationId;
        data["sequenceId"] = this.sequenceId;
        data["containerNo"] = this.containerNo;
        data["remark"] = this.remark;
        data["quantity"] = this.quantity;
        data["quantityInDecimal"] = this.quantityInDecimal;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialDamageDto {
        const json = this.toJSON();
        let result = new MaterialDamageDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDamageDto {
    materialRelationId: number | undefined;
    sequenceId: number;
    containerNo: string | undefined;
    remark: string | undefined;
    quantity: number | undefined;
    quantityInDecimal: string | undefined;
    unitofMeasurementId: number | undefined;
    id: number;
}

export class MaterialInspectionDto implements IMaterialInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    materialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    materialInspectionTransactionId: number | undefined;
    materialTransactionId: number | undefined;
    invoiceDetails: InvoiceDto;
    materialRelationId: number | undefined;
    materialConsignments: MaterialConsignmentDto[] | undefined;
    materialCheckpoints: CheckpointDto[] | undefined;
    materialDamageDetails: MaterialDamageDto[] | undefined;
    id: number;

    constructor(data?: IMaterialInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.gatePassNo = _data["gatePassNo"];
            this.materialId = _data["materialId"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.materialInspectionTransactionId = _data["materialInspectionTransactionId"];
            this.materialTransactionId = _data["materialTransactionId"];
            this.invoiceDetails = _data["invoiceDetails"] ? InvoiceDto.fromJS(_data["invoiceDetails"]) : <any>undefined;
            this.materialRelationId = _data["materialRelationId"];
            if (Array.isArray(_data["materialConsignments"])) {
                this.materialConsignments = [] as any;
                for (let item of _data["materialConsignments"])
                    this.materialConsignments.push(MaterialConsignmentDto.fromJS(item));
            }
            if (Array.isArray(_data["materialCheckpoints"])) {
                this.materialCheckpoints = [] as any;
                for (let item of _data["materialCheckpoints"])
                    this.materialCheckpoints.push(CheckpointDto.fromJS(item));
            }
            if (Array.isArray(_data["materialDamageDetails"])) {
                this.materialDamageDetails = [] as any;
                for (let item of _data["materialDamageDetails"])
                    this.materialDamageDetails.push(MaterialDamageDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["gatePassNo"] = this.gatePassNo;
        data["materialId"] = this.materialId;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["materialInspectionTransactionId"] = this.materialInspectionTransactionId;
        data["materialTransactionId"] = this.materialTransactionId;
        data["invoiceDetails"] = this.invoiceDetails ? this.invoiceDetails.toJSON() : <any>undefined;
        data["materialRelationId"] = this.materialRelationId;
        if (Array.isArray(this.materialConsignments)) {
            data["materialConsignments"] = [];
            for (let item of this.materialConsignments)
                data["materialConsignments"].push(item.toJSON());
        }
        if (Array.isArray(this.materialCheckpoints)) {
            data["materialCheckpoints"] = [];
            for (let item of this.materialCheckpoints)
                data["materialCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.materialDamageDetails)) {
            data["materialDamageDetails"] = [];
            for (let item of this.materialDamageDetails)
                data["materialDamageDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialInspectionDto {
        const json = this.toJSON();
        let result = new MaterialInspectionDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    materialId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    materialInspectionTransactionId: number | undefined;
    materialTransactionId: number | undefined;
    invoiceDetails: InvoiceDto;
    materialRelationId: number | undefined;
    materialConsignments: MaterialConsignmentDto[] | undefined;
    materialCheckpoints: CheckpointDto[] | undefined;
    materialDamageDetails: MaterialDamageDto[] | undefined;
    id: number;
}

export class MaterialInspectionListDto implements IMaterialInspectionListDto {
    gateEntryId: number | undefined;
    purchaseOrderId: number | undefined;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    lrNo: string | undefined;
    subPlantId: number;
    transactionStatusId: number | undefined;
    userEnteredTransaction: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;

    constructor(data?: IMaterialInspectionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.gatePassNo = _data["gatePassNo"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.lrNo = _data["lrNo"];
            this.subPlantId = _data["subPlantId"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.userEnteredTransaction = _data["userEnteredTransaction"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialInspectionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInspectionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["gatePassNo"] = this.gatePassNo;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["invoiceNo"] = this.invoiceNo;
        data["lrNo"] = this.lrNo;
        data["subPlantId"] = this.subPlantId;
        data["transactionStatusId"] = this.transactionStatusId;
        data["userEnteredTransaction"] = this.userEnteredTransaction;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialInspectionListDto {
        const json = this.toJSON();
        let result = new MaterialInspectionListDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialInspectionListDto {
    gateEntryId: number | undefined;
    purchaseOrderId: number | undefined;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    lrNo: string | undefined;
    subPlantId: number;
    transactionStatusId: number | undefined;
    userEnteredTransaction: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;
}

export class MaterialInspectionListDtoPagedResultDto implements IMaterialInspectionListDtoPagedResultDto {
    totalCount: number;
    items: MaterialInspectionListDto[] | undefined;

    constructor(data?: IMaterialInspectionListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MaterialInspectionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialInspectionListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInspectionListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MaterialInspectionListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MaterialInspectionListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialInspectionListDtoPagedResultDto {
    totalCount: number;
    items: MaterialInspectionListDto[] | undefined;
}

export class CreateMaterialInspectionDto implements ICreateMaterialInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    materialId: number | undefined;
    materialDescription: string | undefined;
    materialHeaderId: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    materialInspectionTransactionId: number | undefined;
    materialTransactionId: number | undefined;
    invoiceDetails: InvoiceDto;
    materialConsignments: MaterialConsignmentDto[] | undefined;
    materialCheckpoints: CheckpointDto[] | undefined;
    materialDamageDetails: MaterialDamageDto[] | undefined;
    transactionStatusId: number | undefined;

    constructor(data?: ICreateMaterialInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.gatePassNo = _data["gatePassNo"];
            this.materialId = _data["materialId"];
            this.materialDescription = _data["materialDescription"];
            this.materialHeaderId = _data["materialHeaderId"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.materialInspectionTransactionId = _data["materialInspectionTransactionId"];
            this.materialTransactionId = _data["materialTransactionId"];
            this.invoiceDetails = _data["invoiceDetails"] ? InvoiceDto.fromJS(_data["invoiceDetails"]) : <any>undefined;
            if (Array.isArray(_data["materialConsignments"])) {
                this.materialConsignments = [] as any;
                for (let item of _data["materialConsignments"])
                    this.materialConsignments.push(MaterialConsignmentDto.fromJS(item));
            }
            if (Array.isArray(_data["materialCheckpoints"])) {
                this.materialCheckpoints = [] as any;
                for (let item of _data["materialCheckpoints"])
                    this.materialCheckpoints.push(CheckpointDto.fromJS(item));
            }
            if (Array.isArray(_data["materialDamageDetails"])) {
                this.materialDamageDetails = [] as any;
                for (let item of _data["materialDamageDetails"])
                    this.materialDamageDetails.push(MaterialDamageDto.fromJS(item));
            }
            this.transactionStatusId = _data["transactionStatusId"];
        }
    }

    static fromJS(data: any): CreateMaterialInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMaterialInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["gatePassNo"] = this.gatePassNo;
        data["materialId"] = this.materialId;
        data["materialDescription"] = this.materialDescription;
        data["materialHeaderId"] = this.materialHeaderId;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["materialInspectionTransactionId"] = this.materialInspectionTransactionId;
        data["materialTransactionId"] = this.materialTransactionId;
        data["invoiceDetails"] = this.invoiceDetails ? this.invoiceDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.materialConsignments)) {
            data["materialConsignments"] = [];
            for (let item of this.materialConsignments)
                data["materialConsignments"].push(item.toJSON());
        }
        if (Array.isArray(this.materialCheckpoints)) {
            data["materialCheckpoints"] = [];
            for (let item of this.materialCheckpoints)
                data["materialCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.materialDamageDetails)) {
            data["materialDamageDetails"] = [];
            for (let item of this.materialDamageDetails)
                data["materialDamageDetails"].push(item.toJSON());
        }
        data["transactionStatusId"] = this.transactionStatusId;
        return data; 
    }

    clone(): CreateMaterialInspectionDto {
        const json = this.toJSON();
        let result = new CreateMaterialInspectionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMaterialInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    materialId: number | undefined;
    materialDescription: string | undefined;
    materialHeaderId: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    materialInspectionTransactionId: number | undefined;
    materialTransactionId: number | undefined;
    invoiceDetails: InvoiceDto;
    materialConsignments: MaterialConsignmentDto[] | undefined;
    materialCheckpoints: CheckpointDto[] | undefined;
    materialDamageDetails: MaterialDamageDto[] | undefined;
    transactionStatusId: number | undefined;
}

export class CompleteInspectionEntityDto implements ICompleteInspectionEntityDto {
    purchaseOrderId: number;
    id: number;

    constructor(data?: ICompleteInspectionEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompleteInspectionEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteInspectionEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CompleteInspectionEntityDto {
        const json = this.toJSON();
        let result = new CompleteInspectionEntityDto();
        result.init(json);
        return result;
    }
}

export interface ICompleteInspectionEntityDto {
    purchaseOrderId: number;
    id: number;
}

export class AcceptRejectInspectionCheckpointDto implements IAcceptRejectInspectionCheckpointDto {
    materialRelationId: number;
    transactionStatusId: number;
    qualityCheckpoints: CheckpointDto[] | undefined;
    id: number;

    constructor(data?: IAcceptRejectInspectionCheckpointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialRelationId = _data["materialRelationId"];
            this.transactionStatusId = _data["transactionStatusId"];
            if (Array.isArray(_data["qualityCheckpoints"])) {
                this.qualityCheckpoints = [] as any;
                for (let item of _data["qualityCheckpoints"])
                    this.qualityCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AcceptRejectInspectionCheckpointDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptRejectInspectionCheckpointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRelationId"] = this.materialRelationId;
        data["transactionStatusId"] = this.transactionStatusId;
        if (Array.isArray(this.qualityCheckpoints)) {
            data["qualityCheckpoints"] = [];
            for (let item of this.qualityCheckpoints)
                data["qualityCheckpoints"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): AcceptRejectInspectionCheckpointDto {
        const json = this.toJSON();
        let result = new AcceptRejectInspectionCheckpointDto();
        result.init(json);
        return result;
    }
}

export interface IAcceptRejectInspectionCheckpointDto {
    materialRelationId: number;
    transactionStatusId: number;
    qualityCheckpoints: CheckpointDto[] | undefined;
    id: number;
}

export class MaterialStatusDto implements IMaterialStatusDto {
    materialCode: string | undefined;
    materialDescription: string | undefined;
    sapBatchNo: string | undefined;
    mfgDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    daysLeftForExpiry: number;
    retestDate: moment.Moment | undefined;
    daysLeftForRetest: number;
    plantId: number;
    grnDetailId: number;
    id: number;

    constructor(data?: IMaterialStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.mfgDate = _data["mfgDate"] ? moment(_data["mfgDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.daysLeftForExpiry = _data["daysLeftForExpiry"];
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.daysLeftForRetest = _data["daysLeftForRetest"];
            this.plantId = _data["plantId"];
            this.grnDetailId = _data["grnDetailId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["sapBatchNo"] = this.sapBatchNo;
        data["mfgDate"] = this.mfgDate ? this.mfgDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["daysLeftForExpiry"] = this.daysLeftForExpiry;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["daysLeftForRetest"] = this.daysLeftForRetest;
        data["plantId"] = this.plantId;
        data["grnDetailId"] = this.grnDetailId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialStatusDto {
        const json = this.toJSON();
        let result = new MaterialStatusDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialStatusDto {
    materialCode: string | undefined;
    materialDescription: string | undefined;
    sapBatchNo: string | undefined;
    mfgDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    daysLeftForExpiry: number;
    retestDate: moment.Moment | undefined;
    daysLeftForRetest: number;
    plantId: number;
    grnDetailId: number;
    id: number;
}

export class MaterialDetailDto implements IMaterialDetailDto {
    materialCode: string | undefined;
    materialDescription: string | undefined;
    vendorCode: string | undefined;
    manufacturerCode: string | undefined;
    mfgBatchNo: string | undefined;
    qcInvDate: moment.Moment | undefined;
    sapBatchNo: string | undefined;
    mgfDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    daysLeftForExpiry: number;
    status: string | undefined;
    retestDate: moment.Moment | undefined;
    releaseDate: moment.Moment | undefined;
    daysLeftForRetest: number;
    grnNo: string | undefined;
    arNo: string | undefined;
    noOfContainer: number;
    totalQtyReceived: string | undefined;
    qtyIssueToProduction: string | undefined;
    rejectedQty: number;
    qtyReturnedFromProduction: string | undefined;
    uom: string | undefined;
    containerNo: number;
    doneBy: string | undefined;
    samplingDate: moment.Moment | undefined;
    releasedBy: string | undefined;
    batchNo: string | undefined;
    processOrder: string | undefined;
    tempStatus: string | undefined;

    constructor(data?: IMaterialDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.vendorCode = _data["vendorCode"];
            this.manufacturerCode = _data["manufacturerCode"];
            this.mfgBatchNo = _data["mfgBatchNo"];
            this.qcInvDate = _data["qcInvDate"] ? moment(_data["qcInvDate"].toString()) : <any>undefined;
            this.sapBatchNo = _data["sapBatchNo"];
            this.mgfDate = _data["mgfDate"] ? moment(_data["mgfDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.daysLeftForExpiry = _data["daysLeftForExpiry"];
            this.status = _data["status"];
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.daysLeftForRetest = _data["daysLeftForRetest"];
            this.grnNo = _data["grnNo"];
            this.arNo = _data["arNo"];
            this.noOfContainer = _data["noOfContainer"];
            this.totalQtyReceived = _data["totalQtyReceived"];
            this.qtyIssueToProduction = _data["qtyIssueToProduction"];
            this.rejectedQty = _data["rejectedQty"];
            this.qtyReturnedFromProduction = _data["qtyReturnedFromProduction"];
            this.uom = _data["uom"];
            this.containerNo = _data["containerNo"];
            this.doneBy = _data["doneBy"];
            this.samplingDate = _data["samplingDate"] ? moment(_data["samplingDate"].toString()) : <any>undefined;
            this.releasedBy = _data["releasedBy"];
            this.batchNo = _data["batchNo"];
            this.processOrder = _data["processOrder"];
            this.tempStatus = _data["tempStatus"];
        }
    }

    static fromJS(data: any): MaterialDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["vendorCode"] = this.vendorCode;
        data["manufacturerCode"] = this.manufacturerCode;
        data["mfgBatchNo"] = this.mfgBatchNo;
        data["qcInvDate"] = this.qcInvDate ? this.qcInvDate.toISOString() : <any>undefined;
        data["sapBatchNo"] = this.sapBatchNo;
        data["mgfDate"] = this.mgfDate ? this.mgfDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["daysLeftForExpiry"] = this.daysLeftForExpiry;
        data["status"] = this.status;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["daysLeftForRetest"] = this.daysLeftForRetest;
        data["grnNo"] = this.grnNo;
        data["arNo"] = this.arNo;
        data["noOfContainer"] = this.noOfContainer;
        data["totalQtyReceived"] = this.totalQtyReceived;
        data["qtyIssueToProduction"] = this.qtyIssueToProduction;
        data["rejectedQty"] = this.rejectedQty;
        data["qtyReturnedFromProduction"] = this.qtyReturnedFromProduction;
        data["uom"] = this.uom;
        data["containerNo"] = this.containerNo;
        data["doneBy"] = this.doneBy;
        data["samplingDate"] = this.samplingDate ? this.samplingDate.toISOString() : <any>undefined;
        data["releasedBy"] = this.releasedBy;
        data["batchNo"] = this.batchNo;
        data["processOrder"] = this.processOrder;
        data["tempStatus"] = this.tempStatus;
        return data; 
    }

    clone(): MaterialDetailDto {
        const json = this.toJSON();
        let result = new MaterialDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDetailDto {
    materialCode: string | undefined;
    materialDescription: string | undefined;
    vendorCode: string | undefined;
    manufacturerCode: string | undefined;
    mfgBatchNo: string | undefined;
    qcInvDate: moment.Moment | undefined;
    sapBatchNo: string | undefined;
    mgfDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    daysLeftForExpiry: number;
    status: string | undefined;
    retestDate: moment.Moment | undefined;
    releaseDate: moment.Moment | undefined;
    daysLeftForRetest: number;
    grnNo: string | undefined;
    arNo: string | undefined;
    noOfContainer: number;
    totalQtyReceived: string | undefined;
    qtyIssueToProduction: string | undefined;
    rejectedQty: number;
    qtyReturnedFromProduction: string | undefined;
    uom: string | undefined;
    containerNo: number;
    doneBy: string | undefined;
    samplingDate: moment.Moment | undefined;
    releasedBy: string | undefined;
    batchNo: string | undefined;
    processOrder: string | undefined;
    tempStatus: string | undefined;
}

export class MaterialRteturnDetailsSAPDto implements IMaterialRteturnDetailsSAPDto {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    productName: string | undefined;
    productBatchNo: string | undefined;
    productId: number | undefined;
    itemName: string | undefined;
    itemCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: string | undefined;

    constructor(data?: IMaterialRteturnDetailsSAPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocumentNo = _data["materialDocumentNo"];
            this.materialDocumentYear = _data["materialDocumentYear"];
            this.productName = _data["productName"];
            this.productBatchNo = _data["productBatchNo"];
            this.productId = _data["productId"];
            this.itemName = _data["itemName"];
            this.itemCode = _data["itemCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialDescription = _data["materialDescription"];
            this.arNo = _data["arNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.qty = _data["qty"];
            this.uom = _data["uom"];
        }
    }

    static fromJS(data: any): MaterialRteturnDetailsSAPDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRteturnDetailsSAPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocumentNo"] = this.materialDocumentNo;
        data["materialDocumentYear"] = this.materialDocumentYear;
        data["productName"] = this.productName;
        data["productBatchNo"] = this.productBatchNo;
        data["productId"] = this.productId;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["lineItemNo"] = this.lineItemNo;
        data["materialDescription"] = this.materialDescription;
        data["arNo"] = this.arNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["qty"] = this.qty;
        data["uom"] = this.uom;
        return data; 
    }

    clone(): MaterialRteturnDetailsSAPDto {
        const json = this.toJSON();
        let result = new MaterialRteturnDetailsSAPDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialRteturnDetailsSAPDto {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    productName: string | undefined;
    productBatchNo: string | undefined;
    productId: number | undefined;
    itemName: string | undefined;
    itemCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: string | undefined;
}

export class MaterialRteturnDetailsSAP implements IMaterialRteturnDetailsSAP {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    productName: string | undefined;
    productBatchNo: string | undefined;
    productId: number;
    itemName: string | undefined;
    itemCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IMaterialRteturnDetailsSAP) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocumentNo = _data["materialDocumentNo"];
            this.materialDocumentYear = _data["materialDocumentYear"];
            this.productName = _data["productName"];
            this.productBatchNo = _data["productBatchNo"];
            this.productId = _data["productId"];
            this.itemName = _data["itemName"];
            this.itemCode = _data["itemCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialDescription = _data["materialDescription"];
            this.arNo = _data["arNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.qty = _data["qty"];
            this.uom = _data["uom"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialRteturnDetailsSAP {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRteturnDetailsSAP();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocumentNo"] = this.materialDocumentNo;
        data["materialDocumentYear"] = this.materialDocumentYear;
        data["productName"] = this.productName;
        data["productBatchNo"] = this.productBatchNo;
        data["productId"] = this.productId;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["lineItemNo"] = this.lineItemNo;
        data["materialDescription"] = this.materialDescription;
        data["arNo"] = this.arNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["qty"] = this.qty;
        data["uom"] = this.uom;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialRteturnDetailsSAP {
        const json = this.toJSON();
        let result = new MaterialRteturnDetailsSAP();
        result.init(json);
        return result;
    }
}

export interface IMaterialRteturnDetailsSAP {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    productName: string | undefined;
    productBatchNo: string | undefined;
    productId: number;
    itemName: string | undefined;
    itemCode: string | undefined;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    qty: number | undefined;
    uom: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class CreateMaterialReturnDto implements ICreateMaterialReturnDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    containerId: number;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;

    constructor(data?: ICreateMaterialReturnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNo = _data["documentNo"];
            this.productId = _data["productId"];
            this.productNo = _data["productNo"];
            this.batchNo = _data["batchNo"];
            this.uomId = _data["uomId"];
            this.containerId = _data["containerId"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.quantity = _data["quantity"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.materialReturnProcessLabelBarcode = _data["materialReturnProcessLabelBarcode"];
            this.processOrderId = _data["processOrderId"];
        }
    }

    static fromJS(data: any): CreateMaterialReturnDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMaterialReturnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNo"] = this.documentNo;
        data["productId"] = this.productId;
        data["productNo"] = this.productNo;
        data["batchNo"] = this.batchNo;
        data["uomId"] = this.uomId;
        data["containerId"] = this.containerId;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["quantity"] = this.quantity;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["materialReturnProcessLabelBarcode"] = this.materialReturnProcessLabelBarcode;
        data["processOrderId"] = this.processOrderId;
        return data; 
    }

    clone(): CreateMaterialReturnDto {
        const json = this.toJSON();
        let result = new CreateMaterialReturnDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMaterialReturnDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    containerId: number;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;
}

export class MaterialReturnDto implements IMaterialReturnDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    containerId: number;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;
    id: number;

    constructor(data?: IMaterialReturnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNo = _data["documentNo"];
            this.productId = _data["productId"];
            this.productNo = _data["productNo"];
            this.batchNo = _data["batchNo"];
            this.uomId = _data["uomId"];
            this.containerId = _data["containerId"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.quantity = _data["quantity"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.materialReturnProcessLabelBarcode = _data["materialReturnProcessLabelBarcode"];
            this.processOrderId = _data["processOrderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialReturnDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialReturnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNo"] = this.documentNo;
        data["productId"] = this.productId;
        data["productNo"] = this.productNo;
        data["batchNo"] = this.batchNo;
        data["uomId"] = this.uomId;
        data["containerId"] = this.containerId;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["quantity"] = this.quantity;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["materialReturnProcessLabelBarcode"] = this.materialReturnProcessLabelBarcode;
        data["processOrderId"] = this.processOrderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialReturnDto {
        const json = this.toJSON();
        let result = new MaterialReturnDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialReturnDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    containerId: number;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;
    id: number;
}

export class MaterialReturnListDto implements IMaterialReturnListDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    uom: string | undefined;
    containerId: number;
    container: string | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;
    id: number;

    constructor(data?: IMaterialReturnListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNo = _data["documentNo"];
            this.productId = _data["productId"];
            this.productNo = _data["productNo"];
            this.batchNo = _data["batchNo"];
            this.uomId = _data["uomId"];
            this.uom = _data["uom"];
            this.containerId = _data["containerId"];
            this.container = _data["container"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.quantity = _data["quantity"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.materialReturnProcessLabelBarcode = _data["materialReturnProcessLabelBarcode"];
            this.processOrderId = _data["processOrderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialReturnListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialReturnListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNo"] = this.documentNo;
        data["productId"] = this.productId;
        data["productNo"] = this.productNo;
        data["batchNo"] = this.batchNo;
        data["uomId"] = this.uomId;
        data["uom"] = this.uom;
        data["containerId"] = this.containerId;
        data["container"] = this.container;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["quantity"] = this.quantity;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["materialReturnProcessLabelBarcode"] = this.materialReturnProcessLabelBarcode;
        data["processOrderId"] = this.processOrderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialReturnListDto {
        const json = this.toJSON();
        let result = new MaterialReturnListDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialReturnListDto {
    documentNo: string | undefined;
    productId: number;
    productNo: string | undefined;
    batchNo: string | undefined;
    uomId: number;
    uom: string | undefined;
    containerId: number;
    container: string | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    quantity: number;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    materialReturnProcessLabelBarcode: string | undefined;
    processOrderId: string | undefined;
    id: number;
}

export class MaterialReturnListDtoPagedResultDto implements IMaterialReturnListDtoPagedResultDto {
    totalCount: number;
    items: MaterialReturnListDto[] | undefined;

    constructor(data?: IMaterialReturnListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MaterialReturnListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialReturnListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialReturnListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MaterialReturnListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MaterialReturnListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialReturnListDtoPagedResultDto {
    totalCount: number;
    items: MaterialReturnListDto[] | undefined;
}

export class MaterialSampleDispensingDto implements IMaterialSampleDispensingDto {
    rlafId: number;
    rlafCode: string | undefined;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    samplingTypeId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    requiredQty: number | undefined;
    balanceQty: number | undefined;
    baseUnitOfMeasurement: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    dispensingBarcode: string | undefined;
    isAnySAPBatchNoExistForHeader: boolean;
    materialContainerId: number | undefined;
    materialBatchDispensingHeaderId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    deviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    statusId: number | undefined;
    sapbBatchNumberSelectList: SelectListDto[] | undefined;
    isPackUOM: boolean;
    noofPacks: number | undefined;
    isController: boolean;
    materialContainerBalanceQuantity: number | undefined;
    materialSamplingDetailIdToReprint: number;
    reprintDeviceId: number | undefined;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    isSampling: boolean;
    noOfQuantity: number;
    selectedContainer: number;
    id: number;

    constructor(data?: IMaterialSampleDispensingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rlafId = _data["rlafId"];
            this.rlafCode = _data["rlafCode"];
            this.processOrderId = _data["processOrderId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.samplingTypeId = _data["samplingTypeId"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.requiredQty = _data["requiredQty"];
            this.balanceQty = _data["balanceQty"];
            this.baseUnitOfMeasurement = _data["baseUnitOfMeasurement"];
            this.baseUnitOfMeasurementId = _data["baseUnitOfMeasurementId"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.dispensingBarcode = _data["dispensingBarcode"];
            this.isAnySAPBatchNoExistForHeader = _data["isAnySAPBatchNoExistForHeader"];
            this.materialContainerId = _data["materialContainerId"];
            this.materialBatchDispensingHeaderId = _data["materialBatchDispensingHeaderId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            if (Array.isArray(_data["suggestedBalanceIds"])) {
                this.suggestedBalanceIds = [] as any;
                for (let item of _data["suggestedBalanceIds"])
                    this.suggestedBalanceIds.push(SelectListDto.fromJS(item));
            }
            this.commsSepratedSuggestedBalanceIds = _data["commsSepratedSuggestedBalanceIds"];
            this.balanceCode = _data["balanceCode"];
            this.balanceId = _data["balanceId"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.grossWeight = _data["grossWeight"];
            this.noOfPacks = _data["noOfPacks"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            if (Array.isArray(_data["sapbBatchNumberSelectList"])) {
                this.sapbBatchNumberSelectList = [] as any;
                for (let item of _data["sapbBatchNumberSelectList"])
                    this.sapbBatchNumberSelectList.push(SelectListDto.fromJS(item));
            }
            this.isPackUOM = _data["isPackUOM"];
            this.noofPacks = _data["noofPacks"];
            this.isController = _data["isController"];
            this.materialContainerBalanceQuantity = _data["materialContainerBalanceQuantity"];
            this.materialSamplingDetailIdToReprint = _data["materialSamplingDetailIdToReprint"];
            this.reprintDeviceId = _data["reprintDeviceId"];
            this.convertedNoOfPack = _data["convertedNoOfPack"];
            this.convertedNetWeight = _data["convertedNetWeight"];
            this.isSampling = _data["isSampling"];
            this.noOfQuantity = _data["noOfQuantity"];
            this.selectedContainer = _data["selectedContainer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialSampleDispensingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialSampleDispensingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rlafId"] = this.rlafId;
        data["rlafCode"] = this.rlafCode;
        data["processOrderId"] = this.processOrderId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["samplingTypeId"] = this.samplingTypeId;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["requiredQty"] = this.requiredQty;
        data["balanceQty"] = this.balanceQty;
        data["baseUnitOfMeasurement"] = this.baseUnitOfMeasurement;
        data["baseUnitOfMeasurementId"] = this.baseUnitOfMeasurementId;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["dispensingBarcode"] = this.dispensingBarcode;
        data["isAnySAPBatchNoExistForHeader"] = this.isAnySAPBatchNoExistForHeader;
        data["materialContainerId"] = this.materialContainerId;
        data["materialBatchDispensingHeaderId"] = this.materialBatchDispensingHeaderId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        if (Array.isArray(this.suggestedBalanceIds)) {
            data["suggestedBalanceIds"] = [];
            for (let item of this.suggestedBalanceIds)
                data["suggestedBalanceIds"].push(item.toJSON());
        }
        data["commsSepratedSuggestedBalanceIds"] = this.commsSepratedSuggestedBalanceIds;
        data["balanceCode"] = this.balanceCode;
        data["balanceId"] = this.balanceId;
        data["isGrossWeight"] = this.isGrossWeight;
        data["grossWeight"] = this.grossWeight;
        data["noOfPacks"] = this.noOfPacks;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        if (Array.isArray(this.sapbBatchNumberSelectList)) {
            data["sapbBatchNumberSelectList"] = [];
            for (let item of this.sapbBatchNumberSelectList)
                data["sapbBatchNumberSelectList"].push(item.toJSON());
        }
        data["isPackUOM"] = this.isPackUOM;
        data["noofPacks"] = this.noofPacks;
        data["isController"] = this.isController;
        data["materialContainerBalanceQuantity"] = this.materialContainerBalanceQuantity;
        data["materialSamplingDetailIdToReprint"] = this.materialSamplingDetailIdToReprint;
        data["reprintDeviceId"] = this.reprintDeviceId;
        data["convertedNoOfPack"] = this.convertedNoOfPack;
        data["convertedNetWeight"] = this.convertedNetWeight;
        data["isSampling"] = this.isSampling;
        data["noOfQuantity"] = this.noOfQuantity;
        data["selectedContainer"] = this.selectedContainer;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialSampleDispensingDto {
        const json = this.toJSON();
        let result = new MaterialSampleDispensingDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialSampleDispensingDto {
    rlafId: number;
    rlafCode: string | undefined;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    samplingTypeId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    requiredQty: number | undefined;
    balanceQty: number | undefined;
    baseUnitOfMeasurement: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    dispensingBarcode: string | undefined;
    isAnySAPBatchNoExistForHeader: boolean;
    materialContainerId: number | undefined;
    materialBatchDispensingHeaderId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    deviceId: number | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    statusId: number | undefined;
    sapbBatchNumberSelectList: SelectListDto[] | undefined;
    isPackUOM: boolean;
    noofPacks: number | undefined;
    isController: boolean;
    materialContainerBalanceQuantity: number | undefined;
    materialSamplingDetailIdToReprint: number;
    reprintDeviceId: number | undefined;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    isSampling: boolean;
    noOfQuantity: number;
    selectedContainer: number;
    id: number;
}

export class MaterialSampleDispensingDetailDto implements IMaterialSampleDispensingDetailDto {
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    dispensingContainerBarcode: string | undefined;
    unitOfMeasurement: string | undefined;
    readonly grossWeightWithUOM: string | undefined;
    readonly netWeightWithUOM: string | undefined;
    readonly tareWeightWithUOM: string | undefined;
    readonly noOfPacksWithUOM: string | undefined;
    id: number;

    constructor(data?: IMaterialSampleDispensingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noOfPacks = _data["noOfPacks"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.dispensingContainerBarcode = _data["dispensingContainerBarcode"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            (<any>this).grossWeightWithUOM = _data["grossWeightWithUOM"];
            (<any>this).netWeightWithUOM = _data["netWeightWithUOM"];
            (<any>this).tareWeightWithUOM = _data["tareWeightWithUOM"];
            (<any>this).noOfPacksWithUOM = _data["noOfPacksWithUOM"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialSampleDispensingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialSampleDispensingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noOfPacks"] = this.noOfPacks;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["dispensingContainerBarcode"] = this.dispensingContainerBarcode;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["grossWeightWithUOM"] = this.grossWeightWithUOM;
        data["netWeightWithUOM"] = this.netWeightWithUOM;
        data["tareWeightWithUOM"] = this.tareWeightWithUOM;
        data["noOfPacksWithUOM"] = this.noOfPacksWithUOM;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialSampleDispensingDetailDto {
        const json = this.toJSON();
        let result = new MaterialSampleDispensingDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialSampleDispensingDetailDto {
    noOfPacks: number | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    dispensingContainerBarcode: string | undefined;
    unitOfMeasurement: string | undefined;
    grossWeightWithUOM: string | undefined;
    netWeightWithUOM: string | undefined;
    tareWeightWithUOM: string | undefined;
    noOfPacksWithUOM: string | undefined;
    id: number;
}

export class MaterialStatusLabelDto implements IMaterialStatusLabelDto {
    materialCode: string | undefined;
    inspectionLotNo: string | undefined;
    materialDescription: string | undefined;
    manfactureCode: string | undefined;
    invoiceDate: moment.Moment | undefined;
    manufacturerBatchNo: string | undefined;
    sapBatchNo: string | undefined;
    mfgDate: moment.Moment | undefined;
    expDate: moment.Moment | undefined;
    mfgrRetestDate: moment.Moment | undefined;
    grnNo: string | undefined;
    noOfContainer: number;
    grnPreparedBy: string | undefined;
    vendorCode: string | undefined;
    packSize: string | undefined;
    status: string | undefined;
    arNo: string | undefined;
    rejectedQty: string | undefined;
    releasedQty: string | undefined;
    statusColorCode: string | undefined;
    totalQtyReceived: string | undefined;
    expiredQty: string | undefined;
    isExpired: boolean;
    isRejected: boolean;
    isQcReleased: boolean;
    inHouseRetestDate: moment.Moment | undefined;
    plantId: number | undefined;

    constructor(data?: IMaterialStatusLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialCode = _data["materialCode"];
            this.inspectionLotNo = _data["inspectionLotNo"];
            this.materialDescription = _data["materialDescription"];
            this.manfactureCode = _data["manfactureCode"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.manufacturerBatchNo = _data["manufacturerBatchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.mfgDate = _data["mfgDate"] ? moment(_data["mfgDate"].toString()) : <any>undefined;
            this.expDate = _data["expDate"] ? moment(_data["expDate"].toString()) : <any>undefined;
            this.mfgrRetestDate = _data["mfgrRetestDate"] ? moment(_data["mfgrRetestDate"].toString()) : <any>undefined;
            this.grnNo = _data["grnNo"];
            this.noOfContainer = _data["noOfContainer"];
            this.grnPreparedBy = _data["grnPreparedBy"];
            this.vendorCode = _data["vendorCode"];
            this.packSize = _data["packSize"];
            this.status = _data["status"];
            this.arNo = _data["arNo"];
            this.rejectedQty = _data["rejectedQty"];
            this.releasedQty = _data["releasedQty"];
            this.statusColorCode = _data["statusColorCode"];
            this.totalQtyReceived = _data["totalQtyReceived"];
            this.expiredQty = _data["expiredQty"];
            this.isExpired = _data["isExpired"];
            this.isRejected = _data["isRejected"];
            this.isQcReleased = _data["isQcReleased"];
            this.inHouseRetestDate = _data["inHouseRetestDate"] ? moment(_data["inHouseRetestDate"].toString()) : <any>undefined;
            this.plantId = _data["plantId"];
        }
    }

    static fromJS(data: any): MaterialStatusLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStatusLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialCode"] = this.materialCode;
        data["inspectionLotNo"] = this.inspectionLotNo;
        data["materialDescription"] = this.materialDescription;
        data["manfactureCode"] = this.manfactureCode;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["manufacturerBatchNo"] = this.manufacturerBatchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["mfgDate"] = this.mfgDate ? this.mfgDate.toISOString() : <any>undefined;
        data["expDate"] = this.expDate ? this.expDate.toISOString() : <any>undefined;
        data["mfgrRetestDate"] = this.mfgrRetestDate ? this.mfgrRetestDate.toISOString() : <any>undefined;
        data["grnNo"] = this.grnNo;
        data["noOfContainer"] = this.noOfContainer;
        data["grnPreparedBy"] = this.grnPreparedBy;
        data["vendorCode"] = this.vendorCode;
        data["packSize"] = this.packSize;
        data["status"] = this.status;
        data["arNo"] = this.arNo;
        data["rejectedQty"] = this.rejectedQty;
        data["releasedQty"] = this.releasedQty;
        data["statusColorCode"] = this.statusColorCode;
        data["totalQtyReceived"] = this.totalQtyReceived;
        data["expiredQty"] = this.expiredQty;
        data["isExpired"] = this.isExpired;
        data["isRejected"] = this.isRejected;
        data["isQcReleased"] = this.isQcReleased;
        data["inHouseRetestDate"] = this.inHouseRetestDate ? this.inHouseRetestDate.toISOString() : <any>undefined;
        data["plantId"] = this.plantId;
        return data; 
    }

    clone(): MaterialStatusLabelDto {
        const json = this.toJSON();
        let result = new MaterialStatusLabelDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialStatusLabelDto {
    materialCode: string | undefined;
    inspectionLotNo: string | undefined;
    materialDescription: string | undefined;
    manfactureCode: string | undefined;
    invoiceDate: moment.Moment | undefined;
    manufacturerBatchNo: string | undefined;
    sapBatchNo: string | undefined;
    mfgDate: moment.Moment | undefined;
    expDate: moment.Moment | undefined;
    mfgrRetestDate: moment.Moment | undefined;
    grnNo: string | undefined;
    noOfContainer: number;
    grnPreparedBy: string | undefined;
    vendorCode: string | undefined;
    packSize: string | undefined;
    status: string | undefined;
    arNo: string | undefined;
    rejectedQty: string | undefined;
    releasedQty: string | undefined;
    statusColorCode: string | undefined;
    totalQtyReceived: string | undefined;
    expiredQty: string | undefined;
    isExpired: boolean;
    isRejected: boolean;
    isQcReleased: boolean;
    inHouseRetestDate: moment.Moment | undefined;
    plantId: number | undefined;
}

export class CreateMaterialVerificationDto implements ICreateMaterialVerificationDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number | undefined;
    cubicleId: number | undefined;
    cageBarcodeId: number | undefined;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;

    constructor(data?: ICreateMaterialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productID = _data["productID"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleId = _data["cubicleId"];
            this.cageBarcodeId = _data["cageBarcodeId"];
            this.cageBarcode = _data["cageBarcode"];
            this.noOfCage = _data["noOfCage"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateMaterialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMaterialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productID"] = this.productID;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleId"] = this.cubicleId;
        data["cageBarcodeId"] = this.cageBarcodeId;
        data["cageBarcode"] = this.cageBarcode;
        data["noOfCage"] = this.noOfCage;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateMaterialVerificationDto {
        const json = this.toJSON();
        let result = new CreateMaterialVerificationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMaterialVerificationDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number | undefined;
    cubicleId: number | undefined;
    cageBarcodeId: number | undefined;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;
}

export class MaterialVerificationDto implements IMaterialVerificationDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    cubicleId: number | undefined;
    batchNo: string | undefined;
    uom: string | undefined;
    quantity: string | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    cageBarcodeId: number;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;
    id: number;

    constructor(data?: IMaterialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productID = _data["productID"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleId = _data["cubicleId"];
            this.batchNo = _data["batchNo"];
            this.uom = _data["uom"];
            this.quantity = _data["quantity"];
            this.materialCode = _data["materialCode"];
            this.arNo = _data["arNo"];
            this.productName = _data["productName"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.cageBarcodeId = _data["cageBarcodeId"];
            this.cageBarcode = _data["cageBarcode"];
            this.noOfCage = _data["noOfCage"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productID"] = this.productID;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleId"] = this.cubicleId;
        data["batchNo"] = this.batchNo;
        data["uom"] = this.uom;
        data["quantity"] = this.quantity;
        data["materialCode"] = this.materialCode;
        data["arNo"] = this.arNo;
        data["productName"] = this.productName;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["cageBarcodeId"] = this.cageBarcodeId;
        data["cageBarcode"] = this.cageBarcode;
        data["noOfCage"] = this.noOfCage;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialVerificationDto {
        const json = this.toJSON();
        let result = new MaterialVerificationDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialVerificationDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    cubicleId: number | undefined;
    batchNo: string | undefined;
    uom: string | undefined;
    quantity: string | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    cageBarcodeId: number;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;
    id: number;
}

export class MaterialVerificationListDto implements IMaterialVerificationListDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    cubicleId: number | undefined;
    batchNo: string | undefined;
    uom: string | undefined;
    quantity: string | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    cageBarcodeId: number;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;
    id: number;

    constructor(data?: IMaterialVerificationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productID = _data["productID"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleId = _data["cubicleId"];
            this.batchNo = _data["batchNo"];
            this.uom = _data["uom"];
            this.quantity = _data["quantity"];
            this.materialCode = _data["materialCode"];
            this.arNo = _data["arNo"];
            this.productName = _data["productName"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.cageBarcodeId = _data["cageBarcodeId"];
            this.cageBarcode = _data["cageBarcode"];
            this.noOfCage = _data["noOfCage"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialVerificationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialVerificationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productID"] = this.productID;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleId"] = this.cubicleId;
        data["batchNo"] = this.batchNo;
        data["uom"] = this.uom;
        data["quantity"] = this.quantity;
        data["materialCode"] = this.materialCode;
        data["arNo"] = this.arNo;
        data["productName"] = this.productName;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["cageBarcodeId"] = this.cageBarcodeId;
        data["cageBarcode"] = this.cageBarcode;
        data["noOfCage"] = this.noOfCage;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialVerificationListDto {
        const json = this.toJSON();
        let result = new MaterialVerificationListDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialVerificationListDto {
    productID: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    cubicleBarcodeId: number;
    cubicleId: number | undefined;
    batchNo: string | undefined;
    uom: string | undefined;
    quantity: string | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    cubicleBarcode: string | undefined;
    cageBarcodeId: number;
    cageBarcode: string | undefined;
    noOfCage: number;
    isActive: boolean;
    id: number;
}

export class MaterialVerificationListDtoPagedResultDto implements IMaterialVerificationListDtoPagedResultDto {
    totalCount: number;
    items: MaterialVerificationListDto[] | undefined;

    constructor(data?: IMaterialVerificationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MaterialVerificationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialVerificationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialVerificationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MaterialVerificationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MaterialVerificationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialVerificationListDtoPagedResultDto {
    totalCount: number;
    items: MaterialVerificationListDto[] | undefined;
}

export class ProcessOrderMaterialAfterRelease implements IProcessOrderMaterialAfterRelease {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arno: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    productBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    uom: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;

    constructor(data?: IProcessOrderMaterialAfterRelease) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.arno = _data["arno"];
            this.lotNo = _data["lotNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.productBatchNo = _data["productBatchNo"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessOrderMaterialAfterRelease {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderMaterialAfterRelease();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["lineItemNo"] = this.lineItemNo;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["arno"] = this.arno;
        data["lotNo"] = this.lotNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["productBatchNo"] = this.productBatchNo;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessOrderMaterialAfterRelease {
        const json = this.toJSON();
        let result = new ProcessOrderMaterialAfterRelease();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderMaterialAfterRelease {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arno: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    productBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    uom: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    isDeleted: boolean;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    id: number;
}

export class ModuleListDto implements IModuleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IModuleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ModuleListDto {
        const json = this.toJSON();
        let result = new ModuleListDto();
        result.init(json);
        return result;
    }
}

export interface IModuleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    id: number;
}

export class ModuleListDtoPagedResultDto implements IModuleListDtoPagedResultDto {
    totalCount: number;
    items: ModuleListDto[] | undefined;

    constructor(data?: IModuleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ModuleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ModuleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ModuleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IModuleListDtoPagedResultDto {
    totalCount: number;
    items: ModuleListDto[] | undefined;
}

export class SubModuleListDto implements ISubModuleListDto {
    name: string | undefined;
    moduleName: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    subModuleType: string | undefined;
    moduleId: number | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalRequired: string | undefined;
    id: number;

    constructor(data?: ISubModuleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.moduleName = _data["moduleName"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.subModuleType = _data["subModuleType"];
            this.moduleId = _data["moduleId"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalRequired = _data["userEnteredApprovalRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubModuleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["moduleName"] = this.moduleName;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["subModuleType"] = this.subModuleType;
        data["moduleId"] = this.moduleId;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalRequired"] = this.userEnteredApprovalRequired;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubModuleListDto {
        const json = this.toJSON();
        let result = new SubModuleListDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleListDto {
    name: string | undefined;
    moduleName: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    subModuleType: string | undefined;
    moduleId: number | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalRequired: string | undefined;
    id: number;
}

export class SubModuleListDtoPagedResultDto implements ISubModuleListDtoPagedResultDto {
    totalCount: number;
    items: SubModuleListDto[] | undefined;

    constructor(data?: ISubModuleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SubModuleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubModuleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubModuleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SubModuleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleListDtoPagedResultDto {
    totalCount: number;
    items: SubModuleListDto[] | undefined;
}

export class SubModuleDto implements ISubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    sequence: number;
    isActive: boolean;
    subModuleTypeId: number | undefined;
    isApprovalRequired: boolean;
    isApprovalWorkflowRequired: boolean;
    id: number;

    constructor(data?: ISubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSelected = _data["isSelected"];
            this.isMandatory = _data["isMandatory"];
            this.isDeleted = _data["isDeleted"];
            this.sequence = _data["sequence"];
            this.isActive = _data["isActive"];
            this.subModuleTypeId = _data["subModuleTypeId"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.isApprovalWorkflowRequired = _data["isApprovalWorkflowRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSelected"] = this.isSelected;
        data["isMandatory"] = this.isMandatory;
        data["isDeleted"] = this.isDeleted;
        data["sequence"] = this.sequence;
        data["isActive"] = this.isActive;
        data["subModuleTypeId"] = this.subModuleTypeId;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["isApprovalWorkflowRequired"] = this.isApprovalWorkflowRequired;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubModuleDto {
        const json = this.toJSON();
        let result = new SubModuleDto();
        result.init(json);
        return result;
    }
}

export interface ISubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    sequence: number;
    isActive: boolean;
    subModuleTypeId: number | undefined;
    isApprovalRequired: boolean;
    isApprovalWorkflowRequired: boolean;
    id: number;
}

export class ModuleDto implements IModuleDto {
    name: string;
    displayName: string;
    description: string;
    isDeleted: boolean;
    isActive: boolean;
    createdOn: moment.Moment | undefined;
    subModules: SubModuleDto[];
    id: number;

    constructor(data?: IModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subModules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["subModules"])) {
                this.subModules = [] as any;
                for (let item of _data["subModules"])
                    this.subModules.push(SubModuleDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.subModules)) {
            data["subModules"] = [];
            for (let item of this.subModules)
                data["subModules"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): ModuleDto {
        const json = this.toJSON();
        let result = new ModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleDto {
    name: string;
    displayName: string;
    description: string;
    isDeleted: boolean;
    isActive: boolean;
    createdOn: moment.Moment | undefined;
    subModules: SubModuleDto[];
    id: number;
}

export class UpdateSubModuleDto implements IUpdateSubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    isActive: boolean;
    isApprovalRequired: boolean;
    id: number;

    constructor(data?: IUpdateSubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSelected = _data["isSelected"];
            this.isMandatory = _data["isMandatory"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSelected"] = this.isSelected;
        data["isMandatory"] = this.isMandatory;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateSubModuleDto {
        const json = this.toJSON();
        let result = new UpdateSubModuleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSubModuleDto {
    name: string;
    displayName: string;
    description: string;
    isSelected: boolean;
    isMandatory: boolean;
    isDeleted: boolean;
    isActive: boolean;
    isApprovalRequired: boolean;
    id: number;
}

export class ModuleSubModuleDto implements IModuleSubModuleDto {
    subModule: SubModuleDto[] | undefined;
    isMandatory: boolean;
    isSelected: boolean;
    isActive: boolean;
    id: number;

    constructor(data?: IModuleSubModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subModule"])) {
                this.subModule = [] as any;
                for (let item of _data["subModule"])
                    this.subModule.push(SubModuleDto.fromJS(item));
            }
            this.isMandatory = _data["isMandatory"];
            this.isSelected = _data["isSelected"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleSubModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subModule)) {
            data["subModule"] = [];
            for (let item of this.subModule)
                data["subModule"].push(item.toJSON());
        }
        data["isMandatory"] = this.isMandatory;
        data["isSelected"] = this.isSelected;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ModuleSubModuleDto {
        const json = this.toJSON();
        let result = new ModuleSubModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleSubModuleDto {
    subModule: SubModuleDto[] | undefined;
    isMandatory: boolean;
    isSelected: boolean;
    isActive: boolean;
    id: number;
}

export class CreatePackingDto implements ICreatePackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    batchNo: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;

    constructor(data?: ICreatePackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.batchNo = _data["batchNo"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["batchNo"] = this.batchNo;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreatePackingDto {
        const json = this.toJSON();
        let result = new CreatePackingDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    batchNo: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;
}

export class PackingDto implements IPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IPackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.productCode = _data["productCode"];
            this.batchNo = _data["batchNo"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["productCode"] = this.productCode;
        data["batchNo"] = this.batchNo;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): PackingDto {
        const json = this.toJSON();
        let result = new PackingDto();
        result.init(json);
        return result;
    }
}

export interface IPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;
    id: number;
}

export class PackingListDto implements IPackingListDto {
    productCodeId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;
    storageLocation: string | undefined;
    noOfContainer: string | undefined;
    qty: number | undefined;
    id: number;

    constructor(data?: IPackingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCodeId = _data["productCodeId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.batchNo = _data["batchNo"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.isActive = _data["isActive"];
            this.storageLocation = _data["storageLocation"];
            this.noOfContainer = _data["noOfContainer"];
            this.qty = _data["qty"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PackingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCodeId"] = this.productCodeId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["batchNo"] = this.batchNo;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["isActive"] = this.isActive;
        data["storageLocation"] = this.storageLocation;
        data["noOfContainer"] = this.noOfContainer;
        data["qty"] = this.qty;
        data["id"] = this.id;
        return data; 
    }

    clone(): PackingListDto {
        const json = this.toJSON();
        let result = new PackingListDto();
        result.init(json);
        return result;
    }
}

export interface IPackingListDto {
    productCodeId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number | undefined;
    isActive: boolean;
    storageLocation: string | undefined;
    noOfContainer: string | undefined;
    qty: number | undefined;
    id: number;
}

export class PackingListDtoPagedResultDto implements IPackingListDtoPagedResultDto {
    totalCount: number;
    items: PackingListDto[] | undefined;

    constructor(data?: IPackingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PackingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PackingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PackingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPackingListDtoPagedResultDto {
    totalCount: number;
    items: PackingListDto[] | undefined;
}

export class PalletizationDto implements IPalletizationDto {
    palletId: number;
    materialId: number;
    transactionId: string;
    isUnloaded: boolean;
    palletBarcode: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    containerNo: number;
    containerBarCode: string | undefined;
    sapBatchNumber: string | undefined;
    partition: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    checked: boolean | undefined;
    id: number;

    constructor(data?: IPalletizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.transactionId = _data["transactionId"];
            this.isUnloaded = _data["isUnloaded"];
            this.palletBarcode = _data["palletBarcode"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.containerNo = _data["containerNo"];
            this.containerBarCode = _data["containerBarCode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.partition = _data["partition"];
            this.grnDetailId = _data["grnDetailId"];
            this.containerId = _data["containerId"];
            this.checked = _data["checked"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PalletizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["transactionId"] = this.transactionId;
        data["isUnloaded"] = this.isUnloaded;
        data["palletBarcode"] = this.palletBarcode;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["containerNo"] = this.containerNo;
        data["containerBarCode"] = this.containerBarCode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["partition"] = this.partition;
        data["grnDetailId"] = this.grnDetailId;
        data["containerId"] = this.containerId;
        data["checked"] = this.checked;
        data["id"] = this.id;
        return data; 
    }

    clone(): PalletizationDto {
        const json = this.toJSON();
        let result = new PalletizationDto();
        result.init(json);
        return result;
    }
}

export interface IPalletizationDto {
    palletId: number;
    materialId: number;
    transactionId: string;
    isUnloaded: boolean;
    palletBarcode: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    containerNo: number;
    containerBarCode: string | undefined;
    sapBatchNumber: string | undefined;
    partition: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
    checked: boolean | undefined;
    id: number;
}

export class PalletizationListDto implements IPalletizationListDto {
    palletBarcode: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    sapBatchNumber: string | undefined;
    count: number;
    transactionId: string;
    palletId: number | undefined;
    materialId: number | undefined;
    plantId: number;
    id: string | undefined;

    constructor(data?: IPalletizationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletBarcode = _data["palletBarcode"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.count = _data["count"];
            this.transactionId = _data["transactionId"];
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.plantId = _data["plantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PalletizationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletizationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletBarcode"] = this.palletBarcode;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["count"] = this.count;
        data["transactionId"] = this.transactionId;
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["plantId"] = this.plantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PalletizationListDto {
        const json = this.toJSON();
        let result = new PalletizationListDto();
        result.init(json);
        return result;
    }
}

export interface IPalletizationListDto {
    palletBarcode: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    sapBatchNumber: string | undefined;
    count: number;
    transactionId: string;
    palletId: number | undefined;
    materialId: number | undefined;
    plantId: number;
    id: string | undefined;
}

export class PalletizationListDtoPagedResultDto implements IPalletizationListDtoPagedResultDto {
    totalCount: number;
    items: PalletizationListDto[] | undefined;

    constructor(data?: IPalletizationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PalletizationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PalletizationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletizationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PalletizationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PalletizationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPalletizationListDtoPagedResultDto {
    totalCount: number;
    items: PalletizationListDto[] | undefined;
}

export class CreatePalletizationDto implements ICreatePalletizationDto {
    palletId: number;
    materialId: number;
    containerNo: number;
    containerBarCode: string | undefined;
    transactionId: string;
    partitionId: number;
    isUnloaded: boolean;
    palletBarcode: string | undefined;
    sapBatchNumber: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;

    constructor(data?: ICreatePalletizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.containerNo = _data["containerNo"];
            this.containerBarCode = _data["containerBarCode"];
            this.transactionId = _data["transactionId"];
            this.partitionId = _data["partitionId"];
            this.isUnloaded = _data["isUnloaded"];
            this.palletBarcode = _data["palletBarcode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.grnDetailId = _data["grnDetailId"];
            this.containerId = _data["containerId"];
        }
    }

    static fromJS(data: any): CreatePalletizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePalletizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["containerNo"] = this.containerNo;
        data["containerBarCode"] = this.containerBarCode;
        data["transactionId"] = this.transactionId;
        data["partitionId"] = this.partitionId;
        data["isUnloaded"] = this.isUnloaded;
        data["palletBarcode"] = this.palletBarcode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["grnDetailId"] = this.grnDetailId;
        data["containerId"] = this.containerId;
        return data; 
    }

    clone(): CreatePalletizationDto {
        const json = this.toJSON();
        let result = new CreatePalletizationDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePalletizationDto {
    palletId: number;
    materialId: number;
    containerNo: number;
    containerBarCode: string | undefined;
    transactionId: string;
    partitionId: number;
    isUnloaded: boolean;
    palletBarcode: string | undefined;
    sapBatchNumber: string | undefined;
    grnDetailId: number | undefined;
    containerId: number | undefined;
}

export class PalletMasterDto implements IPalletMasterDto {
    pallet_Barcode: string | undefined;
    cartonBarcodeId: number;
    carton_barcode: string | undefined;
    productBatchNo: string | undefined;
    processOrderId: string | undefined;
    palletBarcodeId: number;
    description: string | undefined;
    tenantId: number | undefined;
    containerCount: number | undefined;
    id: number;

    constructor(data?: IPalletMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pallet_Barcode = _data["pallet_Barcode"];
            this.cartonBarcodeId = _data["cartonBarcodeId"];
            this.carton_barcode = _data["carton_barcode"];
            this.productBatchNo = _data["productBatchNo"];
            this.processOrderId = _data["processOrderId"];
            this.palletBarcodeId = _data["palletBarcodeId"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.containerCount = _data["containerCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PalletMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pallet_Barcode"] = this.pallet_Barcode;
        data["cartonBarcodeId"] = this.cartonBarcodeId;
        data["carton_barcode"] = this.carton_barcode;
        data["productBatchNo"] = this.productBatchNo;
        data["processOrderId"] = this.processOrderId;
        data["palletBarcodeId"] = this.palletBarcodeId;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["containerCount"] = this.containerCount;
        data["id"] = this.id;
        return data; 
    }

    clone(): PalletMasterDto {
        const json = this.toJSON();
        let result = new PalletMasterDto();
        result.init(json);
        return result;
    }
}

export interface IPalletMasterDto {
    pallet_Barcode: string | undefined;
    cartonBarcodeId: number;
    carton_barcode: string | undefined;
    productBatchNo: string | undefined;
    processOrderId: string | undefined;
    palletBarcodeId: number;
    description: string | undefined;
    tenantId: number | undefined;
    containerCount: number | undefined;
    id: number;
}

export class PalletMasterListDto implements IPalletMasterListDto {
    pallet_Barcode: string | undefined;
    carton_barcode: string | undefined;
    description: string | undefined;
    tenantId: number | undefined;
    palletBarcodeId: number;
    cartonBarcodeId: number;
    productBatchNo: string | undefined;
    id: number;

    constructor(data?: IPalletMasterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pallet_Barcode = _data["pallet_Barcode"];
            this.carton_barcode = _data["carton_barcode"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.palletBarcodeId = _data["palletBarcodeId"];
            this.cartonBarcodeId = _data["cartonBarcodeId"];
            this.productBatchNo = _data["productBatchNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PalletMasterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletMasterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pallet_Barcode"] = this.pallet_Barcode;
        data["carton_barcode"] = this.carton_barcode;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["palletBarcodeId"] = this.palletBarcodeId;
        data["cartonBarcodeId"] = this.cartonBarcodeId;
        data["productBatchNo"] = this.productBatchNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): PalletMasterListDto {
        const json = this.toJSON();
        let result = new PalletMasterListDto();
        result.init(json);
        return result;
    }
}

export interface IPalletMasterListDto {
    pallet_Barcode: string | undefined;
    carton_barcode: string | undefined;
    description: string | undefined;
    tenantId: number | undefined;
    palletBarcodeId: number;
    cartonBarcodeId: number;
    productBatchNo: string | undefined;
    id: number;
}

export class PalletMasterListDtoPagedResultDto implements IPalletMasterListDtoPagedResultDto {
    totalCount: number;
    items: PalletMasterListDto[] | undefined;

    constructor(data?: IPalletMasterListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PalletMasterListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PalletMasterListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PalletMasterListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PalletMasterListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PalletMasterListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPalletMasterListDtoPagedResultDto {
    totalCount: number;
    items: PalletMasterListDto[] | undefined;
}

export class PickingDto implements IPickingDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    suggestedBins: SelectListDto[] | undefined;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    requiredQty: number | undefined;
    sapBatchNo: string | undefined;
    sapBatchNumbers: string[] | undefined;
    commaSeparatedSuggestedBins: string | undefined;
    locationBarCode: string | undefined;
    locationId: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    isCompletePickingAllowed: boolean;
    id: number;

    constructor(data?: IPickingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["suggestedBins"])) {
                this.suggestedBins = [] as any;
                for (let item of _data["suggestedBins"])
                    this.suggestedBins.push(SelectListDto.fromJS(item));
            }
            this.materialCode = _data["materialCode"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.materialContainerId = _data["materialContainerId"];
            this.requiredQty = _data["requiredQty"];
            this.sapBatchNo = _data["sapBatchNo"];
            if (Array.isArray(_data["sapBatchNumbers"])) {
                this.sapBatchNumbers = [] as any;
                for (let item of _data["sapBatchNumbers"])
                    this.sapBatchNumbers.push(item);
            }
            this.commaSeparatedSuggestedBins = _data["commaSeparatedSuggestedBins"];
            this.locationBarCode = _data["locationBarCode"];
            this.locationId = _data["locationId"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.isCompletePickingAllowed = _data["isCompletePickingAllowed"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PickingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PickingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.suggestedBins)) {
            data["suggestedBins"] = [];
            for (let item of this.suggestedBins)
                data["suggestedBins"].push(item.toJSON());
        }
        data["materialCode"] = this.materialCode;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["materialContainerId"] = this.materialContainerId;
        data["requiredQty"] = this.requiredQty;
        data["sapBatchNo"] = this.sapBatchNo;
        if (Array.isArray(this.sapBatchNumbers)) {
            data["sapBatchNumbers"] = [];
            for (let item of this.sapBatchNumbers)
                data["sapBatchNumbers"].push(item);
        }
        data["commaSeparatedSuggestedBins"] = this.commaSeparatedSuggestedBins;
        data["locationBarCode"] = this.locationBarCode;
        data["locationId"] = this.locationId;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["isCompletePickingAllowed"] = this.isCompletePickingAllowed;
        data["id"] = this.id;
        return data; 
    }

    clone(): PickingDto {
        const json = this.toJSON();
        let result = new PickingDto();
        result.init(json);
        return result;
    }
}

export interface IPickingDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    suggestedBins: SelectListDto[] | undefined;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    requiredQty: number | undefined;
    sapBatchNo: string | undefined;
    sapBatchNumbers: string[] | undefined;
    commaSeparatedSuggestedBins: string | undefined;
    locationBarCode: string | undefined;
    locationId: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    isCompletePickingAllowed: boolean;
    id: number;
}

export class PlantDto implements IPlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    userEnteredApprovalStatus: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IPlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.masterPlantId = _data["masterPlantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.taxRegistrationNo = _data["taxRegistrationNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.website = _data["website"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["masterPlantId"] = this.masterPlantId;
        data["plantTypeId"] = this.plantTypeId;
        data["taxRegistrationNo"] = this.taxRegistrationNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["website"] = this.website;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): PlantDto {
        const json = this.toJSON();
        let result = new PlantDto();
        result.init(json);
        return result;
    }
}

export interface IPlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    userEnteredApprovalStatus: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class PlantListDto implements IPlantListDto {
    plantName: string | undefined;
    plantId: string | undefined;
    plantTypeId: number | undefined;
    license: string | undefined;
    countryId: number | undefined;
    isActive: boolean;
    countryName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    masterPlantId: number | undefined;
    id: number;

    constructor(data?: IPlantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.license = _data["license"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
            this.countryName = _data["countryName"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.masterPlantId = _data["masterPlantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["plantTypeId"] = this.plantTypeId;
        data["license"] = this.license;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        data["countryName"] = this.countryName;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["masterPlantId"] = this.masterPlantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PlantListDto {
        const json = this.toJSON();
        let result = new PlantListDto();
        result.init(json);
        return result;
    }
}

export interface IPlantListDto {
    plantName: string | undefined;
    plantId: string | undefined;
    plantTypeId: number | undefined;
    license: string | undefined;
    countryId: number | undefined;
    isActive: boolean;
    countryName: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    masterPlantId: number | undefined;
    id: number;
}

export class PlantListDtoPagedResultDto implements IPlantListDtoPagedResultDto {
    totalCount: number;
    items: PlantListDto[] | undefined;

    constructor(data?: IPlantListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PlantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlantListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PlantListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PlantListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlantListDtoPagedResultDto {
    totalCount: number;
    items: PlantListDto[] | undefined;
}

export class CreatePlantDto implements ICreatePlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ICreatePlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantName = _data["plantName"];
            this.plantId = _data["plantId"];
            this.masterPlantId = _data["masterPlantId"];
            this.plantTypeId = _data["plantTypeId"];
            this.taxRegistrationNo = _data["taxRegistrationNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantName"] = this.plantName;
        data["plantId"] = this.plantId;
        data["masterPlantId"] = this.masterPlantId;
        data["plantTypeId"] = this.plantTypeId;
        data["taxRegistrationNo"] = this.taxRegistrationNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["website"] = this.website;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreatePlantDto {
        const json = this.toJSON();
        let result = new CreatePlantDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePlantDto {
    plantName: string;
    plantId: string;
    masterPlantId: number | undefined;
    plantTypeId: number;
    taxRegistrationNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    website: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class CreatePostToSAPDto implements ICreatePostToSAPDto {
    productId: number;
    processOrderId: number;
    isActive: boolean;
    isSent: boolean;

    constructor(data?: ICreatePostToSAPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.isActive = _data["isActive"];
            this.isSent = _data["isSent"];
        }
    }

    static fromJS(data: any): CreatePostToSAPDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostToSAPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["isActive"] = this.isActive;
        data["isSent"] = this.isSent;
        return data; 
    }

    clone(): CreatePostToSAPDto {
        const json = this.toJSON();
        let result = new CreatePostToSAPDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePostToSAPDto {
    productId: number;
    processOrderId: number;
    isActive: boolean;
    isSent: boolean;
}

export class PostToSAPDto implements IPostToSAPDto {
    productId: number;
    processOrderId: number;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    isActive: boolean;
    isSent: boolean;
    id: number;

    constructor(data?: IPostToSAPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchNo = _data["batchNo"];
            this.isActive = _data["isActive"];
            this.isSent = _data["isSent"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PostToSAPDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostToSAPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchNo"] = this.batchNo;
        data["isActive"] = this.isActive;
        data["isSent"] = this.isSent;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostToSAPDto {
        const json = this.toJSON();
        let result = new PostToSAPDto();
        result.init(json);
        return result;
    }
}

export interface IPostToSAPDto {
    productId: number;
    processOrderId: number;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    isActive: boolean;
    isSent: boolean;
    id: number;
}

export class PostToSAPListDto implements IPostToSAPListDto {
    productId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    containerBarcodeCount: number;
    netWeight: number;
    isActive: boolean;
    isSent: boolean;
    id: number;

    constructor(data?: IPostToSAPListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.batchNo = _data["batchNo"];
            this.currentStage = _data["currentStage"];
            this.containerBarcodeCount = _data["containerBarcodeCount"];
            this.netWeight = _data["netWeight"];
            this.isActive = _data["isActive"];
            this.isSent = _data["isSent"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PostToSAPListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostToSAPListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["batchNo"] = this.batchNo;
        data["currentStage"] = this.currentStage;
        data["containerBarcodeCount"] = this.containerBarcodeCount;
        data["netWeight"] = this.netWeight;
        data["isActive"] = this.isActive;
        data["isSent"] = this.isSent;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostToSAPListDto {
        const json = this.toJSON();
        let result = new PostToSAPListDto();
        result.init(json);
        return result;
    }
}

export interface IPostToSAPListDto {
    productId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    containerBarcodeCount: number;
    netWeight: number;
    isActive: boolean;
    isSent: boolean;
    id: number;
}

export class PostToSAPListDtoPagedResultDto implements IPostToSAPListDtoPagedResultDto {
    totalCount: number;
    items: PostToSAPListDto[] | undefined;

    constructor(data?: IPostToSAPListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PostToSAPListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostToSAPListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostToSAPListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PostToSAPListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PostToSAPListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPostToSAPListDtoPagedResultDto {
    totalCount: number;
    items: PostToSAPListDto[] | undefined;
}

export class PreStageDto implements IPreStageDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    processOrderMaterialId: number;
    purchaseOrderMaterialId: number;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    sapBatchNo: string | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    requiredQty: number | undefined;
    materialBatchDispensingHeaderId: number | undefined;
    isCompletePreStageAllowed: boolean;
    id: number;

    constructor(data?: IPreStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.processOrderMaterialId = _data["processOrderMaterialId"];
            this.purchaseOrderMaterialId = _data["purchaseOrderMaterialId"];
            this.materialCode = _data["materialCode"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.materialContainerId = _data["materialContainerId"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.requiredQty = _data["requiredQty"];
            this.materialBatchDispensingHeaderId = _data["materialBatchDispensingHeaderId"];
            this.isCompletePreStageAllowed = _data["isCompletePreStageAllowed"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PreStageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreStageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["processOrderMaterialId"] = this.processOrderMaterialId;
        data["purchaseOrderMaterialId"] = this.purchaseOrderMaterialId;
        data["materialCode"] = this.materialCode;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["materialContainerId"] = this.materialContainerId;
        data["sapBatchNo"] = this.sapBatchNo;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["requiredQty"] = this.requiredQty;
        data["materialBatchDispensingHeaderId"] = this.materialBatchDispensingHeaderId;
        data["isCompletePreStageAllowed"] = this.isCompletePreStageAllowed;
        data["id"] = this.id;
        return data; 
    }

    clone(): PreStageDto {
        const json = this.toJSON();
        let result = new PreStageDto();
        result.init(json);
        return result;
    }
}

export interface IPreStageDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    processOrderMaterialId: number;
    purchaseOrderMaterialId: number;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    sapBatchNo: string | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    requiredQty: number | undefined;
    materialBatchDispensingHeaderId: number | undefined;
    isCompletePreStageAllowed: boolean;
    id: number;
}

export class CreatePrintPackingDto implements ICreatePrintPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;

    constructor(data?: ICreatePrintPackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.containerId = _data["containerId"];
            this.containerBarcode = _data["containerBarcode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.packingLabelBarcode = _data["packingLabelBarcode"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.printerId = _data["printerId"];
        }
    }

    static fromJS(data: any): CreatePrintPackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePrintPackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["containerId"] = this.containerId;
        data["containerBarcode"] = this.containerBarcode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["packingLabelBarcode"] = this.packingLabelBarcode;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["printerId"] = this.printerId;
        return data; 
    }

    clone(): CreatePrintPackingDto {
        const json = this.toJSON();
        let result = new CreatePrintPackingDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePrintPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;
}

export class PrintPackingDto implements IPrintPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    labelProcessBarcodeCode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;
    id: number;

    constructor(data?: IPrintPackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.batchNo = _data["batchNo"];
            this.containerId = _data["containerId"];
            this.containerBarcode = _data["containerBarcode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.packingLabelBarcode = _data["packingLabelBarcode"];
            this.labelProcessBarcodeCode = _data["labelProcessBarcodeCode"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.printerId = _data["printerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PrintPackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintPackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["batchNo"] = this.batchNo;
        data["containerId"] = this.containerId;
        data["containerBarcode"] = this.containerBarcode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["packingLabelBarcode"] = this.packingLabelBarcode;
        data["labelProcessBarcodeCode"] = this.labelProcessBarcodeCode;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["printerId"] = this.printerId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PrintPackingDto {
        const json = this.toJSON();
        let result = new PrintPackingDto();
        result.init(json);
        return result;
    }
}

export interface IPrintPackingDto {
    productId: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    labelProcessBarcodeCode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;
    id: number;
}

export class PrintPackingListDto implements IPrintPackingListDto {
    productId: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;
    id: number;

    constructor(data?: IPrintPackingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.batchNo = _data["batchNo"];
            this.containerId = _data["containerId"];
            this.containerBarcode = _data["containerBarcode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.packingLabelBarcode = _data["packingLabelBarcode"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.printerId = _data["printerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PrintPackingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintPackingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["batchNo"] = this.batchNo;
        data["containerId"] = this.containerId;
        data["containerBarcode"] = this.containerBarcode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["packingLabelBarcode"] = this.packingLabelBarcode;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["printerId"] = this.printerId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PrintPackingListDto {
        const json = this.toJSON();
        let result = new PrintPackingListDto();
        result.init(json);
        return result;
    }
}

export interface IPrintPackingListDto {
    productId: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    containerId: number | undefined;
    containerBarcode: string | undefined;
    containerCount: number | undefined;
    quantity: string | undefined;
    packingLabelBarcode: string | undefined;
    isPrint: boolean;
    printCount: number;
    printerId: number | undefined;
    id: number;
}

export class PrintPackingListDtoPagedResultDto implements IPrintPackingListDtoPagedResultDto {
    totalCount: number;
    items: PrintPackingListDto[] | undefined;

    constructor(data?: IPrintPackingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PrintPackingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrintPackingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintPackingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PrintPackingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PrintPackingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPrintPackingListDtoPagedResultDto {
    totalCount: number;
    items: PrintPackingListDto[] | undefined;
}

export class PRNEntryDto implements IPRNEntryDto {
    prnFileName: string;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IPRNEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prnFileName = _data["prnFileName"];
            this.subPlantId = _data["subPlantId"];
            this.tenantId = _data["tenantId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PRNEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PRNEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prnFileName"] = this.prnFileName;
        data["subPlantId"] = this.subPlantId;
        data["tenantId"] = this.tenantId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): PRNEntryDto {
        const json = this.toJSON();
        let result = new PRNEntryDto();
        result.init(json);
        return result;
    }
}

export interface IPRNEntryDto {
    prnFileName: string;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class PRNEntryListDto implements IPRNEntryListDto {
    prnFileName: string | undefined;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredModuleId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IPRNEntryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prnFileName = _data["prnFileName"];
            this.subPlantId = _data["subPlantId"];
            this.tenantId = _data["tenantId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredModuleId = _data["userEnteredModuleId"];
            this.userEnteredSubModuleId = _data["userEnteredSubModuleId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PRNEntryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PRNEntryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prnFileName"] = this.prnFileName;
        data["subPlantId"] = this.subPlantId;
        data["tenantId"] = this.tenantId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredModuleId"] = this.userEnteredModuleId;
        data["userEnteredSubModuleId"] = this.userEnteredSubModuleId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): PRNEntryListDto {
        const json = this.toJSON();
        let result = new PRNEntryListDto();
        result.init(json);
        return result;
    }
}

export interface IPRNEntryListDto {
    prnFileName: string | undefined;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredModuleId: string | undefined;
    userEnteredSubModuleId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class PRNEntryListDtoPagedResultDto implements IPRNEntryListDtoPagedResultDto {
    totalCount: number;
    items: PRNEntryListDto[] | undefined;

    constructor(data?: IPRNEntryListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PRNEntryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PRNEntryListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PRNEntryListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PRNEntryListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PRNEntryListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPRNEntryListDtoPagedResultDto {
    totalCount: number;
    items: PRNEntryListDto[] | undefined;
}

export class CreatePRNEntryDto implements ICreatePRNEntryDto {
    prnFileName: string;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;

    constructor(data?: ICreatePRNEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prnFileName = _data["prnFileName"];
            this.subPlantId = _data["subPlantId"];
            this.tenantId = _data["tenantId"];
            this.moduleId = _data["moduleId"];
            this.subModuleId = _data["subModuleId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePRNEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePRNEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prnFileName"] = this.prnFileName;
        data["subPlantId"] = this.subPlantId;
        data["tenantId"] = this.tenantId;
        data["moduleId"] = this.moduleId;
        data["subModuleId"] = this.subModuleId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreatePRNEntryDto {
        const json = this.toJSON();
        let result = new CreatePRNEntryDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePRNEntryDto {
    prnFileName: string;
    subPlantId: number;
    tenantId: number | undefined;
    moduleId: number;
    subModuleId: number;
    isActive: boolean;
}

export class CreateProcessLabelDto implements ICreateProcessLabelDto {
    cubicleId: number;
    cubicleBarcode: string | undefined;
    processOrderId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;

    constructor(data?: ICreateProcessLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.processOrderId = _data["processOrderId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.containerBarcode = _data["containerBarcode"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalance = _data["scanBalance"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.noOfContainer = _data["noOfContainer"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
        }
    }

    static fromJS(data: any): CreateProcessLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProcessLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["processOrderId"] = this.processOrderId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["containerBarcode"] = this.containerBarcode;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalance"] = this.scanBalance;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["noOfContainer"] = this.noOfContainer;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        return data; 
    }

    clone(): CreateProcessLabelDto {
        const json = this.toJSON();
        let result = new CreateProcessLabelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProcessLabelDto {
    cubicleId: number;
    cubicleBarcode: string | undefined;
    processOrderId: number | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
}

export class ProcessLabelDto implements IProcessLabelDto {
    cubicleId: number;
    processOrderId: number | undefined;
    productId: number | undefined;
    processLabelBarcode: string | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;

    constructor(data?: IProcessLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.processOrderId = _data["processOrderId"];
            this.productId = _data["productId"];
            this.processLabelBarcode = _data["processLabelBarcode"];
            this.processOrderNo = _data["processOrderNo"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchNo = _data["batchNo"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.containerBarcode = _data["containerBarcode"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalance = _data["scanBalance"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.noOfContainer = _data["noOfContainer"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["processOrderId"] = this.processOrderId;
        data["productId"] = this.productId;
        data["processLabelBarcode"] = this.processLabelBarcode;
        data["processOrderNo"] = this.processOrderNo;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchNo"] = this.batchNo;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["containerBarcode"] = this.containerBarcode;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalance"] = this.scanBalance;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["noOfContainer"] = this.noOfContainer;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessLabelDto {
        const json = this.toJSON();
        let result = new ProcessLabelDto();
        result.init(json);
        return result;
    }
}

export interface IProcessLabelDto {
    cubicleId: number;
    processOrderId: number | undefined;
    productId: number | undefined;
    processLabelBarcode: string | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;
}

export class ProcessLabelListDto implements IProcessLabelListDto {
    cubicleId: number;
    processLabelBarcode: string | undefined;
    productId: number | undefined;
    cubicleCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    lotNo: string | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;

    constructor(data?: IProcessLabelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleId = _data["cubicleId"];
            this.processLabelBarcode = _data["processLabelBarcode"];
            this.productId = _data["productId"];
            this.cubicleCode = _data["cubicleCode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchNo = _data["batchNo"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.containerBarcode = _data["containerBarcode"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalance = _data["scanBalance"];
            this.grossWeight = _data["grossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.lotNo = _data["lotNo"];
            this.noOfContainer = _data["noOfContainer"];
            this.isPrint = _data["isPrint"];
            this.printCount = _data["printCount"];
            this.isActive = _data["isActive"];
            this.printerId = _data["printerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessLabelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLabelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleId"] = this.cubicleId;
        data["processLabelBarcode"] = this.processLabelBarcode;
        data["productId"] = this.productId;
        data["cubicleCode"] = this.cubicleCode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchNo"] = this.batchNo;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["containerBarcode"] = this.containerBarcode;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalance"] = this.scanBalance;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["lotNo"] = this.lotNo;
        data["noOfContainer"] = this.noOfContainer;
        data["isPrint"] = this.isPrint;
        data["printCount"] = this.printCount;
        data["isActive"] = this.isActive;
        data["printerId"] = this.printerId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessLabelListDto {
        const json = this.toJSON();
        let result = new ProcessLabelListDto();
        result.init(json);
        return result;
    }
}

export interface IProcessLabelListDto {
    cubicleId: number;
    processLabelBarcode: string | undefined;
    productId: number | undefined;
    cubicleCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    containerBarcode: string | undefined;
    scanBalanceId: number | undefined;
    scanBalance: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    lotNo: string | undefined;
    noOfContainer: string | undefined;
    isPrint: boolean;
    printCount: number;
    isActive: boolean;
    printerId: number | undefined;
    id: number;
}

export class ProcessLabelListDtoPagedResultDto implements IProcessLabelListDtoPagedResultDto {
    totalCount: number;
    items: ProcessLabelListDto[] | undefined;

    constructor(data?: IProcessLabelListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProcessLabelListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessLabelListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLabelListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProcessLabelListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProcessLabelListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProcessLabelListDtoPagedResultDto {
    totalCount: number;
    items: ProcessLabelListDto[] | undefined;
}

export class ProcessOrderMaterialDto implements IProcessOrderMaterialDto {
    processOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    arNo: string | undefined;

    constructor(data?: IProcessOrderMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderNo = _data["processOrderNo"];
            this.itemNo = _data["itemNo"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.orderQuantity = _data["orderQuantity"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.arNo = _data["arNo"];
        }
    }

    static fromJS(data: any): ProcessOrderMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderNo"] = this.processOrderNo;
        data["itemNo"] = this.itemNo;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["orderQuantity"] = this.orderQuantity;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["batchNo"] = this.batchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["arNo"] = this.arNo;
        return data; 
    }

    clone(): ProcessOrderMaterialDto {
        const json = this.toJSON();
        let result = new ProcessOrderMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderMaterialDto {
    processOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    arNo: string | undefined;
}

export class ProcessOrderDto implements IProcessOrderDto {
    plantId: string;
    processOrderNo: string;
    processOrderType: string;
    processOrderDate: moment.Moment;
    productCode: string;
    issueQuantityUOM: string | undefined;
    issueIndicator: string | undefined;
    listOfMaterials: ProcessOrderMaterialDto[] | undefined;
    isReservationNo: boolean;

    constructor(data?: IProcessOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.processOrderNo = _data["processOrderNo"];
            this.processOrderType = _data["processOrderType"];
            this.processOrderDate = _data["processOrderDate"] ? moment(_data["processOrderDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
            this.issueQuantityUOM = _data["issueQuantityUOM"];
            this.issueIndicator = _data["issueIndicator"];
            if (Array.isArray(_data["listOfMaterials"])) {
                this.listOfMaterials = [] as any;
                for (let item of _data["listOfMaterials"])
                    this.listOfMaterials.push(ProcessOrderMaterialDto.fromJS(item));
            }
            this.isReservationNo = _data["isReservationNo"];
        }
    }

    static fromJS(data: any): ProcessOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["processOrderNo"] = this.processOrderNo;
        data["processOrderType"] = this.processOrderType;
        data["processOrderDate"] = this.processOrderDate ? this.processOrderDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["issueQuantityUOM"] = this.issueQuantityUOM;
        data["issueIndicator"] = this.issueIndicator;
        if (Array.isArray(this.listOfMaterials)) {
            data["listOfMaterials"] = [];
            for (let item of this.listOfMaterials)
                data["listOfMaterials"].push(item.toJSON());
        }
        data["isReservationNo"] = this.isReservationNo;
        return data; 
    }

    clone(): ProcessOrderDto {
        const json = this.toJSON();
        let result = new ProcessOrderDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderDto {
    plantId: string;
    processOrderNo: string;
    processOrderType: string;
    processOrderDate: moment.Moment;
    productCode: string;
    issueQuantityUOM: string | undefined;
    issueIndicator: string | undefined;
    listOfMaterials: ProcessOrderMaterialDto[] | undefined;
    isReservationNo: boolean;
}

export class ProcessOrderMaterialInternalDto implements IProcessOrderMaterialInternalDto {
    processOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number | undefined;
    unitOfMeasurementId: number | undefined;
    unitOfMeasurement: string | undefined;
    tenantId: number | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    arNo: string | undefined;
    id: number;

    constructor(data?: IProcessOrderMaterialInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderNo = _data["processOrderNo"];
            this.itemNo = _data["itemNo"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.orderQuantity = _data["orderQuantity"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.tenantId = _data["tenantId"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
            this.arNo = _data["arNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessOrderMaterialInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderMaterialInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderNo"] = this.processOrderNo;
        data["itemNo"] = this.itemNo;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["orderQuantity"] = this.orderQuantity;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["tenantId"] = this.tenantId;
        data["batchNo"] = this.batchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        data["arNo"] = this.arNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessOrderMaterialInternalDto {
        const json = this.toJSON();
        let result = new ProcessOrderMaterialInternalDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderMaterialInternalDto {
    processOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number | undefined;
    unitOfMeasurementId: number | undefined;
    unitOfMeasurement: string | undefined;
    tenantId: number | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
    arNo: string | undefined;
    id: number;
}

export class ProcessOrderInternalDto implements IProcessOrderInternalDto {
    plantId: number;
    processOrderNo: string;
    processOrderType: string;
    processOrderDate: moment.Moment;
    productCode: string;
    issueQuantityUOM: string | undefined;
    issueIndicator: string | undefined;
    listOfMaterials: ProcessOrderMaterialInternalDto[] | undefined;
    id: number;

    constructor(data?: IProcessOrderInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.processOrderNo = _data["processOrderNo"];
            this.processOrderType = _data["processOrderType"];
            this.processOrderDate = _data["processOrderDate"] ? moment(_data["processOrderDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
            this.issueQuantityUOM = _data["issueQuantityUOM"];
            this.issueIndicator = _data["issueIndicator"];
            if (Array.isArray(_data["listOfMaterials"])) {
                this.listOfMaterials = [] as any;
                for (let item of _data["listOfMaterials"])
                    this.listOfMaterials.push(ProcessOrderMaterialInternalDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessOrderInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["processOrderNo"] = this.processOrderNo;
        data["processOrderType"] = this.processOrderType;
        data["processOrderDate"] = this.processOrderDate ? this.processOrderDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["issueQuantityUOM"] = this.issueQuantityUOM;
        data["issueIndicator"] = this.issueIndicator;
        if (Array.isArray(this.listOfMaterials)) {
            data["listOfMaterials"] = [];
            for (let item of this.listOfMaterials)
                data["listOfMaterials"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessOrderInternalDto {
        const json = this.toJSON();
        let result = new ProcessOrderInternalDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderInternalDto {
    plantId: number;
    processOrderNo: string;
    processOrderType: string;
    processOrderDate: moment.Moment;
    productCode: string;
    issueQuantityUOM: string | undefined;
    issueIndicator: string | undefined;
    listOfMaterials: ProcessOrderMaterialInternalDto[] | undefined;
    id: number;
}

export class ProcessOrderMaterialAfterReleasDto implements IProcessOrderMaterialAfterReleasDto {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    productBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    unitOfMeasurement: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;

    constructor(data?: IProcessOrderMaterialAfterReleasDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.arNo = _data["arNo"];
            this.lotNo = _data["lotNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.productBatchNo = _data["productBatchNo"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.quantity = _data["quantity"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.retestDate = _data["retestDate"] ? moment(_data["retestDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessOrderMaterialAfterReleasDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderMaterialAfterReleasDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["lineItemNo"] = this.lineItemNo;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["arNo"] = this.arNo;
        data["lotNo"] = this.lotNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["productBatchNo"] = this.productBatchNo;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["quantity"] = this.quantity;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["retestDate"] = this.retestDate ? this.retestDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ProcessOrderMaterialAfterReleasDto {
        const json = this.toJSON();
        let result = new ProcessOrderMaterialAfterReleasDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderMaterialAfterReleasDto {
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    productBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    unitOfMeasurement: string | undefined;
    expiryDate: moment.Moment;
    retestDate: moment.Moment;
}

export class ProcessOrderAfterReleasDto implements IProcessOrderAfterReleasDto {
    plantId: string;
    processOrderNo: string;
    processOrderType: string | undefined;
    processOrderDate: moment.Moment;
    productCode: string;
    productCodeId: number | undefined;
    tecoFlag: boolean;
    isPicking: boolean;
    listOfMaterials: ProcessOrderMaterialAfterReleasDto[] | undefined;

    constructor(data?: IProcessOrderAfterReleasDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.processOrderNo = _data["processOrderNo"];
            this.processOrderType = _data["processOrderType"];
            this.processOrderDate = _data["processOrderDate"] ? moment(_data["processOrderDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
            this.productCodeId = _data["productCodeId"];
            this.tecoFlag = _data["tecoFlag"];
            this.isPicking = _data["isPicking"];
            if (Array.isArray(_data["listOfMaterials"])) {
                this.listOfMaterials = [] as any;
                for (let item of _data["listOfMaterials"])
                    this.listOfMaterials.push(ProcessOrderMaterialAfterReleasDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessOrderAfterReleasDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderAfterReleasDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["processOrderNo"] = this.processOrderNo;
        data["processOrderType"] = this.processOrderType;
        data["processOrderDate"] = this.processOrderDate ? this.processOrderDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["productCodeId"] = this.productCodeId;
        data["tecoFlag"] = this.tecoFlag;
        data["isPicking"] = this.isPicking;
        if (Array.isArray(this.listOfMaterials)) {
            data["listOfMaterials"] = [];
            for (let item of this.listOfMaterials)
                data["listOfMaterials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProcessOrderAfterReleasDto {
        const json = this.toJSON();
        let result = new ProcessOrderAfterReleasDto();
        result.init(json);
        return result;
    }
}

export interface IProcessOrderAfterReleasDto {
    plantId: string;
    processOrderNo: string;
    processOrderType: string | undefined;
    processOrderDate: moment.Moment;
    productCode: string;
    productCodeId: number | undefined;
    tecoFlag: boolean;
    isPicking: boolean;
    listOfMaterials: ProcessOrderMaterialAfterReleasDto[] | undefined;
}

export class MaterialDto implements IMaterialDto {
    purchaseOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.itemNo = _data["itemNo"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.orderQuantity = _data["orderQuantity"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["itemNo"] = this.itemNo;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["orderQuantity"] = this.orderQuantity;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        return data; 
    }

    clone(): MaterialDto {
        const json = this.toJSON();
        let result = new MaterialDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDto {
    purchaseOrderNo: string;
    itemNo: string;
    itemCode: string;
    itemDescription: string | undefined;
    orderQuantity: number;
    unitOfMeasurement: string | undefined;
}

export class PurchaseOrderDto implements IPurchaseOrderDto {
    plantId: string;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    listOfMaterials: MaterialDto[] | undefined;

    constructor(data?: IPurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.purchaseOrderDate = _data["purchaseOrderDate"] ? moment(_data["purchaseOrderDate"].toString()) : <any>undefined;
            this.vendorName = _data["vendorName"];
            this.vendorCode = _data["vendorCode"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
            if (Array.isArray(_data["listOfMaterials"])) {
                this.listOfMaterials = [] as any;
                for (let item of _data["listOfMaterials"])
                    this.listOfMaterials.push(MaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["purchaseOrderDate"] = this.purchaseOrderDate ? this.purchaseOrderDate.toISOString() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["vendorCode"] = this.vendorCode;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        if (Array.isArray(this.listOfMaterials)) {
            data["listOfMaterials"] = [];
            for (let item of this.listOfMaterials)
                data["listOfMaterials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PurchaseOrderDto {
        const json = this.toJSON();
        let result = new PurchaseOrderDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderDto {
    plantId: string;
    purchaseOrderNo: string;
    purchaseOrderDate: moment.Moment;
    vendorName: string;
    vendorCode: string;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
    listOfMaterials: MaterialDto[] | undefined;
}

export class CreatePutawayDto implements ICreatePutawayDto {
    locationId: number;
    containerId: number;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    processOrderNo: string | undefined;
    storageLocation: string | undefined;
    processOrderId: number;
    productCodeId: number;

    constructor(data?: ICreatePutawayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.isActive = _data["isActive"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchNo = _data["batchNo"];
            this.processOrderNo = _data["processOrderNo"];
            this.storageLocation = _data["storageLocation"];
            this.processOrderId = _data["processOrderId"];
            this.productCodeId = _data["productCodeId"];
        }
    }

    static fromJS(data: any): CreatePutawayDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePutawayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["isActive"] = this.isActive;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchNo"] = this.batchNo;
        data["processOrderNo"] = this.processOrderNo;
        data["storageLocation"] = this.storageLocation;
        data["processOrderId"] = this.processOrderId;
        data["productCodeId"] = this.productCodeId;
        return data; 
    }

    clone(): CreatePutawayDto {
        const json = this.toJSON();
        let result = new CreatePutawayDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePutawayDto {
    locationId: number;
    containerId: number;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    processOrderNo: string | undefined;
    storageLocation: string | undefined;
    processOrderId: number;
    productCodeId: number;
}

export class PutawayDto implements IPutawayDto {
    locationId: number;
    containerId: number;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    storageLocation: string | undefined;
    processOrderId: number;
    productCodeId: number;
    processOrderNo: string | undefined;
    noOfContainer: string | undefined;
    id: number;

    constructor(data?: IPutawayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.isActive = _data["isActive"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchNo = _data["batchNo"];
            this.storageLocation = _data["storageLocation"];
            this.processOrderId = _data["processOrderId"];
            this.productCodeId = _data["productCodeId"];
            this.processOrderNo = _data["processOrderNo"];
            this.noOfContainer = _data["noOfContainer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PutawayDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutawayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["isActive"] = this.isActive;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchNo"] = this.batchNo;
        data["storageLocation"] = this.storageLocation;
        data["processOrderId"] = this.processOrderId;
        data["productCodeId"] = this.productCodeId;
        data["processOrderNo"] = this.processOrderNo;
        data["noOfContainer"] = this.noOfContainer;
        data["id"] = this.id;
        return data; 
    }

    clone(): PutawayDto {
        const json = this.toJSON();
        let result = new PutawayDto();
        result.init(json);
        return result;
    }
}

export interface IPutawayDto {
    locationId: number;
    containerId: number;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    productName: string | undefined;
    batchNo: string | undefined;
    storageLocation: string | undefined;
    processOrderId: number;
    productCodeId: number;
    processOrderNo: string | undefined;
    noOfContainer: string | undefined;
    id: number;
}

export class PutawayListDto implements IPutawayListDto {
    locationId: number | undefined;
    locationName: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    processOrder: string | undefined;
    productName: string | undefined;
    storageLocation: string | undefined;
    id: number;

    constructor(data?: IPutawayListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.isActive = _data["isActive"];
            this.productCode = _data["productCode"];
            this.processOrder = _data["processOrder"];
            this.productName = _data["productName"];
            this.storageLocation = _data["storageLocation"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PutawayListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutawayListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["isActive"] = this.isActive;
        data["productCode"] = this.productCode;
        data["processOrder"] = this.processOrder;
        data["productName"] = this.productName;
        data["storageLocation"] = this.storageLocation;
        data["id"] = this.id;
        return data; 
    }

    clone(): PutawayListDto {
        const json = this.toJSON();
        let result = new PutawayListDto();
        result.init(json);
        return result;
    }
}

export interface IPutawayListDto {
    locationId: number | undefined;
    locationName: string | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    isActive: boolean;
    productCode: string | undefined;
    processOrder: string | undefined;
    productName: string | undefined;
    storageLocation: string | undefined;
    id: number;
}

export class PutawayListDtoPagedResultDto implements IPutawayListDtoPagedResultDto {
    totalCount: number;
    items: PutawayListDto[] | undefined;

    constructor(data?: IPutawayListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PutawayListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutawayListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutawayListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PutawayListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PutawayListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPutawayListDtoPagedResultDto {
    totalCount: number;
    items: PutawayListDto[] | undefined;
}

export class CreateCubicalRecipeTranDetlMapping implements ICreateCubicalRecipeTranDetlMapping {
    recipeTransactiondetailId: number | undefined;
    operation: string | undefined;
    cubicalId: number;
    isActive: boolean;

    constructor(data?: ICreateCubicalRecipeTranDetlMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeTransactiondetailId = _data["recipeTransactiondetailId"];
            this.operation = _data["operation"];
            this.cubicalId = _data["cubicalId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCubicalRecipeTranDetlMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCubicalRecipeTranDetlMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeTransactiondetailId"] = this.recipeTransactiondetailId;
        data["operation"] = this.operation;
        data["cubicalId"] = this.cubicalId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateCubicalRecipeTranDetlMapping {
        const json = this.toJSON();
        let result = new CreateCubicalRecipeTranDetlMapping();
        result.init(json);
        return result;
    }
}

export interface ICreateCubicalRecipeTranDetlMapping {
    recipeTransactiondetailId: number | undefined;
    operation: string | undefined;
    cubicalId: number;
    isActive: boolean;
}

export class CreateCompRecipeTransDetlMapping implements ICreateCompRecipeTransDetlMapping {
    recipeTransactiondetailId: number;
    operation: string | undefined;
    componentId: number | undefined;
    componentCode: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateCompRecipeTransDetlMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeTransactiondetailId = _data["recipeTransactiondetailId"];
            this.operation = _data["operation"];
            this.componentId = _data["componentId"];
            this.componentCode = _data["componentCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCompRecipeTransDetlMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompRecipeTransDetlMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeTransactiondetailId"] = this.recipeTransactiondetailId;
        data["operation"] = this.operation;
        data["componentId"] = this.componentId;
        data["componentCode"] = this.componentCode;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateCompRecipeTransDetlMapping {
        const json = this.toJSON();
        let result = new CreateCompRecipeTransDetlMapping();
        result.init(json);
        return result;
    }
}

export interface ICreateCompRecipeTransDetlMapping {
    recipeTransactiondetailId: number;
    operation: string | undefined;
    componentId: number | undefined;
    componentCode: string | undefined;
    isActive: boolean;
}

export class CreayeRecipeMasterdetail implements ICreayeRecipeMasterdetail {
    recipeTransHdrId: number | undefined;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    materialDescription: string | undefined;
    productName: string | undefined;
    productId: number;
    approvalRemarks: string | undefined;
    createCubicalRecipeTranDetlMapping: CreateCubicalRecipeTranDetlMapping[] | undefined;
    createCompRecipeTransDetlMapping: CreateCompRecipeTransDetlMapping[] | undefined;

    constructor(data?: ICreayeRecipeMasterdetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.operation = _data["operation"];
            this.stage = _data["stage"];
            this.nextOperation = _data["nextOperation"];
            this.component = _data["component"];
            this.isWeightRequired = _data["isWeightRequired"];
            this.isLebalPrintingRequired = _data["isLebalPrintingRequired"];
            this.isVerificationReq = _data["isVerificationReq"];
            this.inProcessSamplingRequired = _data["inProcessSamplingRequired"];
            this.isSamplingReq = _data["isSamplingReq"];
            this.isActive = _data["isActive"];
            this.documentVersion = _data["documentVersion"];
            this.recipeNo = _data["recipeNo"];
            this.materialDescription = _data["materialDescription"];
            this.productName = _data["productName"];
            this.productId = _data["productId"];
            this.approvalRemarks = _data["approvalRemarks"];
            if (Array.isArray(_data["createCubicalRecipeTranDetlMapping"])) {
                this.createCubicalRecipeTranDetlMapping = [] as any;
                for (let item of _data["createCubicalRecipeTranDetlMapping"])
                    this.createCubicalRecipeTranDetlMapping.push(CreateCubicalRecipeTranDetlMapping.fromJS(item));
            }
            if (Array.isArray(_data["createCompRecipeTransDetlMapping"])) {
                this.createCompRecipeTransDetlMapping = [] as any;
                for (let item of _data["createCompRecipeTransDetlMapping"])
                    this.createCompRecipeTransDetlMapping.push(CreateCompRecipeTransDetlMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreayeRecipeMasterdetail {
        data = typeof data === 'object' ? data : {};
        let result = new CreayeRecipeMasterdetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["operation"] = this.operation;
        data["stage"] = this.stage;
        data["nextOperation"] = this.nextOperation;
        data["component"] = this.component;
        data["isWeightRequired"] = this.isWeightRequired;
        data["isLebalPrintingRequired"] = this.isLebalPrintingRequired;
        data["isVerificationReq"] = this.isVerificationReq;
        data["inProcessSamplingRequired"] = this.inProcessSamplingRequired;
        data["isSamplingReq"] = this.isSamplingReq;
        data["isActive"] = this.isActive;
        data["documentVersion"] = this.documentVersion;
        data["recipeNo"] = this.recipeNo;
        data["materialDescription"] = this.materialDescription;
        data["productName"] = this.productName;
        data["productId"] = this.productId;
        data["approvalRemarks"] = this.approvalRemarks;
        if (Array.isArray(this.createCubicalRecipeTranDetlMapping)) {
            data["createCubicalRecipeTranDetlMapping"] = [];
            for (let item of this.createCubicalRecipeTranDetlMapping)
                data["createCubicalRecipeTranDetlMapping"].push(item.toJSON());
        }
        if (Array.isArray(this.createCompRecipeTransDetlMapping)) {
            data["createCompRecipeTransDetlMapping"] = [];
            for (let item of this.createCompRecipeTransDetlMapping)
                data["createCompRecipeTransDetlMapping"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreayeRecipeMasterdetail {
        const json = this.toJSON();
        let result = new CreayeRecipeMasterdetail();
        result.init(json);
        return result;
    }
}

export interface ICreayeRecipeMasterdetail {
    recipeTransHdrId: number | undefined;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    materialDescription: string | undefined;
    productName: string | undefined;
    productId: number;
    approvalRemarks: string | undefined;
    createCubicalRecipeTranDetlMapping: CreateCubicalRecipeTranDetlMapping[] | undefined;
    createCompRecipeTransDetlMapping: CreateCompRecipeTransDetlMapping[] | undefined;
}

export class CreateRecipeMasterDto implements ICreateRecipeMasterDto {
    productId: number | undefined;
    productCode: string | undefined;
    materialDescription: string | undefined;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    approvedById: number | undefined;
    approvedLevelId: number | undefined;
    approvedDate: moment.Moment | undefined;
    approvalRemarks: string | undefined;
    approvalStatus: string | undefined;
    isActive: boolean;
    recipeTransactionDetails: CreayeRecipeMasterdetail[] | undefined;

    constructor(data?: ICreateRecipeMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.materialDescription = _data["materialDescription"];
            this.documentVersion = _data["documentVersion"];
            this.recipeNo = _data["recipeNo"];
            this.approvedById = _data["approvedById"];
            this.approvedLevelId = _data["approvedLevelId"];
            this.approvedDate = _data["approvedDate"] ? moment(_data["approvedDate"].toString()) : <any>undefined;
            this.approvalRemarks = _data["approvalRemarks"];
            this.approvalStatus = _data["approvalStatus"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["recipeTransactionDetails"])) {
                this.recipeTransactionDetails = [] as any;
                for (let item of _data["recipeTransactionDetails"])
                    this.recipeTransactionDetails.push(CreayeRecipeMasterdetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRecipeMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["materialDescription"] = this.materialDescription;
        data["documentVersion"] = this.documentVersion;
        data["recipeNo"] = this.recipeNo;
        data["approvedById"] = this.approvedById;
        data["approvedLevelId"] = this.approvedLevelId;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toISOString() : <any>undefined;
        data["approvalRemarks"] = this.approvalRemarks;
        data["approvalStatus"] = this.approvalStatus;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.recipeTransactionDetails)) {
            data["recipeTransactionDetails"] = [];
            for (let item of this.recipeTransactionDetails)
                data["recipeTransactionDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateRecipeMasterDto {
        const json = this.toJSON();
        let result = new CreateRecipeMasterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRecipeMasterDto {
    productId: number | undefined;
    productCode: string | undefined;
    materialDescription: string | undefined;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    approvedById: number | undefined;
    approvedLevelId: number | undefined;
    approvedDate: moment.Moment | undefined;
    approvalRemarks: string | undefined;
    approvalStatus: string | undefined;
    isActive: boolean;
    recipeTransactionDetails: CreayeRecipeMasterdetail[] | undefined;
}

export class RecipeMasterListDto implements IRecipeMasterListDto {
    recipeId: number;
    productId: number;
    recipeNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productNo: string | undefined;
    docVersion: string | undefined;
    tenantId: number | undefined;
    userEnteredProductCode: string | undefined;
    userEnteredProductName: string | undefined;
    approvedLevelId: number | undefined;
    approvalStatus: string | undefined;
    id: number;

    constructor(data?: IRecipeMasterListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeId = _data["recipeId"];
            this.productId = _data["productId"];
            this.recipeNo = _data["recipeNo"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            this.docVersion = _data["docVersion"];
            this.tenantId = _data["tenantId"];
            this.userEnteredProductCode = _data["userEnteredProductCode"];
            this.userEnteredProductName = _data["userEnteredProductName"];
            this.approvedLevelId = _data["approvedLevelId"];
            this.approvalStatus = _data["approvalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecipeMasterListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeMasterListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeId"] = this.recipeId;
        data["productId"] = this.productId;
        data["recipeNo"] = this.recipeNo;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        data["docVersion"] = this.docVersion;
        data["tenantId"] = this.tenantId;
        data["userEnteredProductCode"] = this.userEnteredProductCode;
        data["userEnteredProductName"] = this.userEnteredProductName;
        data["approvedLevelId"] = this.approvedLevelId;
        data["approvalStatus"] = this.approvalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecipeMasterListDto {
        const json = this.toJSON();
        let result = new RecipeMasterListDto();
        result.init(json);
        return result;
    }
}

export interface IRecipeMasterListDto {
    recipeId: number;
    productId: number;
    recipeNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productNo: string | undefined;
    docVersion: string | undefined;
    tenantId: number | undefined;
    userEnteredProductCode: string | undefined;
    userEnteredProductName: string | undefined;
    approvedLevelId: number | undefined;
    approvalStatus: string | undefined;
    id: number;
}

export class RecipeMasterListDtoPagedResultDto implements IRecipeMasterListDtoPagedResultDto {
    totalCount: number;
    items: RecipeMasterListDto[] | undefined;

    constructor(data?: IRecipeMasterListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RecipeMasterListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeMasterListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeMasterListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RecipeMasterListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RecipeMasterListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRecipeMasterListDtoPagedResultDto {
    totalCount: number;
    items: RecipeMasterListDto[] | undefined;
}

export class CreateRecipeToPOLinkDto implements ICreateRecipeToPOLinkDto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    remarks: string | undefined;
    productId: number;

    constructor(data?: ICreateRecipeToPOLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.remarks = _data["remarks"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateRecipeToPOLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeToPOLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["remarks"] = this.remarks;
        data["productId"] = this.productId;
        return data; 
    }

    clone(): CreateRecipeToPOLinkDto {
        const json = this.toJSON();
        let result = new CreateRecipeToPOLinkDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRecipeToPOLinkDto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    remarks: string | undefined;
    productId: number;
}

export class RecipeToPOLinkDto implements IRecipeToPOLinkDto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    remarks: string | undefined;
    productId: number;
    id: number;

    constructor(data?: IRecipeToPOLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.remarks = _data["remarks"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecipeToPOLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeToPOLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["remarks"] = this.remarks;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecipeToPOLinkDto {
        const json = this.toJSON();
        let result = new RecipeToPOLinkDto();
        result.init(json);
        return result;
    }
}

export interface IRecipeToPOLinkDto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    remarks: string | undefined;
    productId: number;
    id: number;
}

export class CreayeRecipeMasterdetail1 implements ICreayeRecipeMasterdetail1 {
    recipeTransHdrId: number;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;

    constructor(data?: ICreayeRecipeMasterdetail1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.operation = _data["operation"];
            this.stage = _data["stage"];
            this.nextOperation = _data["nextOperation"];
            this.component = _data["component"];
            this.isWeightRequired = _data["isWeightRequired"];
            this.isLebalPrintingRequired = _data["isLebalPrintingRequired"];
            this.isVerificationReq = _data["isVerificationReq"];
            this.inProcessSamplingRequired = _data["inProcessSamplingRequired"];
            this.isSamplingReq = _data["isSamplingReq"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreayeRecipeMasterdetail1 {
        data = typeof data === 'object' ? data : {};
        let result = new CreayeRecipeMasterdetail1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["operation"] = this.operation;
        data["stage"] = this.stage;
        data["nextOperation"] = this.nextOperation;
        data["component"] = this.component;
        data["isWeightRequired"] = this.isWeightRequired;
        data["isLebalPrintingRequired"] = this.isLebalPrintingRequired;
        data["isVerificationReq"] = this.isVerificationReq;
        data["inProcessSamplingRequired"] = this.inProcessSamplingRequired;
        data["isSamplingReq"] = this.isSamplingReq;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreayeRecipeMasterdetail1 {
        const json = this.toJSON();
        let result = new CreayeRecipeMasterdetail1();
        result.init(json);
        return result;
    }
}

export interface ICreayeRecipeMasterdetail1 {
    recipeTransHdrId: number;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;
}

export class CreateRecipeDetailsDto implements ICreateRecipeDetailsDto {
    productId: number;
    processOrderId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    approvedById: number | undefined;
    approvedLevelId: number | undefined;
    approvedDate: moment.Moment | undefined;
    approvalRemarks: string | undefined;
    approvalStatus: string | undefined;
    isActive: boolean;
    recipeTransactionDetails: CreayeRecipeMasterdetail1[] | undefined;
    id: number;

    constructor(data?: ICreateRecipeDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.processOrderId = _data["processOrderId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.processOrderNo = _data["processOrderNo"];
            this.documentVersion = _data["documentVersion"];
            this.recipeNo = _data["recipeNo"];
            this.approvedById = _data["approvedById"];
            this.approvedLevelId = _data["approvedLevelId"];
            this.approvedDate = _data["approvedDate"] ? moment(_data["approvedDate"].toString()) : <any>undefined;
            this.approvalRemarks = _data["approvalRemarks"];
            this.approvalStatus = _data["approvalStatus"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["recipeTransactionDetails"])) {
                this.recipeTransactionDetails = [] as any;
                for (let item of _data["recipeTransactionDetails"])
                    this.recipeTransactionDetails.push(CreayeRecipeMasterdetail1.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateRecipeDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["processOrderId"] = this.processOrderId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["processOrderNo"] = this.processOrderNo;
        data["documentVersion"] = this.documentVersion;
        data["recipeNo"] = this.recipeNo;
        data["approvedById"] = this.approvedById;
        data["approvedLevelId"] = this.approvedLevelId;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toISOString() : <any>undefined;
        data["approvalRemarks"] = this.approvalRemarks;
        data["approvalStatus"] = this.approvalStatus;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.recipeTransactionDetails)) {
            data["recipeTransactionDetails"] = [];
            for (let item of this.recipeTransactionDetails)
                data["recipeTransactionDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateRecipeDetailsDto {
        const json = this.toJSON();
        let result = new CreateRecipeDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRecipeDetailsDto {
    productId: number;
    processOrderId: number;
    productCode: string | undefined;
    productName: string | undefined;
    processOrderNo: string | undefined;
    documentVersion: string | undefined;
    recipeNo: string | undefined;
    approvedById: number | undefined;
    approvedLevelId: number | undefined;
    approvedDate: moment.Moment | undefined;
    approvalRemarks: string | undefined;
    approvalStatus: string | undefined;
    isActive: boolean;
    recipeTransactionDetails: CreayeRecipeMasterdetail1[] | undefined;
    id: number;
}

export class RecipeToPODto implements IRecipeToPODto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    processOrderNo: string | undefined;
    recipeNo: string | undefined;
    documentVersion: string | undefined;
    id: number;

    constructor(data?: IRecipeToPODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.processOrderNo = _data["processOrderNo"];
            this.recipeNo = _data["recipeNo"];
            this.documentVersion = _data["documentVersion"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecipeToPODto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeToPODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["processOrderNo"] = this.processOrderNo;
        data["recipeNo"] = this.recipeNo;
        data["documentVersion"] = this.documentVersion;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecipeToPODto {
        const json = this.toJSON();
        let result = new RecipeToPODto();
        result.init(json);
        return result;
    }
}

export interface IRecipeToPODto {
    processOrderId: number | undefined;
    recipeTransHdrId: number | undefined;
    processOrderNo: string | undefined;
    recipeNo: string | undefined;
    documentVersion: string | undefined;
    id: number;
}

export class MaterialListDto implements IMaterialListDto {
    processOrderId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arno: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    uom: string | undefined;
    id: number;

    constructor(data?: IMaterialListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.arno = _data["arno"];
            this.lotNo = _data["lotNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["arno"] = this.arno;
        data["lotNo"] = this.lotNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialListDto {
        const json = this.toJSON();
        let result = new MaterialListDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialListDto {
    processOrderId: number | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arno: string | undefined;
    lotNo: string | undefined;
    sapBatchNo: string | undefined;
    currentStage: string | undefined;
    nextStage: string | undefined;
    quantity: number;
    uom: string | undefined;
    id: number;
}

export class RecipePOMappingListDto implements IRecipePOMappingListDto {
    recipeId: number;
    productId: number;
    recipeNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productNo: string | undefined;
    docVersion: string | undefined;
    tenantId: number | undefined;
    userEnteredProductCode: string | undefined;
    userEnteredProductName: string | undefined;
    id: number;

    constructor(data?: IRecipePOMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeId = _data["recipeId"];
            this.productId = _data["productId"];
            this.recipeNo = _data["recipeNo"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productNo = _data["productNo"];
            this.docVersion = _data["docVersion"];
            this.tenantId = _data["tenantId"];
            this.userEnteredProductCode = _data["userEnteredProductCode"];
            this.userEnteredProductName = _data["userEnteredProductName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecipePOMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipePOMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeId"] = this.recipeId;
        data["productId"] = this.productId;
        data["recipeNo"] = this.recipeNo;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productNo"] = this.productNo;
        data["docVersion"] = this.docVersion;
        data["tenantId"] = this.tenantId;
        data["userEnteredProductCode"] = this.userEnteredProductCode;
        data["userEnteredProductName"] = this.userEnteredProductName;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecipePOMappingListDto {
        const json = this.toJSON();
        let result = new RecipePOMappingListDto();
        result.init(json);
        return result;
    }
}

export interface IRecipePOMappingListDto {
    recipeId: number;
    productId: number;
    recipeNo: string | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productNo: string | undefined;
    docVersion: string | undefined;
    tenantId: number | undefined;
    userEnteredProductCode: string | undefined;
    userEnteredProductName: string | undefined;
    id: number;
}

export class RecipePOMappingListDtoPagedResultDto implements IRecipePOMappingListDtoPagedResultDto {
    totalCount: number;
    items: RecipePOMappingListDto[] | undefined;

    constructor(data?: IRecipePOMappingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RecipePOMappingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipePOMappingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipePOMappingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RecipePOMappingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RecipePOMappingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRecipePOMappingListDtoPagedResultDto {
    totalCount: number;
    items: RecipePOMappingListDto[] | undefined;
}

export class RecipeListDto implements IRecipeListDto {
    recipeTransHdrId: number;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;
    id: number;

    constructor(data?: IRecipeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeTransHdrId = _data["recipeTransHdrId"];
            this.operation = _data["operation"];
            this.stage = _data["stage"];
            this.nextOperation = _data["nextOperation"];
            this.component = _data["component"];
            this.isWeightRequired = _data["isWeightRequired"];
            this.isLebalPrintingRequired = _data["isLebalPrintingRequired"];
            this.isVerificationReq = _data["isVerificationReq"];
            this.inProcessSamplingRequired = _data["inProcessSamplingRequired"];
            this.isSamplingReq = _data["isSamplingReq"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RecipeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeTransHdrId"] = this.recipeTransHdrId;
        data["operation"] = this.operation;
        data["stage"] = this.stage;
        data["nextOperation"] = this.nextOperation;
        data["component"] = this.component;
        data["isWeightRequired"] = this.isWeightRequired;
        data["isLebalPrintingRequired"] = this.isLebalPrintingRequired;
        data["isVerificationReq"] = this.isVerificationReq;
        data["inProcessSamplingRequired"] = this.inProcessSamplingRequired;
        data["isSamplingReq"] = this.isSamplingReq;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): RecipeListDto {
        const json = this.toJSON();
        let result = new RecipeListDto();
        result.init(json);
        return result;
    }
}

export interface IRecipeListDto {
    recipeTransHdrId: number;
    operation: string | undefined;
    stage: string | undefined;
    nextOperation: string | undefined;
    component: string | undefined;
    isWeightRequired: boolean;
    isLebalPrintingRequired: boolean;
    isVerificationReq: boolean;
    inProcessSamplingRequired: boolean;
    isSamplingReq: boolean;
    isActive: boolean;
    id: number;
}

export class VehicleInspectionCheckPointReportResultDto implements IVehicleInspectionCheckPointReportResultDto {
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    id: number;

    constructor(data?: IVehicleInspectionCheckPointReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkpointName = _data["checkpointName"];
            this.checkpointType = _data["checkpointType"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            this.userdEnteredValue = _data["userdEnteredValue"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionCheckPointReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionCheckPointReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkpointName"] = this.checkpointName;
        data["checkpointType"] = this.checkpointType;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        data["userdEnteredValue"] = this.userdEnteredValue;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionCheckPointReportResultDto {
        const json = this.toJSON();
        let result = new VehicleInspectionCheckPointReportResultDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionCheckPointReportResultDto {
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    id: number;
}

export class VehicleInspectionReportResultDto implements IVehicleInspectionReportResultDto {
    inspectionDate: moment.Moment;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    checklistName: string | undefined;
    purchaseOrderId: number;
    invoiceId: number;
    subPlantId: number;
    gateEntryId: number;
    vehicleInspectionDetailId: number;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    transactionStatusId: number;
    transactionStatus: string | undefined;
    materialCode: string | undefined;
    materialId: number;
    checkPointId: number;
    inspectedBy: string | undefined;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;

    constructor(data?: IVehicleInspectionReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionDate = _data["inspectionDate"] ? moment(_data["inspectionDate"].toString()) : <any>undefined;
            this.gatePassNo = _data["gatePassNo"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.checklistName = _data["checklistName"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.invoiceId = _data["invoiceId"];
            this.subPlantId = _data["subPlantId"];
            this.gateEntryId = _data["gateEntryId"];
            this.vehicleInspectionDetailId = _data["vehicleInspectionDetailId"];
            this.checkpointName = _data["checkpointName"];
            this.checkpointType = _data["checkpointType"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            this.userdEnteredValue = _data["userdEnteredValue"];
            this.remark = _data["remark"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.transactionStatus = _data["transactionStatus"];
            this.materialCode = _data["materialCode"];
            this.materialId = _data["materialId"];
            this.checkPointId = _data["checkPointId"];
            this.inspectedBy = _data["inspectedBy"];
            if (Array.isArray(_data["checkPoints"])) {
                this.checkPoints = [] as any;
                for (let item of _data["checkPoints"])
                    this.checkPoints.push(VehicleInspectionCheckPointReportResultDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toISOString() : <any>undefined;
        data["gatePassNo"] = this.gatePassNo;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["invoiceNo"] = this.invoiceNo;
        data["checklistName"] = this.checklistName;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["invoiceId"] = this.invoiceId;
        data["subPlantId"] = this.subPlantId;
        data["gateEntryId"] = this.gateEntryId;
        data["vehicleInspectionDetailId"] = this.vehicleInspectionDetailId;
        data["checkpointName"] = this.checkpointName;
        data["checkpointType"] = this.checkpointType;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        data["userdEnteredValue"] = this.userdEnteredValue;
        data["remark"] = this.remark;
        data["transactionStatusId"] = this.transactionStatusId;
        data["transactionStatus"] = this.transactionStatus;
        data["materialCode"] = this.materialCode;
        data["materialId"] = this.materialId;
        data["checkPointId"] = this.checkPointId;
        data["inspectedBy"] = this.inspectedBy;
        if (Array.isArray(this.checkPoints)) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionReportResultDto {
        const json = this.toJSON();
        let result = new VehicleInspectionReportResultDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionReportResultDto {
    inspectionDate: moment.Moment;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    checklistName: string | undefined;
    purchaseOrderId: number;
    invoiceId: number;
    subPlantId: number;
    gateEntryId: number;
    vehicleInspectionDetailId: number;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    transactionStatusId: number;
    transactionStatus: string | undefined;
    materialCode: string | undefined;
    materialId: number;
    checkPointId: number;
    inspectedBy: string | undefined;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;
}

export class AllocationReportResultDto implements IAllocationReportResultDto {
    allocationDate: moment.Moment;
    plantCode: string | undefined;
    areaCode: string | undefined;
    locationCode: string | undefined;
    palletCode: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    balQty: number | undefined;
    qty: number | undefined;
    containerBarcode: string | undefined;
    stockStatus: string | undefined;
    subPlantId: number | undefined;
    areaId: number | undefined;
    locationId: number | undefined;
    palletId: number | undefined;
    materialId: number | undefined;
    allocatedBy: string | undefined;
    id: number;

    constructor(data?: IAllocationReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allocationDate = _data["allocationDate"] ? moment(_data["allocationDate"].toString()) : <any>undefined;
            this.plantCode = _data["plantCode"];
            this.areaCode = _data["areaCode"];
            this.locationCode = _data["locationCode"];
            this.palletCode = _data["palletCode"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.balQty = _data["balQty"];
            this.qty = _data["qty"];
            this.containerBarcode = _data["containerBarcode"];
            this.stockStatus = _data["stockStatus"];
            this.subPlantId = _data["subPlantId"];
            this.areaId = _data["areaId"];
            this.locationId = _data["locationId"];
            this.palletId = _data["palletId"];
            this.materialId = _data["materialId"];
            this.allocatedBy = _data["allocatedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AllocationReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllocationReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allocationDate"] = this.allocationDate ? this.allocationDate.toISOString() : <any>undefined;
        data["plantCode"] = this.plantCode;
        data["areaCode"] = this.areaCode;
        data["locationCode"] = this.locationCode;
        data["palletCode"] = this.palletCode;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["balQty"] = this.balQty;
        data["qty"] = this.qty;
        data["containerBarcode"] = this.containerBarcode;
        data["stockStatus"] = this.stockStatus;
        data["subPlantId"] = this.subPlantId;
        data["areaId"] = this.areaId;
        data["locationId"] = this.locationId;
        data["palletId"] = this.palletId;
        data["materialId"] = this.materialId;
        data["allocatedBy"] = this.allocatedBy;
        data["id"] = this.id;
        return data; 
    }

    clone(): AllocationReportResultDto {
        const json = this.toJSON();
        let result = new AllocationReportResultDto();
        result.init(json);
        return result;
    }
}

export interface IAllocationReportResultDto {
    allocationDate: moment.Moment;
    plantCode: string | undefined;
    areaCode: string | undefined;
    locationCode: string | undefined;
    palletCode: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    balQty: number | undefined;
    qty: number | undefined;
    containerBarcode: string | undefined;
    stockStatus: string | undefined;
    subPlantId: number | undefined;
    areaId: number | undefined;
    locationId: number | undefined;
    palletId: number | undefined;
    materialId: number | undefined;
    allocatedBy: string | undefined;
    id: number;
}

export class CubicleAssignedReportResultDto implements ICubicleAssignedReportResultDto {
    cubicleAssignmentDate: moment.Moment;
    plantCode: string | undefined;
    cubicleCode: string | undefined;
    groupCode: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    balQty: number | undefined;
    qty: number | undefined;
    cubicleStatus: string | undefined;
    subPlantId: number | undefined;
    cubicleId: number | undefined;
    groupId: number | undefined;
    materialId: number | undefined;
    grnDetailId: number | undefined;
    isCubicleAssigned: boolean;
    groupStatusId: number | undefined;
    groupStatus: string | undefined;
    isSampling: boolean | undefined;
    assignmentBy: string | undefined;
    id: number;

    constructor(data?: ICubicleAssignedReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleAssignmentDate = _data["cubicleAssignmentDate"] ? moment(_data["cubicleAssignmentDate"].toString()) : <any>undefined;
            this.plantCode = _data["plantCode"];
            this.cubicleCode = _data["cubicleCode"];
            this.groupCode = _data["groupCode"];
            this.productCode = _data["productCode"];
            this.batchNo = _data["batchNo"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.balQty = _data["balQty"];
            this.qty = _data["qty"];
            this.cubicleStatus = _data["cubicleStatus"];
            this.subPlantId = _data["subPlantId"];
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.materialId = _data["materialId"];
            this.grnDetailId = _data["grnDetailId"];
            this.isCubicleAssigned = _data["isCubicleAssigned"];
            this.groupStatusId = _data["groupStatusId"];
            this.groupStatus = _data["groupStatus"];
            this.isSampling = _data["isSampling"];
            this.assignmentBy = _data["assignmentBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubicleAssignedReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubicleAssignedReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleAssignmentDate"] = this.cubicleAssignmentDate ? this.cubicleAssignmentDate.toISOString() : <any>undefined;
        data["plantCode"] = this.plantCode;
        data["cubicleCode"] = this.cubicleCode;
        data["groupCode"] = this.groupCode;
        data["productCode"] = this.productCode;
        data["batchNo"] = this.batchNo;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["balQty"] = this.balQty;
        data["qty"] = this.qty;
        data["cubicleStatus"] = this.cubicleStatus;
        data["subPlantId"] = this.subPlantId;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["materialId"] = this.materialId;
        data["grnDetailId"] = this.grnDetailId;
        data["isCubicleAssigned"] = this.isCubicleAssigned;
        data["groupStatusId"] = this.groupStatusId;
        data["groupStatus"] = this.groupStatus;
        data["isSampling"] = this.isSampling;
        data["assignmentBy"] = this.assignmentBy;
        data["id"] = this.id;
        return data; 
    }

    clone(): CubicleAssignedReportResultDto {
        const json = this.toJSON();
        let result = new CubicleAssignedReportResultDto();
        result.init(json);
        return result;
    }
}

export interface ICubicleAssignedReportResultDto {
    cubicleAssignmentDate: moment.Moment;
    plantCode: string | undefined;
    cubicleCode: string | undefined;
    groupCode: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    balQty: number | undefined;
    qty: number | undefined;
    cubicleStatus: string | undefined;
    subPlantId: number | undefined;
    cubicleId: number | undefined;
    groupId: number | undefined;
    materialId: number | undefined;
    grnDetailId: number | undefined;
    isCubicleAssigned: boolean;
    groupStatusId: number | undefined;
    groupStatus: string | undefined;
    isSampling: boolean | undefined;
    assignmentBy: string | undefined;
    id: number;
}

export class PickingReportDto implements IPickingReportDto {
    subPlantId: number;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    pickingTime: moment.Moment;
    plantCode: string | undefined;
    cubicleCode: string | undefined;
    groupId: string | undefined;
    productCode: string | undefined;
    materialCode: string | undefined;
    containerBarcode: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    locationCode: string | undefined;
    quantity: number | undefined;
    pickedBy: string | undefined;
    isSampling: boolean | undefined;
    noOfContainers: number;
    inspectionLotNo: string | undefined;
    processOrderNo: string | undefined;
    id: number;

    constructor(data?: IPickingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.processOrderId = _data["processOrderId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.pickingTime = _data["pickingTime"] ? moment(_data["pickingTime"].toString()) : <any>undefined;
            this.plantCode = _data["plantCode"];
            this.cubicleCode = _data["cubicleCode"];
            this.groupId = _data["groupId"];
            this.productCode = _data["productCode"];
            this.materialCode = _data["materialCode"];
            this.containerBarcode = _data["containerBarcode"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.locationCode = _data["locationCode"];
            this.quantity = _data["quantity"];
            this.pickedBy = _data["pickedBy"];
            this.isSampling = _data["isSampling"];
            this.noOfContainers = _data["noOfContainers"];
            this.inspectionLotNo = _data["inspectionLotNo"];
            this.processOrderNo = _data["processOrderNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PickingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PickingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["processOrderId"] = this.processOrderId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["pickingTime"] = this.pickingTime ? this.pickingTime.toISOString() : <any>undefined;
        data["plantCode"] = this.plantCode;
        data["cubicleCode"] = this.cubicleCode;
        data["groupId"] = this.groupId;
        data["productCode"] = this.productCode;
        data["materialCode"] = this.materialCode;
        data["containerBarcode"] = this.containerBarcode;
        data["batchNo"] = this.batchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["locationCode"] = this.locationCode;
        data["quantity"] = this.quantity;
        data["pickedBy"] = this.pickedBy;
        data["isSampling"] = this.isSampling;
        data["noOfContainers"] = this.noOfContainers;
        data["inspectionLotNo"] = this.inspectionLotNo;
        data["processOrderNo"] = this.processOrderNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): PickingReportDto {
        const json = this.toJSON();
        let result = new PickingReportDto();
        result.init(json);
        return result;
    }
}

export interface IPickingReportDto {
    subPlantId: number;
    processOrderId: number | undefined;
    inspectionLotId: number | undefined;
    pickingTime: moment.Moment;
    plantCode: string | undefined;
    cubicleCode: string | undefined;
    groupId: string | undefined;
    productCode: string | undefined;
    materialCode: string | undefined;
    containerBarcode: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    locationCode: string | undefined;
    quantity: number | undefined;
    pickedBy: string | undefined;
    isSampling: boolean | undefined;
    noOfContainers: number;
    inspectionLotNo: string | undefined;
    processOrderNo: string | undefined;
    id: number;
}

export class LineClearanceReportRequestDto implements ILineClearanceReportRequestDto {
    subPlantId: number | undefined;
    materialListId: string[] | undefined;
    productBatchNos: string[] | undefined;
    productSAPBatchNos: string[] | undefined;
    productCodes: string[] | undefined;
    cubicleListIds: number[] | undefined;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    isSampling: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: ILineClearanceReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            if (Array.isArray(_data["materialListId"])) {
                this.materialListId = [] as any;
                for (let item of _data["materialListId"])
                    this.materialListId.push(item);
            }
            if (Array.isArray(_data["productBatchNos"])) {
                this.productBatchNos = [] as any;
                for (let item of _data["productBatchNos"])
                    this.productBatchNos.push(item);
            }
            if (Array.isArray(_data["productSAPBatchNos"])) {
                this.productSAPBatchNos = [] as any;
                for (let item of _data["productSAPBatchNos"])
                    this.productSAPBatchNos.push(item);
            }
            if (Array.isArray(_data["productCodes"])) {
                this.productCodes = [] as any;
                for (let item of _data["productCodes"])
                    this.productCodes.push(item);
            }
            if (Array.isArray(_data["cubicleListIds"])) {
                this.cubicleListIds = [] as any;
                for (let item of _data["cubicleListIds"])
                    this.cubicleListIds.push(item);
            }
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.isSampling = _data["isSampling"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): LineClearanceReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LineClearanceReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        if (Array.isArray(this.materialListId)) {
            data["materialListId"] = [];
            for (let item of this.materialListId)
                data["materialListId"].push(item);
        }
        if (Array.isArray(this.productBatchNos)) {
            data["productBatchNos"] = [];
            for (let item of this.productBatchNos)
                data["productBatchNos"].push(item);
        }
        if (Array.isArray(this.productSAPBatchNos)) {
            data["productSAPBatchNos"] = [];
            for (let item of this.productSAPBatchNos)
                data["productSAPBatchNos"].push(item);
        }
        if (Array.isArray(this.productCodes)) {
            data["productCodes"] = [];
            for (let item of this.productCodes)
                data["productCodes"].push(item);
        }
        if (Array.isArray(this.cubicleListIds)) {
            data["cubicleListIds"] = [];
            for (let item of this.cubicleListIds)
                data["cubicleListIds"].push(item);
        }
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isSampling"] = this.isSampling;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): LineClearanceReportRequestDto {
        const json = this.toJSON();
        let result = new LineClearanceReportRequestDto();
        result.init(json);
        return result;
    }
}

export interface ILineClearanceReportRequestDto {
    subPlantId: number | undefined;
    materialListId: string[] | undefined;
    productBatchNos: string[] | undefined;
    productSAPBatchNos: string[] | undefined;
    productCodes: string[] | undefined;
    cubicleListIds: number[] | undefined;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    isSampling: boolean | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class LineClearanceReportResultDto implements ILineClearanceReportResultDto {
    clearanceDate: moment.Moment;
    subPlantId: number | undefined;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    transactionStatusId: number | undefined;
    transactionStatus: string | undefined;
    materialCode: string | undefined;
    checklistName: string | undefined;
    materialId: number;
    checkPointId: number;
    cubicleCode: string | undefined;
    cubicleId: number;
    groupCode: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    isSampling: boolean | undefined;
    checkedBy: string | undefined;
    doneBy: string | undefined;
    verifiedBy: number | undefined;
    approvedBy: number | undefined;
    createdBy: number | undefined;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    lineClearanceCheckPointId: number;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;

    constructor(data?: ILineClearanceReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.subPlantId = _data["subPlantId"];
            this.checkpointName = _data["checkpointName"];
            this.checkpointType = _data["checkpointType"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            this.userdEnteredValue = _data["userdEnteredValue"];
            this.remark = _data["remark"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.transactionStatus = _data["transactionStatus"];
            this.materialCode = _data["materialCode"];
            this.checklistName = _data["checklistName"];
            this.materialId = _data["materialId"];
            this.checkPointId = _data["checkPointId"];
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.groupCode = _data["groupCode"];
            this.productCode = _data["productCode"];
            this.batchNo = _data["batchNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.isSampling = _data["isSampling"];
            this.checkedBy = _data["checkedBy"];
            this.doneBy = _data["doneBy"];
            this.verifiedBy = _data["verifiedBy"];
            this.approvedBy = _data["approvedBy"];
            this.createdBy = _data["createdBy"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.lineClearanceCheckPointId = _data["lineClearanceCheckPointId"];
            if (Array.isArray(_data["checkPoints"])) {
                this.checkPoints = [] as any;
                for (let item of _data["checkPoints"])
                    this.checkPoints.push(VehicleInspectionCheckPointReportResultDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LineClearanceReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LineClearanceReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["subPlantId"] = this.subPlantId;
        data["checkpointName"] = this.checkpointName;
        data["checkpointType"] = this.checkpointType;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        data["userdEnteredValue"] = this.userdEnteredValue;
        data["remark"] = this.remark;
        data["transactionStatusId"] = this.transactionStatusId;
        data["transactionStatus"] = this.transactionStatus;
        data["materialCode"] = this.materialCode;
        data["checklistName"] = this.checklistName;
        data["materialId"] = this.materialId;
        data["checkPointId"] = this.checkPointId;
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["groupCode"] = this.groupCode;
        data["productCode"] = this.productCode;
        data["batchNo"] = this.batchNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["isSampling"] = this.isSampling;
        data["checkedBy"] = this.checkedBy;
        data["doneBy"] = this.doneBy;
        data["verifiedBy"] = this.verifiedBy;
        data["approvedBy"] = this.approvedBy;
        data["createdBy"] = this.createdBy;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["lineClearanceCheckPointId"] = this.lineClearanceCheckPointId;
        if (Array.isArray(this.checkPoints)) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): LineClearanceReportResultDto {
        const json = this.toJSON();
        let result = new LineClearanceReportResultDto();
        result.init(json);
        return result;
    }
}

export interface ILineClearanceReportResultDto {
    clearanceDate: moment.Moment;
    subPlantId: number | undefined;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    transactionStatusId: number | undefined;
    transactionStatus: string | undefined;
    materialCode: string | undefined;
    checklistName: string | undefined;
    materialId: number;
    checkPointId: number;
    cubicleCode: string | undefined;
    cubicleId: number;
    groupCode: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    sapBatchNo: string | undefined;
    isSampling: boolean | undefined;
    checkedBy: string | undefined;
    doneBy: string | undefined;
    verifiedBy: number | undefined;
    approvedBy: number | undefined;
    createdBy: number | undefined;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    lineClearanceCheckPointId: number;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;
}

export class DispensingReportRequestDto implements IDispensingReportRequestDto {
    plantId: number | undefined;
    lstProcessOrderId: number[] | undefined;
    lstSAPBatchNo: string[] | undefined;
    lstWeighingMachineId: number[] | undefined;
    lstMaterialId: string[] | undefined;
    lstProductCode: string[] | undefined;
    lstProductBatch: string[] | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IDispensingReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            if (Array.isArray(_data["lstProcessOrderId"])) {
                this.lstProcessOrderId = [] as any;
                for (let item of _data["lstProcessOrderId"])
                    this.lstProcessOrderId.push(item);
            }
            if (Array.isArray(_data["lstSAPBatchNo"])) {
                this.lstSAPBatchNo = [] as any;
                for (let item of _data["lstSAPBatchNo"])
                    this.lstSAPBatchNo.push(item);
            }
            if (Array.isArray(_data["lstWeighingMachineId"])) {
                this.lstWeighingMachineId = [] as any;
                for (let item of _data["lstWeighingMachineId"])
                    this.lstWeighingMachineId.push(item);
            }
            if (Array.isArray(_data["lstMaterialId"])) {
                this.lstMaterialId = [] as any;
                for (let item of _data["lstMaterialId"])
                    this.lstMaterialId.push(item);
            }
            if (Array.isArray(_data["lstProductCode"])) {
                this.lstProductCode = [] as any;
                for (let item of _data["lstProductCode"])
                    this.lstProductCode.push(item);
            }
            if (Array.isArray(_data["lstProductBatch"])) {
                this.lstProductBatch = [] as any;
                for (let item of _data["lstProductBatch"])
                    this.lstProductBatch.push(item);
            }
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): DispensingReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        if (Array.isArray(this.lstProcessOrderId)) {
            data["lstProcessOrderId"] = [];
            for (let item of this.lstProcessOrderId)
                data["lstProcessOrderId"].push(item);
        }
        if (Array.isArray(this.lstSAPBatchNo)) {
            data["lstSAPBatchNo"] = [];
            for (let item of this.lstSAPBatchNo)
                data["lstSAPBatchNo"].push(item);
        }
        if (Array.isArray(this.lstWeighingMachineId)) {
            data["lstWeighingMachineId"] = [];
            for (let item of this.lstWeighingMachineId)
                data["lstWeighingMachineId"].push(item);
        }
        if (Array.isArray(this.lstMaterialId)) {
            data["lstMaterialId"] = [];
            for (let item of this.lstMaterialId)
                data["lstMaterialId"].push(item);
        }
        if (Array.isArray(this.lstProductCode)) {
            data["lstProductCode"] = [];
            for (let item of this.lstProductCode)
                data["lstProductCode"].push(item);
        }
        if (Array.isArray(this.lstProductBatch)) {
            data["lstProductBatch"] = [];
            for (let item of this.lstProductBatch)
                data["lstProductBatch"].push(item);
        }
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DispensingReportRequestDto {
        const json = this.toJSON();
        let result = new DispensingReportRequestDto();
        result.init(json);
        return result;
    }
}

export interface IDispensingReportRequestDto {
    plantId: number | undefined;
    lstProcessOrderId: number[] | undefined;
    lstSAPBatchNo: string[] | undefined;
    lstWeighingMachineId: number[] | undefined;
    lstMaterialId: string[] | undefined;
    lstProductCode: string[] | undefined;
    lstProductBatch: string[] | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DispensingReportDto implements IDispensingReportDto {
    userEnteredPlantId: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    itemCode: string | undefined;
    sapBatchNumber: string | undefined;
    isSampling: boolean;
    createdOn: moment.Moment | undefined;
    weighingMachineCode: string | undefined;
    userName: string | undefined;
    noOfPacks: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    plantId: number | undefined;
    processOrderId: number | undefined;
    weighingMachineId: number | undefined;
    productBatch: string | undefined;

    constructor(data?: IDispensingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.productCode = _data["productCode"];
            this.batchNo = _data["batchNo"];
            this.itemCode = _data["itemCode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.isSampling = _data["isSampling"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userName = _data["userName"];
            this.noOfPacks = _data["noOfPacks"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.grossWeight = _data["grossWeight"];
            this.plantId = _data["plantId"];
            this.processOrderId = _data["processOrderId"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.productBatch = _data["productBatch"];
        }
    }

    static fromJS(data: any): DispensingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["productCode"] = this.productCode;
        data["batchNo"] = this.batchNo;
        data["itemCode"] = this.itemCode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["isSampling"] = this.isSampling;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userName"] = this.userName;
        data["noOfPacks"] = this.noOfPacks;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["grossWeight"] = this.grossWeight;
        data["plantId"] = this.plantId;
        data["processOrderId"] = this.processOrderId;
        data["weighingMachineId"] = this.weighingMachineId;
        data["productBatch"] = this.productBatch;
        return data; 
    }

    clone(): DispensingReportDto {
        const json = this.toJSON();
        let result = new DispensingReportDto();
        result.init(json);
        return result;
    }
}

export interface IDispensingReportDto {
    userEnteredPlantId: string | undefined;
    productCode: string | undefined;
    batchNo: string | undefined;
    itemCode: string | undefined;
    sapBatchNumber: string | undefined;
    isSampling: boolean;
    createdOn: moment.Moment | undefined;
    weighingMachineCode: string | undefined;
    userName: string | undefined;
    noOfPacks: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    plantId: number | undefined;
    processOrderId: number | undefined;
    weighingMachineId: number | undefined;
    productBatch: string | undefined;
}

export class DispatchReportRequestDto implements IDispatchReportRequestDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IDispatchReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.putawayId = _data["putawayId"];
            this.pickingId = _data["pickingId"];
            this.productBatchNo = _data["productBatchNo"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.customerName = _data["customerName"];
            this.customerAddress = _data["customerAddress"];
            this.transportName = _data["transportName"];
            this.vehicleNo = _data["vehicleNo"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): DispatchReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["putawayId"] = this.putawayId;
        data["pickingId"] = this.pickingId;
        data["productBatchNo"] = this.productBatchNo;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["customerName"] = this.customerName;
        data["customerAddress"] = this.customerAddress;
        data["transportName"] = this.transportName;
        data["vehicleNo"] = this.vehicleNo;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): DispatchReportRequestDto {
        const json = this.toJSON();
        let result = new DispatchReportRequestDto();
        result.init(json);
        return result;
    }
}

export interface IDispatchReportRequestDto {
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DispatchReportDto implements IDispatchReportDto {
    createdOn: moment.Moment | undefined;
    createdBy: number | undefined;
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;

    constructor(data?: IDispatchReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.obd = _data["obd"];
            this.productId = _data["productId"];
            this.putawayId = _data["putawayId"];
            this.pickingId = _data["pickingId"];
            this.productBatchNo = _data["productBatchNo"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.lineItem = _data["lineItem"];
            this.batch = _data["batch"];
            this.description = _data["description"];
            this.palletBarcode = _data["palletBarcode"];
            this.palletCount = _data["palletCount"];
            this.quantity = _data["quantity"];
            this.uom = _data["uom"];
            this.noOfPacks = _data["noOfPacks"];
            this.customerName = _data["customerName"];
            this.customerAddress = _data["customerAddress"];
            this.transportName = _data["transportName"];
            this.vehicleNo = _data["vehicleNo"];
            this.isActive = _data["isActive"];
            this.isPicked = _data["isPicked"];
            this.huCode = _data["huCode"];
            this.plantId = _data["plantId"];
        }
    }

    static fromJS(data: any): DispatchReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["obd"] = this.obd;
        data["productId"] = this.productId;
        data["putawayId"] = this.putawayId;
        data["pickingId"] = this.pickingId;
        data["productBatchNo"] = this.productBatchNo;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["lineItem"] = this.lineItem;
        data["batch"] = this.batch;
        data["description"] = this.description;
        data["palletBarcode"] = this.palletBarcode;
        data["palletCount"] = this.palletCount;
        data["quantity"] = this.quantity;
        data["uom"] = this.uom;
        data["noOfPacks"] = this.noOfPacks;
        data["customerName"] = this.customerName;
        data["customerAddress"] = this.customerAddress;
        data["transportName"] = this.transportName;
        data["vehicleNo"] = this.vehicleNo;
        data["isActive"] = this.isActive;
        data["isPicked"] = this.isPicked;
        data["huCode"] = this.huCode;
        data["plantId"] = this.plantId;
        return data; 
    }

    clone(): DispatchReportDto {
        const json = this.toJSON();
        let result = new DispatchReportDto();
        result.init(json);
        return result;
    }
}

export interface IDispatchReportDto {
    createdOn: moment.Moment | undefined;
    createdBy: number | undefined;
    obd: string | undefined;
    productId: number | undefined;
    putawayId: number | undefined;
    pickingId: number | undefined;
    productBatchNo: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    lineItem: string | undefined;
    batch: string | undefined;
    description: string | undefined;
    palletBarcode: string | undefined;
    palletCount: number | undefined;
    quantity: number | undefined;
    uom: string | undefined;
    noOfPacks: number | undefined;
    customerName: string | undefined;
    customerAddress: string | undefined;
    transportName: string | undefined;
    vehicleNo: string | undefined;
    isActive: boolean | undefined;
    isPicked: boolean | undefined;
    huCode: string | undefined;
    plantId: number | undefined;
}

export class CleaningLogReportResultDto implements ICleaningLogReportResultDto {
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    cleanerName: string | undefined;
    verifiedName: string | undefined;
    cleaningType: string | undefined;
    cleaningTypeId: number;
    cubicleId: number;
    cubicleCode: string | undefined;
    equipmentId: number;
    equipmentCode: string | undefined;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    isSampling: boolean;
    subPlantId: number | undefined;
    transactionStatus: string | undefined;
    verifiedBy: number | undefined;
    cleanerBy: number | undefined;
    cleaningDate: moment.Moment;
    isPortable: boolean;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;

    constructor(data?: ICleaningLogReportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.cleanerName = _data["cleanerName"];
            this.verifiedName = _data["verifiedName"];
            this.cleaningType = _data["cleaningType"];
            this.cleaningTypeId = _data["cleaningTypeId"];
            this.cubicleId = _data["cubicleId"];
            this.cubicleCode = _data["cubicleCode"];
            this.equipmentId = _data["equipmentId"];
            this.equipmentCode = _data["equipmentCode"];
            this.checkpointName = _data["checkpointName"];
            this.checkpointType = _data["checkpointType"];
            this.valueTag = _data["valueTag"];
            this.acceptanceValue = _data["acceptanceValue"];
            this.userdEnteredValue = _data["userdEnteredValue"];
            this.remark = _data["remark"];
            this.isSampling = _data["isSampling"];
            this.subPlantId = _data["subPlantId"];
            this.transactionStatus = _data["transactionStatus"];
            this.verifiedBy = _data["verifiedBy"];
            this.cleanerBy = _data["cleanerBy"];
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>undefined;
            this.isPortable = _data["isPortable"];
            if (Array.isArray(_data["checkPoints"])) {
                this.checkPoints = [] as any;
                for (let item of _data["checkPoints"])
                    this.checkPoints.push(VehicleInspectionCheckPointReportResultDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CleaningLogReportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningLogReportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["cleanerName"] = this.cleanerName;
        data["verifiedName"] = this.verifiedName;
        data["cleaningType"] = this.cleaningType;
        data["cleaningTypeId"] = this.cleaningTypeId;
        data["cubicleId"] = this.cubicleId;
        data["cubicleCode"] = this.cubicleCode;
        data["equipmentId"] = this.equipmentId;
        data["equipmentCode"] = this.equipmentCode;
        data["checkpointName"] = this.checkpointName;
        data["checkpointType"] = this.checkpointType;
        data["valueTag"] = this.valueTag;
        data["acceptanceValue"] = this.acceptanceValue;
        data["userdEnteredValue"] = this.userdEnteredValue;
        data["remark"] = this.remark;
        data["isSampling"] = this.isSampling;
        data["subPlantId"] = this.subPlantId;
        data["transactionStatus"] = this.transactionStatus;
        data["verifiedBy"] = this.verifiedBy;
        data["cleanerBy"] = this.cleanerBy;
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>undefined;
        data["isPortable"] = this.isPortable;
        if (Array.isArray(this.checkPoints)) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CleaningLogReportResultDto {
        const json = this.toJSON();
        let result = new CleaningLogReportResultDto();
        result.init(json);
        return result;
    }
}

export interface ICleaningLogReportResultDto {
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    cleanerName: string | undefined;
    verifiedName: string | undefined;
    cleaningType: string | undefined;
    cleaningTypeId: number;
    cubicleId: number;
    cubicleCode: string | undefined;
    equipmentId: number;
    equipmentCode: string | undefined;
    checkpointName: string | undefined;
    checkpointType: string | undefined;
    valueTag: string | undefined;
    acceptanceValue: string | undefined;
    userdEnteredValue: string | undefined;
    remark: string | undefined;
    isSampling: boolean;
    subPlantId: number | undefined;
    transactionStatus: string | undefined;
    verifiedBy: number | undefined;
    cleanerBy: number | undefined;
    cleaningDate: moment.Moment;
    isPortable: boolean;
    checkPoints: VehicleInspectionCheckPointReportResultDto[] | undefined;
    id: number;
}

export class ReportConfigurationDto implements IReportConfigurationDto {
    userId: number | undefined;
    subModuleId: number;
    reportSettings: string | undefined;
    subModuleName: string | undefined;
    id: number;

    constructor(data?: IReportConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.subModuleId = _data["subModuleId"];
            this.reportSettings = _data["reportSettings"];
            this.subModuleName = _data["subModuleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReportConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["subModuleId"] = this.subModuleId;
        data["reportSettings"] = this.reportSettings;
        data["subModuleName"] = this.subModuleName;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReportConfigurationDto {
        const json = this.toJSON();
        let result = new ReportConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IReportConfigurationDto {
    userId: number | undefined;
    subModuleId: number;
    reportSettings: string | undefined;
    subModuleName: string | undefined;
    id: number;
}

export class DispensingTrackingReportRequestDto implements IDispensingTrackingReportRequestDto {
    plantId: number | undefined;
    lstProcessOrderId: number[] | undefined;
    lstSAPBatchNo: string[] | undefined;
    lstWeighingMachineId: number[] | undefined;
    isSampling: boolean;
    lstMaterialId: string[] | undefined;
    lstProductCode: string[] | undefined;
    lstProductBatch: string[] | undefined;

    constructor(data?: IDispensingTrackingReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            if (Array.isArray(_data["lstProcessOrderId"])) {
                this.lstProcessOrderId = [] as any;
                for (let item of _data["lstProcessOrderId"])
                    this.lstProcessOrderId.push(item);
            }
            if (Array.isArray(_data["lstSAPBatchNo"])) {
                this.lstSAPBatchNo = [] as any;
                for (let item of _data["lstSAPBatchNo"])
                    this.lstSAPBatchNo.push(item);
            }
            if (Array.isArray(_data["lstWeighingMachineId"])) {
                this.lstWeighingMachineId = [] as any;
                for (let item of _data["lstWeighingMachineId"])
                    this.lstWeighingMachineId.push(item);
            }
            this.isSampling = _data["isSampling"];
            if (Array.isArray(_data["lstMaterialId"])) {
                this.lstMaterialId = [] as any;
                for (let item of _data["lstMaterialId"])
                    this.lstMaterialId.push(item);
            }
            if (Array.isArray(_data["lstProductCode"])) {
                this.lstProductCode = [] as any;
                for (let item of _data["lstProductCode"])
                    this.lstProductCode.push(item);
            }
            if (Array.isArray(_data["lstProductBatch"])) {
                this.lstProductBatch = [] as any;
                for (let item of _data["lstProductBatch"])
                    this.lstProductBatch.push(item);
            }
        }
    }

    static fromJS(data: any): DispensingTrackingReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingTrackingReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        if (Array.isArray(this.lstProcessOrderId)) {
            data["lstProcessOrderId"] = [];
            for (let item of this.lstProcessOrderId)
                data["lstProcessOrderId"].push(item);
        }
        if (Array.isArray(this.lstSAPBatchNo)) {
            data["lstSAPBatchNo"] = [];
            for (let item of this.lstSAPBatchNo)
                data["lstSAPBatchNo"].push(item);
        }
        if (Array.isArray(this.lstWeighingMachineId)) {
            data["lstWeighingMachineId"] = [];
            for (let item of this.lstWeighingMachineId)
                data["lstWeighingMachineId"].push(item);
        }
        data["isSampling"] = this.isSampling;
        if (Array.isArray(this.lstMaterialId)) {
            data["lstMaterialId"] = [];
            for (let item of this.lstMaterialId)
                data["lstMaterialId"].push(item);
        }
        if (Array.isArray(this.lstProductCode)) {
            data["lstProductCode"] = [];
            for (let item of this.lstProductCode)
                data["lstProductCode"].push(item);
        }
        if (Array.isArray(this.lstProductBatch)) {
            data["lstProductBatch"] = [];
            for (let item of this.lstProductBatch)
                data["lstProductBatch"].push(item);
        }
        return data; 
    }

    clone(): DispensingTrackingReportRequestDto {
        const json = this.toJSON();
        let result = new DispensingTrackingReportRequestDto();
        result.init(json);
        return result;
    }
}

export interface IDispensingTrackingReportRequestDto {
    plantId: number | undefined;
    lstProcessOrderId: number[] | undefined;
    lstSAPBatchNo: string[] | undefined;
    lstWeighingMachineId: number[] | undefined;
    isSampling: boolean;
    lstMaterialId: string[] | undefined;
    lstProductCode: string[] | undefined;
    lstProductBatch: string[] | undefined;
}

export class DispensingTrackingActivity implements IDispensingTrackingActivity {
    activityName: string | undefined;
    doneBy: string | undefined;
    actvityDate: moment.Moment | undefined;
    activityCheckBy: string | undefined;

    constructor(data?: IDispensingTrackingActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.doneBy = _data["doneBy"];
            this.actvityDate = _data["actvityDate"] ? moment(_data["actvityDate"].toString()) : <any>undefined;
            this.activityCheckBy = _data["activityCheckBy"];
        }
    }

    static fromJS(data: any): DispensingTrackingActivity {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingTrackingActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["doneBy"] = this.doneBy;
        data["actvityDate"] = this.actvityDate ? this.actvityDate.toISOString() : <any>undefined;
        data["activityCheckBy"] = this.activityCheckBy;
        return data; 
    }

    clone(): DispensingTrackingActivity {
        const json = this.toJSON();
        let result = new DispensingTrackingActivity();
        result.init(json);
        return result;
    }
}

export interface IDispensingTrackingActivity {
    activityName: string | undefined;
    doneBy: string | undefined;
    actvityDate: moment.Moment | undefined;
    activityCheckBy: string | undefined;
}

export class DispensingTrackingReportDto implements IDispensingTrackingReportDto {
    groupId: string | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    lstActivity: DispensingTrackingActivity[] | undefined;

    constructor(data?: IDispensingTrackingReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.processOrderNo = _data["processOrderNo"];
            this.batchNo = _data["batchNo"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            if (Array.isArray(_data["lstActivity"])) {
                this.lstActivity = [] as any;
                for (let item of _data["lstActivity"])
                    this.lstActivity.push(DispensingTrackingActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DispensingTrackingReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispensingTrackingReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["processOrderNo"] = this.processOrderNo;
        data["batchNo"] = this.batchNo;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        if (Array.isArray(this.lstActivity)) {
            data["lstActivity"] = [];
            for (let item of this.lstActivity)
                data["lstActivity"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DispensingTrackingReportDto {
        const json = this.toJSON();
        let result = new DispensingTrackingReportDto();
        result.init(json);
        return result;
    }
}

export interface IDispensingTrackingReportDto {
    groupId: string | undefined;
    processOrderNo: string | undefined;
    batchNo: string | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    lstActivity: DispensingTrackingActivity[] | undefined;
}

export class CalibrationFrequencyDto implements ICalibrationFrequencyDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    id: number;

    constructor(data?: ICalibrationFrequencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.calibrationLevel = _data["calibrationLevel"];
            this.calibrationCriteria = _data["calibrationCriteria"];
            this.standardWeightValue = _data["standardWeightValue"];
            this.minimumValue = _data["minimumValue"];
            this.maximumValue = _data["maximumValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CalibrationFrequencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalibrationFrequencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["calibrationLevel"] = this.calibrationLevel;
        data["calibrationCriteria"] = this.calibrationCriteria;
        data["standardWeightValue"] = this.standardWeightValue;
        data["minimumValue"] = this.minimumValue;
        data["maximumValue"] = this.maximumValue;
        data["id"] = this.id;
        return data; 
    }

    clone(): CalibrationFrequencyDto {
        const json = this.toJSON();
        let result = new CalibrationFrequencyDto();
        result.init(json);
        return result;
    }
}

export interface ICalibrationFrequencyDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    calibrationLevel: string | undefined;
    calibrationCriteria: string | undefined;
    standardWeightValue: number | undefined;
    minimumValue: number | undefined;
    maximumValue: number | undefined;
    id: number;
}

export class WeighingCalibrationDetailDto implements IWeighingCalibrationDetailDto {
    wmCalibrationHeaderId: number | undefined;
    standardWeight: string | undefined;
    weightRange: string | undefined;
    calibrationLevelId: number | undefined;
    standardWeightBoxId: number | undefined;
    capturedWeight: number;
    capturedWeightString: string | undefined;
    remark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    initialZeroReading: string | undefined;
    spriritLevelBubble: string | undefined;
    calibrationStatusId: number | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredCalibrationLevel: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightId: string | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.standardWeight = _data["standardWeight"];
            this.weightRange = _data["weightRange"];
            this.calibrationLevelId = _data["calibrationLevelId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.capturedWeight = _data["capturedWeight"];
            this.capturedWeightString = _data["capturedWeightString"];
            this.remark = _data["remark"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.calibrationStatusId = _data["calibrationStatusId"];
            this.weighingMachineId = _data["weighingMachineId"];
            if (Array.isArray(_data["lstWeightId"])) {
                this.lstWeightId = [] as any;
                for (let item of _data["lstWeightId"])
                    this.lstWeightId.push(item);
            }
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userEnteredCalibrationLevel = _data["userEnteredCalibrationLevel"];
            this.userEnteredWeightBox = _data["userEnteredWeightBox"];
            this.userEnteredWeightId = _data["userEnteredWeightId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["standardWeight"] = this.standardWeight;
        data["weightRange"] = this.weightRange;
        data["calibrationLevelId"] = this.calibrationLevelId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["capturedWeight"] = this.capturedWeight;
        data["capturedWeightString"] = this.capturedWeightString;
        data["remark"] = this.remark;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["initialZeroReading"] = this.initialZeroReading;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["calibrationStatusId"] = this.calibrationStatusId;
        data["weighingMachineId"] = this.weighingMachineId;
        if (Array.isArray(this.lstWeightId)) {
            data["lstWeightId"] = [];
            for (let item of this.lstWeightId)
                data["lstWeightId"].push(item);
        }
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userEnteredCalibrationLevel"] = this.userEnteredCalibrationLevel;
        data["userEnteredWeightBox"] = this.userEnteredWeightBox;
        data["userEnteredWeightId"] = this.userEnteredWeightId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationDetailDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationDetailDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationDetailDto {
    wmCalibrationHeaderId: number | undefined;
    standardWeight: string | undefined;
    weightRange: string | undefined;
    calibrationLevelId: number | undefined;
    standardWeightBoxId: number | undefined;
    capturedWeight: number;
    capturedWeightString: string | undefined;
    remark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    initialZeroReading: string | undefined;
    spriritLevelBubble: string | undefined;
    calibrationStatusId: number | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredCalibrationLevel: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightId: string | undefined;
    id: number;
}

export class WMCalibrationStandardWeightDto implements IWMCalibrationStandardWeightDto {
    standardWeightId: number;
    userEnteredStandardWeightId: string | undefined;

    constructor(data?: IWMCalibrationStandardWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.standardWeightId = _data["standardWeightId"];
            this.userEnteredStandardWeightId = _data["userEnteredStandardWeightId"];
        }
    }

    static fromJS(data: any): WMCalibrationStandardWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new WMCalibrationStandardWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["standardWeightId"] = this.standardWeightId;
        data["userEnteredStandardWeightId"] = this.userEnteredStandardWeightId;
        return data; 
    }

    clone(): WMCalibrationStandardWeightDto {
        const json = this.toJSON();
        let result = new WMCalibrationStandardWeightDto();
        result.init(json);
        return result;
    }
}

export interface IWMCalibrationStandardWeightDto {
    standardWeightId: number;
    userEnteredStandardWeightId: string | undefined;
}

export class WeighingCalibrationEccentricityTestDto implements IWeighingCalibrationEccentricityTestDto {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    standardWeightBoxId: number | undefined;
    cValue: number;
    lfValue: number;
    rfValue: number;
    lbValue: number;
    rbValue: number;
    meanValue: number;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    testResult: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredCValueStandardWeightBox: string | undefined;
    userEnteredLFValueStandardWeightBox: string | undefined;
    userEnteredRFValueStandardWeightBox: string | undefined;
    userEnteredLBValueStandardWeightBox: string | undefined;
    userEnteredRBValueStandardWeightBox: string | undefined;
    cValueStandardWeightBoxId: number | undefined;
    lfValueStandardWeightBoxId: number | undefined;
    rfValueStandardWeightBoxId: number | undefined;
    lbValueStandardWeightBoxId: number | undefined;
    rbValueStandardWeightBoxId: number | undefined;
    lstCValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstLFValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstRFValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstLBValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstRBValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationEccentricityTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.calculatedCapacityWeight = _data["calculatedCapacityWeight"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertainityInstruction = _data["uncertainityInstruction"];
            this.userEnteredUnitOfMeasurement = _data["userEnteredUnitOfMeasurement"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.cValue = _data["cValue"];
            this.lfValue = _data["lfValue"];
            this.rfValue = _data["rfValue"];
            this.lbValue = _data["lbValue"];
            this.rbValue = _data["rbValue"];
            this.meanValue = _data["meanValue"];
            this.meanWeightRange = _data["meanWeightRange"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            this.testResult = _data["testResult"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weighingMachineId = _data["weighingMachineId"];
            if (Array.isArray(_data["lstWeightId"])) {
                this.lstWeightId = [] as any;
                for (let item of _data["lstWeightId"])
                    this.lstWeightId.push(item);
            }
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userEnteredWeightBox = _data["userEnteredWeightBox"];
            this.userEnteredCValueStandardWeightBox = _data["userEnteredCValueStandardWeightBox"];
            this.userEnteredLFValueStandardWeightBox = _data["userEnteredLFValueStandardWeightBox"];
            this.userEnteredRFValueStandardWeightBox = _data["userEnteredRFValueStandardWeightBox"];
            this.userEnteredLBValueStandardWeightBox = _data["userEnteredLBValueStandardWeightBox"];
            this.userEnteredRBValueStandardWeightBox = _data["userEnteredRBValueStandardWeightBox"];
            this.cValueStandardWeightBoxId = _data["cValueStandardWeightBoxId"];
            this.lfValueStandardWeightBoxId = _data["lfValueStandardWeightBoxId"];
            this.rfValueStandardWeightBoxId = _data["rfValueStandardWeightBoxId"];
            this.lbValueStandardWeightBoxId = _data["lbValueStandardWeightBoxId"];
            this.rbValueStandardWeightBoxId = _data["rbValueStandardWeightBoxId"];
            if (Array.isArray(_data["lstCValueStandardWeight"])) {
                this.lstCValueStandardWeight = [] as any;
                for (let item of _data["lstCValueStandardWeight"])
                    this.lstCValueStandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstLFValueStandardWeight"])) {
                this.lstLFValueStandardWeight = [] as any;
                for (let item of _data["lstLFValueStandardWeight"])
                    this.lstLFValueStandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstRFValueStandardWeight"])) {
                this.lstRFValueStandardWeight = [] as any;
                for (let item of _data["lstRFValueStandardWeight"])
                    this.lstRFValueStandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstLBValueStandardWeight"])) {
                this.lstLBValueStandardWeight = [] as any;
                for (let item of _data["lstLBValueStandardWeight"])
                    this.lstLBValueStandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstRBValueStandardWeight"])) {
                this.lstRBValueStandardWeight = [] as any;
                for (let item of _data["lstRBValueStandardWeight"])
                    this.lstRBValueStandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationEccentricityTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationEccentricityTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["calculatedCapacityWeight"] = this.calculatedCapacityWeight;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertainityInstruction"] = this.uncertainityInstruction;
        data["userEnteredUnitOfMeasurement"] = this.userEnteredUnitOfMeasurement;
        data["initialZeroReading"] = this.initialZeroReading;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["cValue"] = this.cValue;
        data["lfValue"] = this.lfValue;
        data["rfValue"] = this.rfValue;
        data["lbValue"] = this.lbValue;
        data["rbValue"] = this.rbValue;
        data["meanValue"] = this.meanValue;
        data["meanWeightRange"] = this.meanWeightRange;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        data["testResult"] = this.testResult;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weighingMachineId"] = this.weighingMachineId;
        if (Array.isArray(this.lstWeightId)) {
            data["lstWeightId"] = [];
            for (let item of this.lstWeightId)
                data["lstWeightId"].push(item);
        }
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userEnteredWeightBox"] = this.userEnteredWeightBox;
        data["userEnteredCValueStandardWeightBox"] = this.userEnteredCValueStandardWeightBox;
        data["userEnteredLFValueStandardWeightBox"] = this.userEnteredLFValueStandardWeightBox;
        data["userEnteredRFValueStandardWeightBox"] = this.userEnteredRFValueStandardWeightBox;
        data["userEnteredLBValueStandardWeightBox"] = this.userEnteredLBValueStandardWeightBox;
        data["userEnteredRBValueStandardWeightBox"] = this.userEnteredRBValueStandardWeightBox;
        data["cValueStandardWeightBoxId"] = this.cValueStandardWeightBoxId;
        data["lfValueStandardWeightBoxId"] = this.lfValueStandardWeightBoxId;
        data["rfValueStandardWeightBoxId"] = this.rfValueStandardWeightBoxId;
        data["lbValueStandardWeightBoxId"] = this.lbValueStandardWeightBoxId;
        data["rbValueStandardWeightBoxId"] = this.rbValueStandardWeightBoxId;
        if (Array.isArray(this.lstCValueStandardWeight)) {
            data["lstCValueStandardWeight"] = [];
            for (let item of this.lstCValueStandardWeight)
                data["lstCValueStandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstLFValueStandardWeight)) {
            data["lstLFValueStandardWeight"] = [];
            for (let item of this.lstLFValueStandardWeight)
                data["lstLFValueStandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstRFValueStandardWeight)) {
            data["lstRFValueStandardWeight"] = [];
            for (let item of this.lstRFValueStandardWeight)
                data["lstRFValueStandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstLBValueStandardWeight)) {
            data["lstLBValueStandardWeight"] = [];
            for (let item of this.lstLBValueStandardWeight)
                data["lstLBValueStandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstRBValueStandardWeight)) {
            data["lstRBValueStandardWeight"] = [];
            for (let item of this.lstRBValueStandardWeight)
                data["lstRBValueStandardWeight"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationEccentricityTestDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationEccentricityTestDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationEccentricityTestDto {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    standardWeightBoxId: number | undefined;
    cValue: number;
    lfValue: number;
    rfValue: number;
    lbValue: number;
    rbValue: number;
    meanValue: number;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    testResult: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredCValueStandardWeightBox: string | undefined;
    userEnteredLFValueStandardWeightBox: string | undefined;
    userEnteredRFValueStandardWeightBox: string | undefined;
    userEnteredLBValueStandardWeightBox: string | undefined;
    userEnteredRBValueStandardWeightBox: string | undefined;
    cValueStandardWeightBoxId: number | undefined;
    lfValueStandardWeightBoxId: number | undefined;
    rfValueStandardWeightBoxId: number | undefined;
    lbValueStandardWeightBoxId: number | undefined;
    rbValueStandardWeightBoxId: number | undefined;
    lstCValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstLFValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstRFValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstLBValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstRBValueStandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    id: number;
}

export class WeighingCalibrationLinearityTestDto implements IWeighingCalibrationLinearityTestDto {
    wmCalibrationHeaderId: number | undefined;
    standardWeightBoxId: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    meanValue: number;
    initialZeroReading: string | undefined;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightValue1StandardWeightBox: string | undefined;
    userEnteredWeightValue2StandardWeightBox: string | undefined;
    userEnteredWeightValue3StandardWeightBox: string | undefined;
    userEnteredWeightValue4StandardWeightBox: string | undefined;
    userEnteredWeightValue5StandardWeightBox: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    lstWeightValue1StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue2StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue3StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue4StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue5StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationLinearityTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertainityInstruction = _data["uncertainityInstruction"];
            this.weightValue1 = _data["weightValue1"];
            this.weightValue2 = _data["weightValue2"];
            this.weightValue3 = _data["weightValue3"];
            this.weightValue4 = _data["weightValue4"];
            this.weightValue5 = _data["weightValue5"];
            this.meanValue = _data["meanValue"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.meanWeightRange = _data["meanWeightRange"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            this.weighingMachineId = _data["weighingMachineId"];
            if (Array.isArray(_data["lstWeightId"])) {
                this.lstWeightId = [] as any;
                for (let item of _data["lstWeightId"])
                    this.lstWeightId.push(item);
            }
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userEnteredWeightBox = _data["userEnteredWeightBox"];
            this.userEnteredWeightValue1StandardWeightBox = _data["userEnteredWeightValue1StandardWeightBox"];
            this.userEnteredWeightValue2StandardWeightBox = _data["userEnteredWeightValue2StandardWeightBox"];
            this.userEnteredWeightValue3StandardWeightBox = _data["userEnteredWeightValue3StandardWeightBox"];
            this.userEnteredWeightValue4StandardWeightBox = _data["userEnteredWeightValue4StandardWeightBox"];
            this.userEnteredWeightValue5StandardWeightBox = _data["userEnteredWeightValue5StandardWeightBox"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weightValue1StandardWeightBoxId = _data["weightValue1StandardWeightBoxId"];
            this.weightValue2StandardWeightBoxId = _data["weightValue2StandardWeightBoxId"];
            this.weightValue3StandardWeightBoxId = _data["weightValue3StandardWeightBoxId"];
            this.weightValue4StandardWeightBoxId = _data["weightValue4StandardWeightBoxId"];
            this.weightValue5StandardWeightBoxId = _data["weightValue5StandardWeightBoxId"];
            if (Array.isArray(_data["lstWeightValue1StandardWeight"])) {
                this.lstWeightValue1StandardWeight = [] as any;
                for (let item of _data["lstWeightValue1StandardWeight"])
                    this.lstWeightValue1StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue2StandardWeight"])) {
                this.lstWeightValue2StandardWeight = [] as any;
                for (let item of _data["lstWeightValue2StandardWeight"])
                    this.lstWeightValue2StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue3StandardWeight"])) {
                this.lstWeightValue3StandardWeight = [] as any;
                for (let item of _data["lstWeightValue3StandardWeight"])
                    this.lstWeightValue3StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue4StandardWeight"])) {
                this.lstWeightValue4StandardWeight = [] as any;
                for (let item of _data["lstWeightValue4StandardWeight"])
                    this.lstWeightValue4StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue5StandardWeight"])) {
                this.lstWeightValue5StandardWeight = [] as any;
                for (let item of _data["lstWeightValue5StandardWeight"])
                    this.lstWeightValue5StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationLinearityTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationLinearityTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertainityInstruction"] = this.uncertainityInstruction;
        data["weightValue1"] = this.weightValue1;
        data["weightValue2"] = this.weightValue2;
        data["weightValue3"] = this.weightValue3;
        data["weightValue4"] = this.weightValue4;
        data["weightValue5"] = this.weightValue5;
        data["meanValue"] = this.meanValue;
        data["initialZeroReading"] = this.initialZeroReading;
        data["meanWeightRange"] = this.meanWeightRange;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        data["weighingMachineId"] = this.weighingMachineId;
        if (Array.isArray(this.lstWeightId)) {
            data["lstWeightId"] = [];
            for (let item of this.lstWeightId)
                data["lstWeightId"].push(item);
        }
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userEnteredWeightBox"] = this.userEnteredWeightBox;
        data["userEnteredWeightValue1StandardWeightBox"] = this.userEnteredWeightValue1StandardWeightBox;
        data["userEnteredWeightValue2StandardWeightBox"] = this.userEnteredWeightValue2StandardWeightBox;
        data["userEnteredWeightValue3StandardWeightBox"] = this.userEnteredWeightValue3StandardWeightBox;
        data["userEnteredWeightValue4StandardWeightBox"] = this.userEnteredWeightValue4StandardWeightBox;
        data["userEnteredWeightValue5StandardWeightBox"] = this.userEnteredWeightValue5StandardWeightBox;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weightValue1StandardWeightBoxId"] = this.weightValue1StandardWeightBoxId;
        data["weightValue2StandardWeightBoxId"] = this.weightValue2StandardWeightBoxId;
        data["weightValue3StandardWeightBoxId"] = this.weightValue3StandardWeightBoxId;
        data["weightValue4StandardWeightBoxId"] = this.weightValue4StandardWeightBoxId;
        data["weightValue5StandardWeightBoxId"] = this.weightValue5StandardWeightBoxId;
        if (Array.isArray(this.lstWeightValue1StandardWeight)) {
            data["lstWeightValue1StandardWeight"] = [];
            for (let item of this.lstWeightValue1StandardWeight)
                data["lstWeightValue1StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue2StandardWeight)) {
            data["lstWeightValue2StandardWeight"] = [];
            for (let item of this.lstWeightValue2StandardWeight)
                data["lstWeightValue2StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue3StandardWeight)) {
            data["lstWeightValue3StandardWeight"] = [];
            for (let item of this.lstWeightValue3StandardWeight)
                data["lstWeightValue3StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue4StandardWeight)) {
            data["lstWeightValue4StandardWeight"] = [];
            for (let item of this.lstWeightValue4StandardWeight)
                data["lstWeightValue4StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue5StandardWeight)) {
            data["lstWeightValue5StandardWeight"] = [];
            for (let item of this.lstWeightValue5StandardWeight)
                data["lstWeightValue5StandardWeight"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationLinearityTestDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationLinearityTestDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationLinearityTestDto {
    wmCalibrationHeaderId: number | undefined;
    standardWeightBoxId: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    meanValue: number;
    initialZeroReading: string | undefined;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightValue1StandardWeightBox: string | undefined;
    userEnteredWeightValue2StandardWeightBox: string | undefined;
    userEnteredWeightValue3StandardWeightBox: string | undefined;
    userEnteredWeightValue4StandardWeightBox: string | undefined;
    userEnteredWeightValue5StandardWeightBox: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    lstWeightValue1StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue2StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue3StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue4StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue5StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    id: number;
}

export class WeighingCalibrationRepeatabilityTestDto implements IWeighingCalibrationRepeatabilityTestDto {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    standardWeightBoxId: number | undefined;
    initialZeroReading: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    weightValue6: number;
    weightValue7: number;
    weightValue8: number;
    weightValue9: number;
    weightValue10: number;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightValue1StandardWeightBox: string | undefined;
    userEnteredWeightValue2StandardWeightBox: string | undefined;
    userEnteredWeightValue3StandardWeightBox: string | undefined;
    userEnteredWeightValue4StandardWeightBox: string | undefined;
    userEnteredWeightValue5StandardWeightBox: string | undefined;
    userEnteredWeightValue6StandardWeightBox: string | undefined;
    userEnteredWeightValue7StandardWeightBox: string | undefined;
    userEnteredWeightValue8StandardWeightBox: string | undefined;
    userEnteredWeightValue9StandardWeightBox: string | undefined;
    userEnteredWeightValue10StandardWeightBox: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    weightValue6StandardWeightBoxId: number | undefined;
    weightValue7StandardWeightBoxId: number | undefined;
    weightValue8StandardWeightBoxId: number | undefined;
    weightValue9StandardWeightBoxId: number | undefined;
    weightValue10StandardWeightBoxId: number | undefined;
    lstWeightValue1StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue2StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue3StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue4StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue5StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue6StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue7StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue8StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue9StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue10StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    meanValue: number;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    testResult: string | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEneteredWeightBox: string | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    acceptableMeanValue: number | undefined;
    acceptableStandardDeviationValue: number | undefined;
    acceptablePRSDValue: number | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationRepeatabilityTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wmCalibrationHeaderId = _data["wmCalibrationHeaderId"];
            this.calculatedCapacityWeight = _data["calculatedCapacityWeight"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertainityInstruction = _data["uncertainityInstruction"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weightValue1 = _data["weightValue1"];
            this.weightValue2 = _data["weightValue2"];
            this.weightValue3 = _data["weightValue3"];
            this.weightValue4 = _data["weightValue4"];
            this.weightValue5 = _data["weightValue5"];
            this.weightValue6 = _data["weightValue6"];
            this.weightValue7 = _data["weightValue7"];
            this.weightValue8 = _data["weightValue8"];
            this.weightValue9 = _data["weightValue9"];
            this.weightValue10 = _data["weightValue10"];
            this.userEnteredWeightBox = _data["userEnteredWeightBox"];
            this.userEnteredWeightValue1StandardWeightBox = _data["userEnteredWeightValue1StandardWeightBox"];
            this.userEnteredWeightValue2StandardWeightBox = _data["userEnteredWeightValue2StandardWeightBox"];
            this.userEnteredWeightValue3StandardWeightBox = _data["userEnteredWeightValue3StandardWeightBox"];
            this.userEnteredWeightValue4StandardWeightBox = _data["userEnteredWeightValue4StandardWeightBox"];
            this.userEnteredWeightValue5StandardWeightBox = _data["userEnteredWeightValue5StandardWeightBox"];
            this.userEnteredWeightValue6StandardWeightBox = _data["userEnteredWeightValue6StandardWeightBox"];
            this.userEnteredWeightValue7StandardWeightBox = _data["userEnteredWeightValue7StandardWeightBox"];
            this.userEnteredWeightValue8StandardWeightBox = _data["userEnteredWeightValue8StandardWeightBox"];
            this.userEnteredWeightValue9StandardWeightBox = _data["userEnteredWeightValue9StandardWeightBox"];
            this.userEnteredWeightValue10StandardWeightBox = _data["userEnteredWeightValue10StandardWeightBox"];
            this.weightValue1StandardWeightBoxId = _data["weightValue1StandardWeightBoxId"];
            this.weightValue2StandardWeightBoxId = _data["weightValue2StandardWeightBoxId"];
            this.weightValue3StandardWeightBoxId = _data["weightValue3StandardWeightBoxId"];
            this.weightValue4StandardWeightBoxId = _data["weightValue4StandardWeightBoxId"];
            this.weightValue5StandardWeightBoxId = _data["weightValue5StandardWeightBoxId"];
            this.weightValue6StandardWeightBoxId = _data["weightValue6StandardWeightBoxId"];
            this.weightValue7StandardWeightBoxId = _data["weightValue7StandardWeightBoxId"];
            this.weightValue8StandardWeightBoxId = _data["weightValue8StandardWeightBoxId"];
            this.weightValue9StandardWeightBoxId = _data["weightValue9StandardWeightBoxId"];
            this.weightValue10StandardWeightBoxId = _data["weightValue10StandardWeightBoxId"];
            if (Array.isArray(_data["lstWeightValue1StandardWeight"])) {
                this.lstWeightValue1StandardWeight = [] as any;
                for (let item of _data["lstWeightValue1StandardWeight"])
                    this.lstWeightValue1StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue2StandardWeight"])) {
                this.lstWeightValue2StandardWeight = [] as any;
                for (let item of _data["lstWeightValue2StandardWeight"])
                    this.lstWeightValue2StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue3StandardWeight"])) {
                this.lstWeightValue3StandardWeight = [] as any;
                for (let item of _data["lstWeightValue3StandardWeight"])
                    this.lstWeightValue3StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue4StandardWeight"])) {
                this.lstWeightValue4StandardWeight = [] as any;
                for (let item of _data["lstWeightValue4StandardWeight"])
                    this.lstWeightValue4StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue5StandardWeight"])) {
                this.lstWeightValue5StandardWeight = [] as any;
                for (let item of _data["lstWeightValue5StandardWeight"])
                    this.lstWeightValue5StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue6StandardWeight"])) {
                this.lstWeightValue6StandardWeight = [] as any;
                for (let item of _data["lstWeightValue6StandardWeight"])
                    this.lstWeightValue6StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue7StandardWeight"])) {
                this.lstWeightValue7StandardWeight = [] as any;
                for (let item of _data["lstWeightValue7StandardWeight"])
                    this.lstWeightValue7StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue8StandardWeight"])) {
                this.lstWeightValue8StandardWeight = [] as any;
                for (let item of _data["lstWeightValue8StandardWeight"])
                    this.lstWeightValue8StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue9StandardWeight"])) {
                this.lstWeightValue9StandardWeight = [] as any;
                for (let item of _data["lstWeightValue9StandardWeight"])
                    this.lstWeightValue9StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeightValue10StandardWeight"])) {
                this.lstWeightValue10StandardWeight = [] as any;
                for (let item of _data["lstWeightValue10StandardWeight"])
                    this.lstWeightValue10StandardWeight.push(WMCalibrationStandardWeightDto.fromJS(item));
            }
            this.meanValue = _data["meanValue"];
            this.meanWeightRange = _data["meanWeightRange"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.prsdValue = _data["prsdValue"];
            this.testResultId = _data["testResultId"];
            this.testResult = _data["testResult"];
            this.weighingMachineId = _data["weighingMachineId"];
            if (Array.isArray(_data["lstWeightId"])) {
                this.lstWeightId = [] as any;
                for (let item of _data["lstWeightId"])
                    this.lstWeightId.push(item);
            }
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userEneteredWeightBox = _data["userEneteredWeightBox"];
            this.userEnteredUnitOfMeasurement = _data["userEnteredUnitOfMeasurement"];
            this.acceptableMeanValue = _data["acceptableMeanValue"];
            this.acceptableStandardDeviationValue = _data["acceptableStandardDeviationValue"];
            this.acceptablePRSDValue = _data["acceptablePRSDValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationRepeatabilityTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationRepeatabilityTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wmCalibrationHeaderId"] = this.wmCalibrationHeaderId;
        data["calculatedCapacityWeight"] = this.calculatedCapacityWeight;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertainityInstruction"] = this.uncertainityInstruction;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["initialZeroReading"] = this.initialZeroReading;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weightValue1"] = this.weightValue1;
        data["weightValue2"] = this.weightValue2;
        data["weightValue3"] = this.weightValue3;
        data["weightValue4"] = this.weightValue4;
        data["weightValue5"] = this.weightValue5;
        data["weightValue6"] = this.weightValue6;
        data["weightValue7"] = this.weightValue7;
        data["weightValue8"] = this.weightValue8;
        data["weightValue9"] = this.weightValue9;
        data["weightValue10"] = this.weightValue10;
        data["userEnteredWeightBox"] = this.userEnteredWeightBox;
        data["userEnteredWeightValue1StandardWeightBox"] = this.userEnteredWeightValue1StandardWeightBox;
        data["userEnteredWeightValue2StandardWeightBox"] = this.userEnteredWeightValue2StandardWeightBox;
        data["userEnteredWeightValue3StandardWeightBox"] = this.userEnteredWeightValue3StandardWeightBox;
        data["userEnteredWeightValue4StandardWeightBox"] = this.userEnteredWeightValue4StandardWeightBox;
        data["userEnteredWeightValue5StandardWeightBox"] = this.userEnteredWeightValue5StandardWeightBox;
        data["userEnteredWeightValue6StandardWeightBox"] = this.userEnteredWeightValue6StandardWeightBox;
        data["userEnteredWeightValue7StandardWeightBox"] = this.userEnteredWeightValue7StandardWeightBox;
        data["userEnteredWeightValue8StandardWeightBox"] = this.userEnteredWeightValue8StandardWeightBox;
        data["userEnteredWeightValue9StandardWeightBox"] = this.userEnteredWeightValue9StandardWeightBox;
        data["userEnteredWeightValue10StandardWeightBox"] = this.userEnteredWeightValue10StandardWeightBox;
        data["weightValue1StandardWeightBoxId"] = this.weightValue1StandardWeightBoxId;
        data["weightValue2StandardWeightBoxId"] = this.weightValue2StandardWeightBoxId;
        data["weightValue3StandardWeightBoxId"] = this.weightValue3StandardWeightBoxId;
        data["weightValue4StandardWeightBoxId"] = this.weightValue4StandardWeightBoxId;
        data["weightValue5StandardWeightBoxId"] = this.weightValue5StandardWeightBoxId;
        data["weightValue6StandardWeightBoxId"] = this.weightValue6StandardWeightBoxId;
        data["weightValue7StandardWeightBoxId"] = this.weightValue7StandardWeightBoxId;
        data["weightValue8StandardWeightBoxId"] = this.weightValue8StandardWeightBoxId;
        data["weightValue9StandardWeightBoxId"] = this.weightValue9StandardWeightBoxId;
        data["weightValue10StandardWeightBoxId"] = this.weightValue10StandardWeightBoxId;
        if (Array.isArray(this.lstWeightValue1StandardWeight)) {
            data["lstWeightValue1StandardWeight"] = [];
            for (let item of this.lstWeightValue1StandardWeight)
                data["lstWeightValue1StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue2StandardWeight)) {
            data["lstWeightValue2StandardWeight"] = [];
            for (let item of this.lstWeightValue2StandardWeight)
                data["lstWeightValue2StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue3StandardWeight)) {
            data["lstWeightValue3StandardWeight"] = [];
            for (let item of this.lstWeightValue3StandardWeight)
                data["lstWeightValue3StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue4StandardWeight)) {
            data["lstWeightValue4StandardWeight"] = [];
            for (let item of this.lstWeightValue4StandardWeight)
                data["lstWeightValue4StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue5StandardWeight)) {
            data["lstWeightValue5StandardWeight"] = [];
            for (let item of this.lstWeightValue5StandardWeight)
                data["lstWeightValue5StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue6StandardWeight)) {
            data["lstWeightValue6StandardWeight"] = [];
            for (let item of this.lstWeightValue6StandardWeight)
                data["lstWeightValue6StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue7StandardWeight)) {
            data["lstWeightValue7StandardWeight"] = [];
            for (let item of this.lstWeightValue7StandardWeight)
                data["lstWeightValue7StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue8StandardWeight)) {
            data["lstWeightValue8StandardWeight"] = [];
            for (let item of this.lstWeightValue8StandardWeight)
                data["lstWeightValue8StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue9StandardWeight)) {
            data["lstWeightValue9StandardWeight"] = [];
            for (let item of this.lstWeightValue9StandardWeight)
                data["lstWeightValue9StandardWeight"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeightValue10StandardWeight)) {
            data["lstWeightValue10StandardWeight"] = [];
            for (let item of this.lstWeightValue10StandardWeight)
                data["lstWeightValue10StandardWeight"].push(item.toJSON());
        }
        data["meanValue"] = this.meanValue;
        data["meanWeightRange"] = this.meanWeightRange;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["prsdValue"] = this.prsdValue;
        data["testResultId"] = this.testResultId;
        data["testResult"] = this.testResult;
        data["weighingMachineId"] = this.weighingMachineId;
        if (Array.isArray(this.lstWeightId)) {
            data["lstWeightId"] = [];
            for (let item of this.lstWeightId)
                data["lstWeightId"].push(item);
        }
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userEneteredWeightBox"] = this.userEneteredWeightBox;
        data["userEnteredUnitOfMeasurement"] = this.userEnteredUnitOfMeasurement;
        data["acceptableMeanValue"] = this.acceptableMeanValue;
        data["acceptableStandardDeviationValue"] = this.acceptableStandardDeviationValue;
        data["acceptablePRSDValue"] = this.acceptablePRSDValue;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationRepeatabilityTestDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationRepeatabilityTestDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationRepeatabilityTestDto {
    wmCalibrationHeaderId: number | undefined;
    calculatedCapacityWeight: number;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    standardWeightBoxId: number | undefined;
    initialZeroReading: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weightValue1: number;
    weightValue2: number;
    weightValue3: number;
    weightValue4: number;
    weightValue5: number;
    weightValue6: number;
    weightValue7: number;
    weightValue8: number;
    weightValue9: number;
    weightValue10: number;
    userEnteredWeightBox: string | undefined;
    userEnteredWeightValue1StandardWeightBox: string | undefined;
    userEnteredWeightValue2StandardWeightBox: string | undefined;
    userEnteredWeightValue3StandardWeightBox: string | undefined;
    userEnteredWeightValue4StandardWeightBox: string | undefined;
    userEnteredWeightValue5StandardWeightBox: string | undefined;
    userEnteredWeightValue6StandardWeightBox: string | undefined;
    userEnteredWeightValue7StandardWeightBox: string | undefined;
    userEnteredWeightValue8StandardWeightBox: string | undefined;
    userEnteredWeightValue9StandardWeightBox: string | undefined;
    userEnteredWeightValue10StandardWeightBox: string | undefined;
    weightValue1StandardWeightBoxId: number | undefined;
    weightValue2StandardWeightBoxId: number | undefined;
    weightValue3StandardWeightBoxId: number | undefined;
    weightValue4StandardWeightBoxId: number | undefined;
    weightValue5StandardWeightBoxId: number | undefined;
    weightValue6StandardWeightBoxId: number | undefined;
    weightValue7StandardWeightBoxId: number | undefined;
    weightValue8StandardWeightBoxId: number | undefined;
    weightValue9StandardWeightBoxId: number | undefined;
    weightValue10StandardWeightBoxId: number | undefined;
    lstWeightValue1StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue2StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue3StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue4StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue5StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue6StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue7StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue8StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue9StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    lstWeightValue10StandardWeight: WMCalibrationStandardWeightDto[] | undefined;
    meanValue: number;
    meanWeightRange: string | undefined;
    standardDeviationValue: number;
    prsdValue: number;
    testResultId: number | undefined;
    testResult: string | undefined;
    weighingMachineId: number | undefined;
    lstWeightId: number[] | undefined;
    weighingMachineCode: string | undefined;
    userEneteredWeightBox: string | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    acceptableMeanValue: number | undefined;
    acceptableStandardDeviationValue: number | undefined;
    acceptablePRSDValue: number | undefined;
    id: number;
}

export class WeighingMachineTestconfigurationDto implements IWeighingMachineTestconfigurationDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    id: number;

    constructor(data?: IWeighingMachineTestconfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.isEccentricityTestRequired = _data["isEccentricityTestRequired"];
            this.isLinearityTestRequired = _data["isLinearityTestRequired"];
            this.isRepeatabilityTestRequired = _data["isRepeatabilityTestRequired"];
            this.isUncertainityTestRequired = _data["isUncertainityTestRequired"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineTestconfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineTestconfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["isEccentricityTestRequired"] = this.isEccentricityTestRequired;
        data["isLinearityTestRequired"] = this.isLinearityTestRequired;
        data["isRepeatabilityTestRequired"] = this.isRepeatabilityTestRequired;
        data["isUncertainityTestRequired"] = this.isUncertainityTestRequired;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineTestconfigurationDto {
        const json = this.toJSON();
        let result = new WeighingMachineTestconfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineTestconfigurationDto {
    weighingMachineId: number | undefined;
    frequencyTypeId: number | undefined;
    isEccentricityTestRequired: boolean | undefined;
    isLinearityTestRequired: boolean | undefined;
    isRepeatabilityTestRequired: boolean | undefined;
    isUncertainityTestRequired: boolean | undefined;
    id: number;
}

export class WeighingCalibrationDto implements IWeighingCalibrationDto {
    weighingMachineCode: string | undefined;
    weighingMachineId: number | undefined;
    frequencyModeld: number;
    userEnteredFrequencyMode: string | undefined;
    make: string | undefined;
    model: string | undefined;
    capacity: number | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    unitOfMeasurement: number | undefined;
    eccentricityInstruction: string | undefined;
    leastCount: string | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    isReCalibrated: boolean | undefined;
    isAllCalibrationLevelFinished: boolean;
    isCheckpointFinished: boolean;
    reCalibrationRemark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weighingCalibrationSaveType: number;
    calibrationStatusId: number | undefined;
    uncertainityTestResultId: number | undefined;
    uncertainityTestResult: string | undefined;
    uncertainityValue: number;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    uncertainityTestId: number;
    acceptableUncertainityValue: number;
    calibrationStatus: string | undefined;
    calibrationTestDate: moment.Moment;
    calibrationFrequencySelectListDtos: SelectListDto[] | undefined;
    calibrationFrequencyDtos: CalibrationFrequencyDto[] | undefined;
    weighingCalibrationCheckpoints: CheckpointDto[] | undefined;
    lstWeighingCalibrationDetailDto: WeighingCalibrationDetailDto[] | undefined;
    weighingCalibrationDetailCurrentDto: WeighingCalibrationDetailDto;
    weighingCalibrationEccentricityTestDto: WeighingCalibrationEccentricityTestDto;
    weighingCalibrationLinearityTestDto: WeighingCalibrationLinearityTestDto;
    weighingCalibrationRepeatabilityTestDto: WeighingCalibrationRepeatabilityTestDto;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyModeld = _data["frequencyModeld"];
            this.userEnteredFrequencyMode = _data["userEnteredFrequencyMode"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.capacity = _data["capacity"];
            this.userEnteredUnitOfMeasurement = _data["userEnteredUnitOfMeasurement"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.leastCount = _data["leastCount"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.isReCalibrated = _data["isReCalibrated"];
            this.isAllCalibrationLevelFinished = _data["isAllCalibrationLevelFinished"];
            this.isCheckpointFinished = _data["isCheckpointFinished"];
            this.reCalibrationRemark = _data["reCalibrationRemark"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.weighingCalibrationSaveType = _data["weighingCalibrationSaveType"];
            this.calibrationStatusId = _data["calibrationStatusId"];
            this.uncertainityTestResultId = _data["uncertainityTestResultId"];
            this.uncertainityTestResult = _data["uncertainityTestResult"];
            this.uncertainityValue = _data["uncertainityValue"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertainityInstruction = _data["uncertainityInstruction"];
            this.uncertainityTestId = _data["uncertainityTestId"];
            this.acceptableUncertainityValue = _data["acceptableUncertainityValue"];
            this.calibrationStatus = _data["calibrationStatus"];
            this.calibrationTestDate = _data["calibrationTestDate"] ? moment(_data["calibrationTestDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["calibrationFrequencySelectListDtos"])) {
                this.calibrationFrequencySelectListDtos = [] as any;
                for (let item of _data["calibrationFrequencySelectListDtos"])
                    this.calibrationFrequencySelectListDtos.push(SelectListDto.fromJS(item));
            }
            if (Array.isArray(_data["calibrationFrequencyDtos"])) {
                this.calibrationFrequencyDtos = [] as any;
                for (let item of _data["calibrationFrequencyDtos"])
                    this.calibrationFrequencyDtos.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingCalibrationCheckpoints"])) {
                this.weighingCalibrationCheckpoints = [] as any;
                for (let item of _data["weighingCalibrationCheckpoints"])
                    this.weighingCalibrationCheckpoints.push(CheckpointDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeighingCalibrationDetailDto"])) {
                this.lstWeighingCalibrationDetailDto = [] as any;
                for (let item of _data["lstWeighingCalibrationDetailDto"])
                    this.lstWeighingCalibrationDetailDto.push(WeighingCalibrationDetailDto.fromJS(item));
            }
            this.weighingCalibrationDetailCurrentDto = _data["weighingCalibrationDetailCurrentDto"] ? WeighingCalibrationDetailDto.fromJS(_data["weighingCalibrationDetailCurrentDto"]) : <any>undefined;
            this.weighingCalibrationEccentricityTestDto = _data["weighingCalibrationEccentricityTestDto"] ? WeighingCalibrationEccentricityTestDto.fromJS(_data["weighingCalibrationEccentricityTestDto"]) : <any>undefined;
            this.weighingCalibrationLinearityTestDto = _data["weighingCalibrationLinearityTestDto"] ? WeighingCalibrationLinearityTestDto.fromJS(_data["weighingCalibrationLinearityTestDto"]) : <any>undefined;
            this.weighingCalibrationRepeatabilityTestDto = _data["weighingCalibrationRepeatabilityTestDto"] ? WeighingCalibrationRepeatabilityTestDto.fromJS(_data["weighingCalibrationRepeatabilityTestDto"]) : <any>undefined;
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestconfigurationDto.fromJS(item));
            }
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyModeld"] = this.frequencyModeld;
        data["userEnteredFrequencyMode"] = this.userEnteredFrequencyMode;
        data["make"] = this.make;
        data["model"] = this.model;
        data["capacity"] = this.capacity;
        data["userEnteredUnitOfMeasurement"] = this.userEnteredUnitOfMeasurement;
        data["initialZeroReading"] = this.initialZeroReading;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["leastCount"] = this.leastCount;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["isReCalibrated"] = this.isReCalibrated;
        data["isAllCalibrationLevelFinished"] = this.isAllCalibrationLevelFinished;
        data["isCheckpointFinished"] = this.isCheckpointFinished;
        data["reCalibrationRemark"] = this.reCalibrationRemark;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["weighingCalibrationSaveType"] = this.weighingCalibrationSaveType;
        data["calibrationStatusId"] = this.calibrationStatusId;
        data["uncertainityTestResultId"] = this.uncertainityTestResultId;
        data["uncertainityTestResult"] = this.uncertainityTestResult;
        data["uncertainityValue"] = this.uncertainityValue;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertainityInstruction"] = this.uncertainityInstruction;
        data["uncertainityTestId"] = this.uncertainityTestId;
        data["acceptableUncertainityValue"] = this.acceptableUncertainityValue;
        data["calibrationStatus"] = this.calibrationStatus;
        data["calibrationTestDate"] = this.calibrationTestDate ? this.calibrationTestDate.toISOString() : <any>undefined;
        if (Array.isArray(this.calibrationFrequencySelectListDtos)) {
            data["calibrationFrequencySelectListDtos"] = [];
            for (let item of this.calibrationFrequencySelectListDtos)
                data["calibrationFrequencySelectListDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.calibrationFrequencyDtos)) {
            data["calibrationFrequencyDtos"] = [];
            for (let item of this.calibrationFrequencyDtos)
                data["calibrationFrequencyDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingCalibrationCheckpoints)) {
            data["weighingCalibrationCheckpoints"] = [];
            for (let item of this.weighingCalibrationCheckpoints)
                data["weighingCalibrationCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeighingCalibrationDetailDto)) {
            data["lstWeighingCalibrationDetailDto"] = [];
            for (let item of this.lstWeighingCalibrationDetailDto)
                data["lstWeighingCalibrationDetailDto"].push(item.toJSON());
        }
        data["weighingCalibrationDetailCurrentDto"] = this.weighingCalibrationDetailCurrentDto ? this.weighingCalibrationDetailCurrentDto.toJSON() : <any>undefined;
        data["weighingCalibrationEccentricityTestDto"] = this.weighingCalibrationEccentricityTestDto ? this.weighingCalibrationEccentricityTestDto.toJSON() : <any>undefined;
        data["weighingCalibrationLinearityTestDto"] = this.weighingCalibrationLinearityTestDto ? this.weighingCalibrationLinearityTestDto.toJSON() : <any>undefined;
        data["weighingCalibrationRepeatabilityTestDto"] = this.weighingCalibrationRepeatabilityTestDto ? this.weighingCalibrationRepeatabilityTestDto.toJSON() : <any>undefined;
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationDto {
    weighingMachineCode: string | undefined;
    weighingMachineId: number | undefined;
    frequencyModeld: number;
    userEnteredFrequencyMode: string | undefined;
    make: string | undefined;
    model: string | undefined;
    capacity: number | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    unitOfMeasurement: number | undefined;
    eccentricityInstruction: string | undefined;
    leastCount: string | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    isReCalibrated: boolean | undefined;
    isAllCalibrationLevelFinished: boolean;
    isCheckpointFinished: boolean;
    reCalibrationRemark: string | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    weighingCalibrationSaveType: number;
    calibrationStatusId: number | undefined;
    uncertainityTestResultId: number | undefined;
    uncertainityTestResult: string | undefined;
    uncertainityValue: number;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertainityInstruction: string | undefined;
    uncertainityTestId: number;
    acceptableUncertainityValue: number;
    calibrationStatus: string | undefined;
    calibrationTestDate: moment.Moment;
    calibrationFrequencySelectListDtos: SelectListDto[] | undefined;
    calibrationFrequencyDtos: CalibrationFrequencyDto[] | undefined;
    weighingCalibrationCheckpoints: CheckpointDto[] | undefined;
    lstWeighingCalibrationDetailDto: WeighingCalibrationDetailDto[] | undefined;
    weighingCalibrationDetailCurrentDto: WeighingCalibrationDetailDto;
    weighingCalibrationEccentricityTestDto: WeighingCalibrationEccentricityTestDto;
    weighingCalibrationLinearityTestDto: WeighingCalibrationLinearityTestDto;
    weighingCalibrationRepeatabilityTestDto: WeighingCalibrationRepeatabilityTestDto;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    id: number;
}

export class ReturnToVendorDto implements IReturnToVendorDto {
    materialDocumentId: string | undefined;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    sapBatchNumber: string | undefined;
    arNo: string | undefined;
    statusId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    scanQty: number | undefined;
    uom: string | undefined;
    convertedQty: number | undefined;
    baseUom: string | undefined;
    id: number;

    constructor(data?: IReturnToVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocumentId = _data["materialDocumentId"];
            this.materialCode = _data["materialCode"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.sapBatchNumber = _data["sapBatchNumber"];
            this.arNo = _data["arNo"];
            this.statusId = _data["statusId"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.scanQty = _data["scanQty"];
            this.uom = _data["uom"];
            this.convertedQty = _data["convertedQty"];
            this.baseUom = _data["baseUom"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReturnToVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnToVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocumentId"] = this.materialDocumentId;
        data["materialCode"] = this.materialCode;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["sapBatchNumber"] = this.sapBatchNumber;
        data["arNo"] = this.arNo;
        data["statusId"] = this.statusId;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["scanQty"] = this.scanQty;
        data["uom"] = this.uom;
        data["convertedQty"] = this.convertedQty;
        data["baseUom"] = this.baseUom;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReturnToVendorDto {
        const json = this.toJSON();
        let result = new ReturnToVendorDto();
        result.init(json);
        return result;
    }
}

export interface IReturnToVendorDto {
    materialDocumentId: string | undefined;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    sapBatchNumber: string | undefined;
    arNo: string | undefined;
    statusId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    scanQty: number | undefined;
    uom: string | undefined;
    convertedQty: number | undefined;
    baseUom: string | undefined;
    id: number;
}

export class ActionDto implements IActionDto {
    id: number;
    action: string | undefined;
    isGranted: boolean;
    permissionName: string | undefined;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
            this.isGranted = _data["isGranted"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["isGranted"] = this.isGranted;
        data["permissionName"] = this.permissionName;
        return data; 
    }

    clone(): ActionDto {
        const json = this.toJSON();
        let result = new ActionDto();
        result.init(json);
        return result;
    }
}

export interface IActionDto {
    id: number;
    action: string | undefined;
    isGranted: boolean;
    permissionName: string | undefined;
}

export class RolePermissionsDto implements IRolePermissionsDto {
    moduleSubModuleId: number;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    isGranted: boolean;
    isSuperAdminPermission: boolean;
    grantedPermissions: ActionDto[];

    constructor(data?: IRolePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleSubModuleId = _data["moduleSubModuleId"];
            this.moduleName = _data["moduleName"];
            this.subModuleName = _data["subModuleName"];
            this.isGranted = _data["isGranted"];
            this.isSuperAdminPermission = _data["isSuperAdminPermission"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(ActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleSubModuleId"] = this.moduleSubModuleId;
        data["moduleName"] = this.moduleName;
        data["subModuleName"] = this.subModuleName;
        data["isGranted"] = this.isGranted;
        data["isSuperAdminPermission"] = this.isSuperAdminPermission;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionsDto {
        const json = this.toJSON();
        let result = new RolePermissionsDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionsDto {
    moduleSubModuleId: number;
    moduleName: string | undefined;
    subModuleName: string | undefined;
    isGranted: boolean;
    isSuperAdminPermission: boolean;
    grantedPermissions: ActionDto[];
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
    modulePermissions: RolePermissionsDto[];
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isSuperAdminRole: boolean;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
            this.isActive = true;
            this.modulePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            if (Array.isArray(_data["modulePermissions"])) {
                this.modulePermissions = [] as any;
                for (let item of _data["modulePermissions"])
                    this.modulePermissions.push(RolePermissionsDto.fromJS(item));
            }
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.isSuperAdminRole = _data["isSuperAdminRole"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.modulePermissions)) {
            data["modulePermissions"] = [];
            for (let item of this.modulePermissions)
                data["modulePermissions"].push(item.toJSON());
        }
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["isSuperAdminRole"] = this.isSuperAdminRole;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
    modulePermissions: RolePermissionsDto[];
    isApprovalRequired: boolean;
    approvalStatusDescription: string | undefined;
    userEnteredApprovalStatus: string | undefined;
    isSuperAdminRole: boolean;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class RoleListDtoPagedResultDto implements IRoleListDtoPagedResultDto {
    totalCount: number;
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoPagedResultDto {
    totalCount: number;
    items: RoleListDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    isDeleted: boolean;
    isActive: boolean;
    description: string | undefined;
    createdOn: moment.Moment;
    modulePermissions: RolePermissionsDto[];

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
            this.isActive = true;
            this.modulePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.description = _data["description"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["modulePermissions"])) {
                this.modulePermissions = [] as any;
                for (let item of _data["modulePermissions"])
                    this.modulePermissions.push(RolePermissionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.modulePermissions)) {
            data["modulePermissions"] = [];
            for (let item of this.modulePermissions)
                data["modulePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    isDeleted: boolean;
    isActive: boolean;
    description: string | undefined;
    createdOn: moment.Moment;
    modulePermissions: RolePermissionsDto[];
}

export class SampleDestructionDto implements ISampleDestructionDto {
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number | undefined;
    materialSampleHeaderHeaderId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    isPackUOM: boolean;
    noofPacks: number | undefined;
    materialContainerBalanceQuantity: number | undefined;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    id: number;

    constructor(data?: ISampleDestructionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inspectionLotId = _data["inspectionLotId"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.baseUnitOfMeasurementId = _data["baseUnitOfMeasurementId"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.materialContainerId = _data["materialContainerId"];
            this.materialSampleHeaderHeaderId = _data["materialSampleHeaderHeaderId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            if (Array.isArray(_data["suggestedBalanceIds"])) {
                this.suggestedBalanceIds = [] as any;
                for (let item of _data["suggestedBalanceIds"])
                    this.suggestedBalanceIds.push(SelectListDto.fromJS(item));
            }
            this.commsSepratedSuggestedBalanceIds = _data["commsSepratedSuggestedBalanceIds"];
            this.balanceCode = _data["balanceCode"];
            this.balanceId = _data["balanceId"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.grossWeight = _data["grossWeight"];
            this.noOfPacks = _data["noOfPacks"];
            this.tareWeight = _data["tareWeight"];
            this.netWeight = _data["netWeight"];
            this.isPackUOM = _data["isPackUOM"];
            this.noofPacks = _data["noofPacks"];
            this.materialContainerBalanceQuantity = _data["materialContainerBalanceQuantity"];
            this.convertedNoOfPack = _data["convertedNoOfPack"];
            this.convertedNetWeight = _data["convertedNetWeight"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SampleDestructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDestructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionLotId"] = this.inspectionLotId;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["baseUnitOfMeasurementId"] = this.baseUnitOfMeasurementId;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["materialContainerId"] = this.materialContainerId;
        data["materialSampleHeaderHeaderId"] = this.materialSampleHeaderHeaderId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        if (Array.isArray(this.suggestedBalanceIds)) {
            data["suggestedBalanceIds"] = [];
            for (let item of this.suggestedBalanceIds)
                data["suggestedBalanceIds"].push(item.toJSON());
        }
        data["commsSepratedSuggestedBalanceIds"] = this.commsSepratedSuggestedBalanceIds;
        data["balanceCode"] = this.balanceCode;
        data["balanceId"] = this.balanceId;
        data["isGrossWeight"] = this.isGrossWeight;
        data["grossWeight"] = this.grossWeight;
        data["noOfPacks"] = this.noOfPacks;
        data["tareWeight"] = this.tareWeight;
        data["netWeight"] = this.netWeight;
        data["isPackUOM"] = this.isPackUOM;
        data["noofPacks"] = this.noofPacks;
        data["materialContainerBalanceQuantity"] = this.materialContainerBalanceQuantity;
        data["convertedNoOfPack"] = this.convertedNoOfPack;
        data["convertedNetWeight"] = this.convertedNetWeight;
        data["id"] = this.id;
        return data; 
    }

    clone(): SampleDestructionDto {
        const json = this.toJSON();
        let result = new SampleDestructionDto();
        result.init(json);
        return result;
    }
}

export interface ISampleDestructionDto {
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    baseUnitOfMeasurementId: number | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number | undefined;
    materialSampleHeaderHeaderId: number | undefined;
    unitOfMeasurementId: number | undefined;
    suggestedBalanceIds: SelectListDto[] | undefined;
    commsSepratedSuggestedBalanceIds: string | undefined;
    balanceCode: string | undefined;
    balanceId: number | undefined;
    isGrossWeight: boolean;
    grossWeight: number | undefined;
    noOfPacks: number | undefined;
    tareWeight: number | undefined;
    netWeight: number | undefined;
    isPackUOM: boolean;
    noofPacks: number | undefined;
    materialContainerBalanceQuantity: number | undefined;
    convertedNoOfPack: number | undefined;
    convertedNetWeight: number | undefined;
    id: number;
}

export class SAPMaterials implements ISAPMaterials {
    record: SAPMaterial[] | undefined;

    constructor(data?: ISAPMaterials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["record"])) {
                this.record = [] as any;
                for (let item of _data["record"])
                    this.record.push(SAPMaterial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SAPMaterials {
        data = typeof data === 'object' ? data : {};
        let result = new SAPMaterials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.record)) {
            data["record"] = [];
            for (let item of this.record)
                data["record"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SAPMaterials {
        const json = this.toJSON();
        let result = new SAPMaterials();
        result.init(json);
        return result;
    }
}

export interface ISAPMaterials {
    record: SAPMaterial[] | undefined;
}

export class SAPPlantMasterDto implements ISAPPlantMasterDto {
    plantCode: string | undefined;
    description: string | undefined;
    taxRegNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;

    constructor(data?: ISAPPlantMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantCode = _data["plantCode"];
            this.description = _data["description"];
            this.taxRegNo = _data["taxRegNo"];
            this.license = _data["license"];
            this.gS1Prefix = _data["gS1Prefix"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SAPPlantMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPPlantMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantCode"] = this.plantCode;
        data["description"] = this.description;
        data["taxRegNo"] = this.taxRegNo;
        data["license"] = this.license;
        data["gS1Prefix"] = this.gS1Prefix;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }

    clone(): SAPPlantMasterDto {
        const json = this.toJSON();
        let result = new SAPPlantMasterDto();
        result.init(json);
        return result;
    }
}

export interface ISAPPlantMasterDto {
    plantCode: string | undefined;
    description: string | undefined;
    taxRegNo: string | undefined;
    license: string | undefined;
    gS1Prefix: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
}

export class SAPUOMMasterDto implements ISAPUOMMasterDto {
    uom: string | undefined;
    description: string | undefined;

    constructor(data?: ISAPUOMMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uom = _data["uom"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SAPUOMMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPUOMMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uom"] = this.uom;
        data["description"] = this.description;
        return data; 
    }

    clone(): SAPUOMMasterDto {
        const json = this.toJSON();
        let result = new SAPUOMMasterDto();
        result.init(json);
        return result;
    }
}

export interface ISAPUOMMasterDto {
    uom: string | undefined;
    description: string | undefined;
}

export class SAPProcessOrderDto implements ISAPProcessOrderDto {
    processOrderNo: string;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    reqDispensedQty: number;
    uom: string | undefined;
    baseUOM: string | undefined;
    baseQty: number;
    currentStage: string | undefined;
    nextStage: string | undefined;
    dispensingQty: number;
    dispensingUOM: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    isReservationNo: boolean;

    constructor(data?: ISAPProcessOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderNo = _data["processOrderNo"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialCode = _data["materialCode"];
            this.materialDescription = _data["materialDescription"];
            this.arNo = _data["arNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.productCode = _data["productCode"];
            this.productBatchNo = _data["productBatchNo"];
            this.reqDispensedQty = _data["reqDispensedQty"];
            this.uom = _data["uom"];
            this.baseUOM = _data["baseUOM"];
            this.baseQty = _data["baseQty"];
            this.currentStage = _data["currentStage"];
            this.nextStage = _data["nextStage"];
            this.dispensingQty = _data["dispensingQty"];
            this.dispensingUOM = _data["dispensingUOM"];
            this.plant = _data["plant"];
            this.storageLocation = _data["storageLocation"];
            this.isReservationNo = _data["isReservationNo"];
        }
    }

    static fromJS(data: any): SAPProcessOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPProcessOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderNo"] = this.processOrderNo;
        data["lineItemNo"] = this.lineItemNo;
        data["materialCode"] = this.materialCode;
        data["materialDescription"] = this.materialDescription;
        data["arNo"] = this.arNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["productCode"] = this.productCode;
        data["productBatchNo"] = this.productBatchNo;
        data["reqDispensedQty"] = this.reqDispensedQty;
        data["uom"] = this.uom;
        data["baseUOM"] = this.baseUOM;
        data["baseQty"] = this.baseQty;
        data["currentStage"] = this.currentStage;
        data["nextStage"] = this.nextStage;
        data["dispensingQty"] = this.dispensingQty;
        data["dispensingUOM"] = this.dispensingUOM;
        data["plant"] = this.plant;
        data["storageLocation"] = this.storageLocation;
        data["isReservationNo"] = this.isReservationNo;
        return data; 
    }

    clone(): SAPProcessOrderDto {
        const json = this.toJSON();
        let result = new SAPProcessOrderDto();
        result.init(json);
        return result;
    }
}

export interface ISAPProcessOrderDto {
    processOrderNo: string;
    lineItemNo: string | undefined;
    materialCode: string | undefined;
    materialDescription: string | undefined;
    arNo: string | undefined;
    sapBatchNo: string | undefined;
    productCode: string | undefined;
    productBatchNo: string | undefined;
    reqDispensedQty: number;
    uom: string | undefined;
    baseUOM: string | undefined;
    baseQty: number;
    currentStage: string | undefined;
    nextStage: string | undefined;
    dispensingQty: number;
    dispensingUOM: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    isReservationNo: boolean;
}

export class SAPReturntoMaterialDto implements ISAPReturntoMaterialDto {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    itemCode: string;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    sapBatchNo: string | undefined;
    qty: number;
    uom: string | undefined;

    constructor(data?: ISAPReturntoMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocumentNo = _data["materialDocumentNo"];
            this.materialDocumentYear = _data["materialDocumentYear"];
            this.itemCode = _data["itemCode"];
            this.lineItemNo = _data["lineItemNo"];
            this.materialDescription = _data["materialDescription"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.qty = _data["qty"];
            this.uom = _data["uom"];
        }
    }

    static fromJS(data: any): SAPReturntoMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPReturntoMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocumentNo"] = this.materialDocumentNo;
        data["materialDocumentYear"] = this.materialDocumentYear;
        data["itemCode"] = this.itemCode;
        data["lineItemNo"] = this.lineItemNo;
        data["materialDescription"] = this.materialDescription;
        data["sapBatchNo"] = this.sapBatchNo;
        data["qty"] = this.qty;
        data["uom"] = this.uom;
        return data; 
    }

    clone(): SAPReturntoMaterialDto {
        const json = this.toJSON();
        let result = new SAPReturntoMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ISAPReturntoMaterialDto {
    materialDocumentNo: string | undefined;
    materialDocumentYear: string | undefined;
    itemCode: string;
    lineItemNo: string | undefined;
    materialDescription: string | undefined;
    sapBatchNo: string | undefined;
    qty: number;
    uom: string | undefined;
}

export class SAPProcessOrderReceivedMaterialDto implements ISAPProcessOrderReceivedMaterialDto {
    plant: string | undefined;
    poNo: string | undefined;
    poDate: string | undefined;
    lineItemNo: string | undefined;
    orderQty: number | undefined;
    uom: string | undefined;
    itemCode: string | undefined;
    itemDescription: string | undefined;
    vendorName: string | undefined;
    vendorCode: string | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;

    constructor(data?: ISAPProcessOrderReceivedMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plant = _data["plant"];
            this.poNo = _data["poNo"];
            this.poDate = _data["poDate"];
            this.lineItemNo = _data["lineItemNo"];
            this.orderQty = _data["orderQty"];
            this.uom = _data["uom"];
            this.itemCode = _data["itemCode"];
            this.itemDescription = _data["itemDescription"];
            this.vendorName = _data["vendorName"];
            this.vendorCode = _data["vendorCode"];
            this.manufacturerName = _data["manufacturerName"];
            this.manufacturerCode = _data["manufacturerCode"];
        }
    }

    static fromJS(data: any): SAPProcessOrderReceivedMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPProcessOrderReceivedMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plant"] = this.plant;
        data["poNo"] = this.poNo;
        data["poDate"] = this.poDate;
        data["lineItemNo"] = this.lineItemNo;
        data["orderQty"] = this.orderQty;
        data["uom"] = this.uom;
        data["itemCode"] = this.itemCode;
        data["itemDescription"] = this.itemDescription;
        data["vendorName"] = this.vendorName;
        data["vendorCode"] = this.vendorCode;
        data["manufacturerName"] = this.manufacturerName;
        data["manufacturerCode"] = this.manufacturerCode;
        return data; 
    }

    clone(): SAPProcessOrderReceivedMaterialDto {
        const json = this.toJSON();
        let result = new SAPProcessOrderReceivedMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ISAPProcessOrderReceivedMaterialDto {
    plant: string | undefined;
    poNo: string | undefined;
    poDate: string | undefined;
    lineItemNo: string | undefined;
    orderQty: number | undefined;
    uom: string | undefined;
    itemCode: string | undefined;
    itemDescription: string | undefined;
    vendorName: string | undefined;
    vendorCode: string | undefined;
    manufacturerName: string | undefined;
    manufacturerCode: string | undefined;
}

export class SAPQualityControlDetailDto implements ISAPQualityControlDetailDto {
    itemCode: string | undefined;
    inspectionlotNo: string | undefined;
    sapBatchNo: string | undefined;
    batchStockStatus: string | undefined;
    retestDate: string | undefined;
    releasedOn: string | undefined;
    releasedQty: number | undefined;
    movementType: string | undefined;

    constructor(data?: ISAPQualityControlDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemCode = _data["itemCode"];
            this.inspectionlotNo = _data["inspectionlotNo"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.batchStockStatus = _data["batchStockStatus"];
            this.retestDate = _data["retestDate"];
            this.releasedOn = _data["releasedOn"];
            this.releasedQty = _data["releasedQty"];
            this.movementType = _data["movementType"];
        }
    }

    static fromJS(data: any): SAPQualityControlDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SAPQualityControlDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCode"] = this.itemCode;
        data["inspectionlotNo"] = this.inspectionlotNo;
        data["sapBatchNo"] = this.sapBatchNo;
        data["batchStockStatus"] = this.batchStockStatus;
        data["retestDate"] = this.retestDate;
        data["releasedOn"] = this.releasedOn;
        data["releasedQty"] = this.releasedQty;
        data["movementType"] = this.movementType;
        return data; 
    }

    clone(): SAPQualityControlDetailDto {
        const json = this.toJSON();
        let result = new SAPQualityControlDetailDto();
        result.init(json);
        return result;
    }
}

export interface ISAPQualityControlDetailDto {
    itemCode: string | undefined;
    inspectionlotNo: string | undefined;
    sapBatchNo: string | undefined;
    batchStockStatus: string | undefined;
    retestDate: string | undefined;
    releasedOn: string | undefined;
    releasedQty: number | undefined;
    movementType: string | undefined;
}

export class SelectListDtoWithPlantIdPalletization implements ISelectListDtoWithPlantIdPalletization {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    productBatchNo: string | undefined;
    containerBarCode: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    id: any | undefined;

    constructor(data?: ISelectListDtoWithPlantIdPalletization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.plantId = _data["plantId"];
            this.isActive = _data["isActive"];
            this.isSampling = _data["isSampling"];
            this.isReservationNo = _data["isReservationNo"];
            this.productBatchNo = _data["productBatchNo"];
            this.containerBarCode = _data["containerBarCode"];
            this.huCode = _data["huCode"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SelectListDtoWithPlantIdPalletization {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListDtoWithPlantIdPalletization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["plantId"] = this.plantId;
        data["isActive"] = this.isActive;
        data["isSampling"] = this.isSampling;
        data["isReservationNo"] = this.isReservationNo;
        data["productBatchNo"] = this.productBatchNo;
        data["containerBarCode"] = this.containerBarCode;
        data["huCode"] = this.huCode;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): SelectListDtoWithPlantIdPalletization {
        const json = this.toJSON();
        let result = new SelectListDtoWithPlantIdPalletization();
        result.init(json);
        return result;
    }
}

export interface ISelectListDtoWithPlantIdPalletization {
    value: string | undefined;
    plantId: number | undefined;
    isActive: boolean | undefined;
    isSampling: boolean;
    isReservationNo: boolean;
    productBatchNo: string | undefined;
    containerBarCode: string | undefined;
    huCode: string | undefined;
    name: string | undefined;
    id: any | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleNames: string[] | undefined;
    permissions: string[] | undefined;
    transactionActiveSubModules: string[] | undefined;
    plantCode: string | undefined;
    modeId: number;
    isControllerMode: boolean;
    isGateEntrySubModuleActive: boolean;
    isMaterialInspectionModuleSelected: boolean;
    resetPasswordDaysLeft: number;
    approvalLevelId: number | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
            if (Array.isArray(_data["transactionActiveSubModules"])) {
                this.transactionActiveSubModules = [] as any;
                for (let item of _data["transactionActiveSubModules"])
                    this.transactionActiveSubModules.push(item);
            }
            this.plantCode = _data["plantCode"];
            this.modeId = _data["modeId"];
            this.isControllerMode = _data["isControllerMode"];
            this.isGateEntrySubModuleActive = _data["isGateEntrySubModuleActive"];
            this.isMaterialInspectionModuleSelected = _data["isMaterialInspectionModuleSelected"];
            this.resetPasswordDaysLeft = _data["resetPasswordDaysLeft"];
            this.approvalLevelId = _data["approvalLevelId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.transactionActiveSubModules)) {
            data["transactionActiveSubModules"] = [];
            for (let item of this.transactionActiveSubModules)
                data["transactionActiveSubModules"].push(item);
        }
        data["plantCode"] = this.plantCode;
        data["modeId"] = this.modeId;
        data["isControllerMode"] = this.isControllerMode;
        data["isGateEntrySubModuleActive"] = this.isGateEntrySubModuleActive;
        data["isMaterialInspectionModuleSelected"] = this.isMaterialInspectionModuleSelected;
        data["resetPasswordDaysLeft"] = this.resetPasswordDaysLeft;
        data["approvalLevelId"] = this.approvalLevelId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleNames: string[] | undefined;
    permissions: string[] | undefined;
    transactionActiveSubModules: string[] | undefined;
    plantCode: string | undefined;
    modeId: number;
    isControllerMode: boolean;
    isGateEntrySubModuleActive: boolean;
    isMaterialInspectionModuleSelected: boolean;
    resetPasswordDaysLeft: number;
    approvalLevelId: number | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SettingDto implements ISettingDto {
    id: number;
    name: string | undefined;
    value: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): SettingDto {
        const json = this.toJSON();
        let result = new SettingDto();
        result.init(json);
        return result;
    }
}

export interface ISettingDto {
    id: number;
    name: string | undefined;
    value: string | undefined;
}

export class StagingDto implements IStagingDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    processOrderMaterialId: number;
    purchaseOrderMaterialId: number;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    sapBatchNo: string | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    requiredQty: number | undefined;
    isCompleteStagingAllowed: boolean;
    materialBatchDispensingHeaderId: number | undefined;
    id: number;

    constructor(data?: IStagingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.groupId = _data["groupId"];
            this.processOrderMaterialId = _data["processOrderMaterialId"];
            this.purchaseOrderMaterialId = _data["purchaseOrderMaterialId"];
            this.materialCode = _data["materialCode"];
            this.materialContainerBarCode = _data["materialContainerBarCode"];
            this.materialContainerId = _data["materialContainerId"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.requiredQty = _data["requiredQty"];
            this.isCompleteStagingAllowed = _data["isCompleteStagingAllowed"];
            this.materialBatchDispensingHeaderId = _data["materialBatchDispensingHeaderId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StagingDto {
        data = typeof data === 'object' ? data : {};
        let result = new StagingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["groupId"] = this.groupId;
        data["processOrderMaterialId"] = this.processOrderMaterialId;
        data["purchaseOrderMaterialId"] = this.purchaseOrderMaterialId;
        data["materialCode"] = this.materialCode;
        data["materialContainerBarCode"] = this.materialContainerBarCode;
        data["materialContainerId"] = this.materialContainerId;
        data["sapBatchNo"] = this.sapBatchNo;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["requiredQty"] = this.requiredQty;
        data["isCompleteStagingAllowed"] = this.isCompleteStagingAllowed;
        data["materialBatchDispensingHeaderId"] = this.materialBatchDispensingHeaderId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StagingDto {
        const json = this.toJSON();
        let result = new StagingDto();
        result.init(json);
        return result;
    }
}

export interface IStagingDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    groupId: string | undefined;
    processOrderMaterialId: number;
    purchaseOrderMaterialId: number;
    materialCode: string | undefined;
    materialContainerBarCode: string | undefined;
    materialContainerId: number;
    sapBatchNo: string | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    containerCount: number;
    quantity: number | undefined;
    requiredQty: number | undefined;
    isCompleteStagingAllowed: boolean;
    materialBatchDispensingHeaderId: number | undefined;
    id: number;
}

export class StagingOutDto implements IStagingOutDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    groupId: string | undefined;
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    materialContainerBarcode: string | undefined;
    balanceQuantity: number;
    containerCount: number;
    quantity: number;
    id: number;

    constructor(data?: IStagingOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubicleCode = _data["cubicleCode"];
            this.cubicleId = _data["cubicleId"];
            this.cubicleAssignmentHeaderId = _data["cubicleAssignmentHeaderId"];
            this.groupId = _data["groupId"];
            this.inspectionLotId = _data["inspectionLotId"];
            this.materialCode = _data["materialCode"];
            this.sapBatchNo = _data["sapBatchNo"];
            this.materialContainerBarcode = _data["materialContainerBarcode"];
            this.balanceQuantity = _data["balanceQuantity"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StagingOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new StagingOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubicleCode"] = this.cubicleCode;
        data["cubicleId"] = this.cubicleId;
        data["cubicleAssignmentHeaderId"] = this.cubicleAssignmentHeaderId;
        data["groupId"] = this.groupId;
        data["inspectionLotId"] = this.inspectionLotId;
        data["materialCode"] = this.materialCode;
        data["sapBatchNo"] = this.sapBatchNo;
        data["materialContainerBarcode"] = this.materialContainerBarcode;
        data["balanceQuantity"] = this.balanceQuantity;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["id"] = this.id;
        return data; 
    }

    clone(): StagingOutDto {
        const json = this.toJSON();
        let result = new StagingOutDto();
        result.init(json);
        return result;
    }
}

export interface IStagingOutDto {
    cubicleCode: string | undefined;
    cubicleId: number | undefined;
    cubicleAssignmentHeaderId: number | undefined;
    groupId: string | undefined;
    inspectionLotId: number | undefined;
    materialCode: string | undefined;
    sapBatchNo: string | undefined;
    materialContainerBarcode: string | undefined;
    balanceQuantity: number;
    containerCount: number;
    quantity: number;
    id: number;
}

export class StandardWeightDto implements IStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    unitOfMeasurementId: number | undefined;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IStandardWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.standardWeightBoxMasterId = _data["standardWeightBoxMasterId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["standardWeightBoxMasterId"] = this.standardWeightBoxMasterId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightDto {
        const json = this.toJSON();
        let result = new StandardWeightDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    unitOfMeasurementId: number | undefined;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class StandardWeightListDto implements IStandardWeightListDto {
    subPlantId: number;
    standardWeightId: string | undefined;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IStandardWeightListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.userEnteredAreaId = _data["userEnteredAreaId"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["userEnteredAreaId"] = this.userEnteredAreaId;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightListDto {
        const json = this.toJSON();
        let result = new StandardWeightListDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightListDto {
    subPlantId: number;
    standardWeightId: string | undefined;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class StandardWeightListDtoPagedResultDto implements IStandardWeightListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightListDto[] | undefined;

    constructor(data?: IStandardWeightListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(StandardWeightListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StandardWeightListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StandardWeightListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StandardWeightListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightListDto[] | undefined;
}

export class CreateStandardWeightDto implements ICreateStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    unitOfMeasurementId: number | undefined;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateStandardWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightId = _data["standardWeightId"];
            this.capacity = _data["capacity"];
            this.capacityinDecimal = _data["capacityinDecimal"];
            this.areaId = _data["areaId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.departmentId = _data["departmentId"];
            this.standardWeightBoxMasterId = _data["standardWeightBoxMasterId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateStandardWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStandardWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightId"] = this.standardWeightId;
        data["capacity"] = this.capacity;
        data["capacityinDecimal"] = this.capacityinDecimal;
        data["areaId"] = this.areaId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["departmentId"] = this.departmentId;
        data["standardWeightBoxMasterId"] = this.standardWeightBoxMasterId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateStandardWeightDto {
        const json = this.toJSON();
        let result = new CreateStandardWeightDto();
        result.init(json);
        return result;
    }
}

export interface ICreateStandardWeightDto {
    subPlantId: number;
    standardWeightId: string;
    capacity: number | undefined;
    capacityinDecimal: string | undefined;
    areaId: number;
    unitOfMeasurementId: number | undefined;
    departmentId: number;
    standardWeightBoxMasterId: number;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    isActive: boolean;
    description: string | undefined;
}

export class StandardWeightStampingDueListDto implements IStandardWeightStampingDueListDto {
    standardWeightBoxId: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    department: string | undefined;
    area: string | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;

    constructor(data?: IStandardWeightStampingDueListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.department = _data["department"];
            this.area = _data["area"];
            this.dueDays = _data["dueDays"];
            this.plantId = _data["plantId"];
            this.subPlant = _data["subPlant"];
        }
    }

    static fromJS(data: any): StandardWeightStampingDueListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightStampingDueListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["department"] = this.department;
        data["area"] = this.area;
        data["dueDays"] = this.dueDays;
        data["plantId"] = this.plantId;
        data["subPlant"] = this.subPlant;
        return data; 
    }

    clone(): StandardWeightStampingDueListDto {
        const json = this.toJSON();
        let result = new StandardWeightStampingDueListDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightStampingDueListDto {
    standardWeightBoxId: string | undefined;
    stampingDoneOn: moment.Moment;
    stampingDueOn: moment.Moment;
    department: string | undefined;
    area: string | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;
}

export class StandardWeightBoxDto implements IStandardWeightBoxDto {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IStandardWeightBoxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightBoxDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightBoxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightBoxDto {
        const json = this.toJSON();
        let result = new StandardWeightBoxDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightBoxDto {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class StandardWeightBoxListDto implements IStandardWeightBoxListDto {
    subPlantId: number;
    standardWeightBoxId: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IStandardWeightBoxListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.userEnteredSubPlantId = _data["userEnteredSubPlantId"];
            this.userEnteredDepartmentId = _data["userEnteredDepartmentId"];
            this.userEnteredAreaId = _data["userEnteredAreaId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StandardWeightBoxListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightBoxListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["userEnteredSubPlantId"] = this.userEnteredSubPlantId;
        data["userEnteredDepartmentId"] = this.userEnteredDepartmentId;
        data["userEnteredAreaId"] = this.userEnteredAreaId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandardWeightBoxListDto {
        const json = this.toJSON();
        let result = new StandardWeightBoxListDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightBoxListDto {
    subPlantId: number;
    standardWeightBoxId: string | undefined;
    areaId: number | undefined;
    departmentId: number;
    userEnteredSubPlantId: string | undefined;
    userEnteredDepartmentId: string | undefined;
    userEnteredAreaId: string | undefined;
    isActive: boolean;
    description: string | undefined;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class StandardWeightBoxListDtoPagedResultDto implements IStandardWeightBoxListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightBoxListDto[] | undefined;

    constructor(data?: IStandardWeightBoxListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(StandardWeightBoxListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StandardWeightBoxListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardWeightBoxListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StandardWeightBoxListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StandardWeightBoxListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStandardWeightBoxListDtoPagedResultDto {
    totalCount: number;
    items: StandardWeightBoxListDto[] | undefined;
}

export class CreateStandardWeightBoxDto implements ICreateStandardWeightBoxDto {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;

    constructor(data?: ICreateStandardWeightBoxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subPlantId = _data["subPlantId"];
            this.standardWeightBoxId = _data["standardWeightBoxId"];
            this.areaId = _data["areaId"];
            this.departmentId = _data["departmentId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateStandardWeightBoxDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStandardWeightBoxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subPlantId"] = this.subPlantId;
        data["standardWeightBoxId"] = this.standardWeightBoxId;
        data["areaId"] = this.areaId;
        data["departmentId"] = this.departmentId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateStandardWeightBoxDto {
        const json = this.toJSON();
        let result = new CreateStandardWeightBoxDto();
        result.init(json);
        return result;
    }
}

export interface ICreateStandardWeightBoxDto {
    subPlantId: number;
    standardWeightBoxId: string;
    areaId: number;
    departmentId: number;
    isActive: boolean;
    description: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    userId: number;
    isMultiplePlantExists: boolean;
    plantId: number | undefined;
    passwordStatus: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.refreshToken = _data["refreshToken"];
            this.userId = _data["userId"];
            this.isMultiplePlantExists = _data["isMultiplePlantExists"];
            this.plantId = _data["plantId"];
            this.passwordStatus = _data["passwordStatus"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["refreshToken"] = this.refreshToken;
        data["userId"] = this.userId;
        data["isMultiplePlantExists"] = this.isMultiplePlantExists;
        data["plantId"] = this.plantId;
        data["passwordStatus"] = this.passwordStatus;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    userId: number;
    isMultiplePlantExists: boolean;
    plantId: number | undefined;
    passwordStatus: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class UnitOfMeasurementDto implements IUnitOfMeasurementDto {
    uomCode: string | undefined;
    name: string;
    description: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;

    constructor(data?: IUnitOfMeasurementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uomCode = _data["uomCode"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.unitOfMeasurementTypeId = _data["unitOfMeasurementTypeId"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UnitOfMeasurementDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitOfMeasurementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uomCode"] = this.uomCode;
        data["name"] = this.name;
        data["description"] = this.description;
        data["unitOfMeasurementTypeId"] = this.unitOfMeasurementTypeId;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): UnitOfMeasurementDto {
        const json = this.toJSON();
        let result = new UnitOfMeasurementDto();
        result.init(json);
        return result;
    }
}

export interface IUnitOfMeasurementDto {
    uomCode: string | undefined;
    name: string;
    description: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    id: number;
}

export class UnitOfMeasurementListDtoPagedResultDto implements IUnitOfMeasurementListDtoPagedResultDto {
    totalCount: number;
    items: UnitOfMeasurementListDto[] | undefined;

    constructor(data?: IUnitOfMeasurementListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UnitOfMeasurementListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnitOfMeasurementListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitOfMeasurementListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UnitOfMeasurementListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UnitOfMeasurementListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUnitOfMeasurementListDtoPagedResultDto {
    totalCount: number;
    items: UnitOfMeasurementListDto[] | undefined;
}

export class CreateUnitOfMeasurementDto implements ICreateUnitOfMeasurementDto {
    name: string;
    description: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string;
    isActive: boolean;

    constructor(data?: ICreateUnitOfMeasurementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.unitOfMeasurementTypeId = _data["unitOfMeasurementTypeId"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateUnitOfMeasurementDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUnitOfMeasurementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["unitOfMeasurementTypeId"] = this.unitOfMeasurementTypeId;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateUnitOfMeasurementDto {
        const json = this.toJSON();
        let result = new CreateUnitOfMeasurementDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUnitOfMeasurementDto {
    name: string;
    description: string | undefined;
    unitOfMeasurementTypeId: number | undefined;
    unitOfMeasurement: string;
    isActive: boolean;
}

export class UsersListDto implements IUsersListDto {
    userName: string | undefined;
    creationTime: moment.Moment;
    approvalStatusId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pswdResetDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.approvalStatusId = _data["approvalStatusId"];
            this.isActive = _data["isActive"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.pswdResetDate = _data["pswdResetDate"] ? moment(_data["pswdResetDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["approvalStatusId"] = this.approvalStatusId;
        data["isActive"] = this.isActive;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["pswdResetDate"] = this.pswdResetDate ? this.pswdResetDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UsersListDto {
        const json = this.toJSON();
        let result = new UsersListDto();
        result.init(json);
        return result;
    }
}

export interface IUsersListDto {
    userName: string | undefined;
    creationTime: moment.Moment;
    approvalStatusId: number;
    isActive: boolean;
    userEnteredApprovalStatus: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    pswdResetDate: moment.Moment | undefined;
    id: number;
}

export class UsersListDtoPagedResultDto implements IUsersListDtoPagedResultDto {
    totalCount: number;
    items: UsersListDto[] | undefined;

    constructor(data?: IUsersListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UsersListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UsersListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UsersListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUsersListDtoPagedResultDto {
    totalCount: number;
    items: UsersListDto[] | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string | undefined;
    email: string | undefined;
    isDeleted: boolean;
    createdOn: moment.Moment;
    plants: number[] | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    designationId: number | undefined;
    employeeCode: string | undefined;
    roleNames: string[] | undefined;
    password: string;
    confirmPassword: string;
    isActive: boolean;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isDeleted = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : false;
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(item);
            }
            this.reportingManagerId = _data["reportingManagerId"];
            this.modeId = _data["modeId"];
            this.designationId = _data["designationId"];
            this.employeeCode = _data["employeeCode"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item);
        }
        data["reportingManagerId"] = this.reportingManagerId;
        data["modeId"] = this.modeId;
        data["designationId"] = this.designationId;
        data["employeeCode"] = this.employeeCode;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    firstName: string;
    lastName: string;
    phoneNumber: string | undefined;
    email: string | undefined;
    isDeleted: boolean;
    createdOn: moment.Moment;
    plants: number[] | undefined;
    reportingManagerId: number | undefined;
    modeId: number;
    designationId: number | undefined;
    employeeCode: string | undefined;
    roleNames: string[] | undefined;
    password: string;
    confirmPassword: string;
    isActive: boolean;
}

export class RoleCheckboxDto implements IRoleCheckboxDto {
    name: string | undefined;
    displayName: string | undefined;
    isSelected: boolean;
    userRoles: RoleCheckboxDto[] | undefined;

    constructor(data?: IRoleCheckboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isSelected = _data["isSelected"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles.push(RoleCheckboxDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleCheckboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleCheckboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isSelected"] = this.isSelected;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleCheckboxDto {
        const json = this.toJSON();
        let result = new RoleCheckboxDto();
        result.init(json);
        return result;
    }
}

export interface IRoleCheckboxDto {
    name: string | undefined;
    displayName: string | undefined;
    isSelected: boolean;
    userRoles: RoleCheckboxDto[] | undefined;
}

export class VehicleInspectionDto implements IVehicleInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    checklistTypeId: number;
    inspectionChecklistId: number;
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    invoiceDto: InvoiceDto;
    id: number;

    constructor(data?: IVehicleInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.gatePassNo = _data["gatePassNo"];
            this.inspectionDate = _data["inspectionDate"] ? moment(_data["inspectionDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.transactionStatusId = _data["transactionStatusId"];
            if (Array.isArray(_data["vehicleInspectionDetails"])) {
                this.vehicleInspectionDetails = [] as any;
                for (let item of _data["vehicleInspectionDetails"])
                    this.vehicleInspectionDetails.push(CheckpointDto.fromJS(item));
            }
            this.invoiceDto = _data["invoiceDto"] ? InvoiceDto.fromJS(_data["invoiceDto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["gatePassNo"] = this.gatePassNo;
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["transactionStatusId"] = this.transactionStatusId;
        if (Array.isArray(this.vehicleInspectionDetails)) {
            data["vehicleInspectionDetails"] = [];
            for (let item of this.vehicleInspectionDetails)
                data["vehicleInspectionDetails"].push(item.toJSON());
        }
        data["invoiceDto"] = this.invoiceDto ? this.invoiceDto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionDto {
        const json = this.toJSON();
        let result = new VehicleInspectionDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionDto {
    gateEntryId: number | undefined;
    gatePassNo: string | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    checklistTypeId: number;
    inspectionChecklistId: number;
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    invoiceDto: InvoiceDto;
    id: number;
}

export class VehicleInspectionListDto implements IVehicleInspectionListDto {
    gateEntryId: number | undefined;
    purchaseOrderId: number | undefined;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    lrNo: string | undefined;
    subPlantId: number;
    transactionStatusId: number | undefined;
    transactionStatus: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;

    constructor(data?: IVehicleInspectionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.gatePassNo = _data["gatePassNo"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.lrNo = _data["lrNo"];
            this.subPlantId = _data["subPlantId"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.transactionStatus = _data["transactionStatus"];
            this.purchaseOrderDeliverSchedule = _data["purchaseOrderDeliverSchedule"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VehicleInspectionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["gatePassNo"] = this.gatePassNo;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["invoiceNo"] = this.invoiceNo;
        data["lrNo"] = this.lrNo;
        data["subPlantId"] = this.subPlantId;
        data["transactionStatusId"] = this.transactionStatusId;
        data["transactionStatus"] = this.transactionStatus;
        data["purchaseOrderDeliverSchedule"] = this.purchaseOrderDeliverSchedule;
        data["id"] = this.id;
        return data; 
    }

    clone(): VehicleInspectionListDto {
        const json = this.toJSON();
        let result = new VehicleInspectionListDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionListDto {
    gateEntryId: number | undefined;
    purchaseOrderId: number | undefined;
    gatePassNo: string | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    lrNo: string | undefined;
    subPlantId: number;
    transactionStatusId: number | undefined;
    transactionStatus: string | undefined;
    purchaseOrderDeliverSchedule: string | undefined;
    id: number;
}

export class VehicleInspectionListDtoPagedResultDto implements IVehicleInspectionListDtoPagedResultDto {
    totalCount: number;
    items: VehicleInspectionListDto[] | undefined;

    constructor(data?: IVehicleInspectionListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VehicleInspectionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleInspectionListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInspectionListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VehicleInspectionListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VehicleInspectionListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleInspectionListDtoPagedResultDto {
    totalCount: number;
    items: VehicleInspectionListDto[] | undefined;
}

export class CreateVehicleInspectionDto implements ICreateVehicleInspectionDto {
    gateEntryId: number | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    checklistTypeId: number;
    inspectionChecklistId: number;
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    invoiceDto: InvoiceDto;

    constructor(data?: ICreateVehicleInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateEntryId = _data["gateEntryId"];
            this.inspectionDate = _data["inspectionDate"] ? moment(_data["inspectionDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.transactionStatusId = _data["transactionStatusId"];
            if (Array.isArray(_data["vehicleInspectionDetails"])) {
                this.vehicleInspectionDetails = [] as any;
                for (let item of _data["vehicleInspectionDetails"])
                    this.vehicleInspectionDetails.push(CheckpointDto.fromJS(item));
            }
            this.invoiceDto = _data["invoiceDto"] ? InvoiceDto.fromJS(_data["invoiceDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateVehicleInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateEntryId"] = this.gateEntryId;
        data["inspectionDate"] = this.inspectionDate ? this.inspectionDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["transactionStatusId"] = this.transactionStatusId;
        if (Array.isArray(this.vehicleInspectionDetails)) {
            data["vehicleInspectionDetails"] = [];
            for (let item of this.vehicleInspectionDetails)
                data["vehicleInspectionDetails"].push(item.toJSON());
        }
        data["invoiceDto"] = this.invoiceDto ? this.invoiceDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateVehicleInspectionDto {
        const json = this.toJSON();
        let result = new CreateVehicleInspectionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateVehicleInspectionDto {
    gateEntryId: number | undefined;
    inspectionDate: moment.Moment;
    tenantId: number | undefined;
    checklistTypeId: number;
    inspectionChecklistId: number;
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    invoiceDto: InvoiceDto;
}

export class UpdateVehicleInspectionDto implements IUpdateVehicleInspectionDto {
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    id: number;

    constructor(data?: IUpdateVehicleInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionStatusId = _data["transactionStatusId"];
            if (Array.isArray(_data["vehicleInspectionDetails"])) {
                this.vehicleInspectionDetails = [] as any;
                for (let item of _data["vehicleInspectionDetails"])
                    this.vehicleInspectionDetails.push(CheckpointDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateVehicleInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionStatusId"] = this.transactionStatusId;
        if (Array.isArray(this.vehicleInspectionDetails)) {
            data["vehicleInspectionDetails"] = [];
            for (let item of this.vehicleInspectionDetails)
                data["vehicleInspectionDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateVehicleInspectionDto {
        const json = this.toJSON();
        let result = new UpdateVehicleInspectionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateVehicleInspectionDto {
    transactionStatusId: number | undefined;
    vehicleInspectionDetails: CheckpointDto[] | undefined;
    id: number;
}

export class WeighingCalibrationListDto implements IWeighingCalibrationListDto {
    weighingMachineId: number | undefined;
    calibrationFrequencyId: number | undefined;
    calibrationStatusId: number | undefined;
    calibrationTestDate: moment.Moment | undefined;
    subPlantId: number | undefined;
    weighingMachineCode: string | undefined;
    userEnteredCalibrationFrequency: string | undefined;
    userEnteredCalibrationStatus: string | undefined;
    id: number;

    constructor(data?: IWeighingCalibrationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineId = _data["weighingMachineId"];
            this.calibrationFrequencyId = _data["calibrationFrequencyId"];
            this.calibrationStatusId = _data["calibrationStatusId"];
            this.calibrationTestDate = _data["calibrationTestDate"] ? moment(_data["calibrationTestDate"].toString()) : <any>undefined;
            this.subPlantId = _data["subPlantId"];
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.userEnteredCalibrationFrequency = _data["userEnteredCalibrationFrequency"];
            this.userEnteredCalibrationStatus = _data["userEnteredCalibrationStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingCalibrationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineId"] = this.weighingMachineId;
        data["calibrationFrequencyId"] = this.calibrationFrequencyId;
        data["calibrationStatusId"] = this.calibrationStatusId;
        data["calibrationTestDate"] = this.calibrationTestDate ? this.calibrationTestDate.toISOString() : <any>undefined;
        data["subPlantId"] = this.subPlantId;
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["userEnteredCalibrationFrequency"] = this.userEnteredCalibrationFrequency;
        data["userEnteredCalibrationStatus"] = this.userEnteredCalibrationStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingCalibrationListDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationListDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationListDto {
    weighingMachineId: number | undefined;
    calibrationFrequencyId: number | undefined;
    calibrationStatusId: number | undefined;
    calibrationTestDate: moment.Moment | undefined;
    subPlantId: number | undefined;
    weighingMachineCode: string | undefined;
    userEnteredCalibrationFrequency: string | undefined;
    userEnteredCalibrationStatus: string | undefined;
    id: number;
}

export class WeighingCalibrationListDtoPagedResultDto implements IWeighingCalibrationListDtoPagedResultDto {
    totalCount: number;
    items: WeighingCalibrationListDto[] | undefined;

    constructor(data?: IWeighingCalibrationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WeighingCalibrationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeighingCalibrationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingCalibrationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WeighingCalibrationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WeighingCalibrationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingCalibrationListDtoPagedResultDto {
    totalCount: number;
    items: WeighingCalibrationListDto[] | undefined;
}

export class CreateWeighingCalibrationDto implements ICreateWeighingCalibrationDto {
    weighingMachineCode: string | undefined;
    weighingMachineId: number | undefined;
    frequencyModeld: number;
    make: string | undefined;
    model: string | undefined;
    capacity: number | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    unitOfMeasurement: number | undefined;
    leastCount: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    isReCalibrated: boolean | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    reCalibrationRemark: string | undefined;
    calibrationFrequencySelectListDtos: SelectListDto[] | undefined;
    calibrationFrequencyDtos: CalibrationFrequencyDto[] | undefined;
    weighingCalibrationCheckpoints: CheckpointDto[] | undefined;
    lstWeighingCalibrationDetailDto: WeighingCalibrationDetailDto[] | undefined;
    weighingCalibrationDetailCurrentDto: WeighingCalibrationDetailDto;
    weighingCalibrationEccentricityTestDto: WeighingCalibrationEccentricityTestDto;
    weighingCalibrationLinearityTestDto: WeighingCalibrationLinearityTestDto;
    weighingCalibrationRepeatabilityTestDto: WeighingCalibrationRepeatabilityTestDto;

    constructor(data?: ICreateWeighingCalibrationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.weighingMachineId = _data["weighingMachineId"];
            this.frequencyModeld = _data["frequencyModeld"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.capacity = _data["capacity"];
            this.userEnteredUnitOfMeasurement = _data["userEnteredUnitOfMeasurement"];
            this.initialZeroReading = _data["initialZeroReading"];
            this.unitOfMeasurement = _data["unitOfMeasurement"];
            this.leastCount = _data["leastCount"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.isReCalibrated = _data["isReCalibrated"];
            this.doneBy = _data["doneBy"];
            this.checkedBy = _data["checkedBy"];
            this.spriritLevelBubble = _data["spriritLevelBubble"];
            this.reCalibrationRemark = _data["reCalibrationRemark"];
            if (Array.isArray(_data["calibrationFrequencySelectListDtos"])) {
                this.calibrationFrequencySelectListDtos = [] as any;
                for (let item of _data["calibrationFrequencySelectListDtos"])
                    this.calibrationFrequencySelectListDtos.push(SelectListDto.fromJS(item));
            }
            if (Array.isArray(_data["calibrationFrequencyDtos"])) {
                this.calibrationFrequencyDtos = [] as any;
                for (let item of _data["calibrationFrequencyDtos"])
                    this.calibrationFrequencyDtos.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingCalibrationCheckpoints"])) {
                this.weighingCalibrationCheckpoints = [] as any;
                for (let item of _data["weighingCalibrationCheckpoints"])
                    this.weighingCalibrationCheckpoints.push(CheckpointDto.fromJS(item));
            }
            if (Array.isArray(_data["lstWeighingCalibrationDetailDto"])) {
                this.lstWeighingCalibrationDetailDto = [] as any;
                for (let item of _data["lstWeighingCalibrationDetailDto"])
                    this.lstWeighingCalibrationDetailDto.push(WeighingCalibrationDetailDto.fromJS(item));
            }
            this.weighingCalibrationDetailCurrentDto = _data["weighingCalibrationDetailCurrentDto"] ? WeighingCalibrationDetailDto.fromJS(_data["weighingCalibrationDetailCurrentDto"]) : <any>undefined;
            this.weighingCalibrationEccentricityTestDto = _data["weighingCalibrationEccentricityTestDto"] ? WeighingCalibrationEccentricityTestDto.fromJS(_data["weighingCalibrationEccentricityTestDto"]) : <any>undefined;
            this.weighingCalibrationLinearityTestDto = _data["weighingCalibrationLinearityTestDto"] ? WeighingCalibrationLinearityTestDto.fromJS(_data["weighingCalibrationLinearityTestDto"]) : <any>undefined;
            this.weighingCalibrationRepeatabilityTestDto = _data["weighingCalibrationRepeatabilityTestDto"] ? WeighingCalibrationRepeatabilityTestDto.fromJS(_data["weighingCalibrationRepeatabilityTestDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateWeighingCalibrationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeighingCalibrationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["weighingMachineId"] = this.weighingMachineId;
        data["frequencyModeld"] = this.frequencyModeld;
        data["make"] = this.make;
        data["model"] = this.model;
        data["capacity"] = this.capacity;
        data["userEnteredUnitOfMeasurement"] = this.userEnteredUnitOfMeasurement;
        data["initialZeroReading"] = this.initialZeroReading;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["leastCount"] = this.leastCount;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["isReCalibrated"] = this.isReCalibrated;
        data["doneBy"] = this.doneBy;
        data["checkedBy"] = this.checkedBy;
        data["spriritLevelBubble"] = this.spriritLevelBubble;
        data["reCalibrationRemark"] = this.reCalibrationRemark;
        if (Array.isArray(this.calibrationFrequencySelectListDtos)) {
            data["calibrationFrequencySelectListDtos"] = [];
            for (let item of this.calibrationFrequencySelectListDtos)
                data["calibrationFrequencySelectListDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.calibrationFrequencyDtos)) {
            data["calibrationFrequencyDtos"] = [];
            for (let item of this.calibrationFrequencyDtos)
                data["calibrationFrequencyDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingCalibrationCheckpoints)) {
            data["weighingCalibrationCheckpoints"] = [];
            for (let item of this.weighingCalibrationCheckpoints)
                data["weighingCalibrationCheckpoints"].push(item.toJSON());
        }
        if (Array.isArray(this.lstWeighingCalibrationDetailDto)) {
            data["lstWeighingCalibrationDetailDto"] = [];
            for (let item of this.lstWeighingCalibrationDetailDto)
                data["lstWeighingCalibrationDetailDto"].push(item.toJSON());
        }
        data["weighingCalibrationDetailCurrentDto"] = this.weighingCalibrationDetailCurrentDto ? this.weighingCalibrationDetailCurrentDto.toJSON() : <any>undefined;
        data["weighingCalibrationEccentricityTestDto"] = this.weighingCalibrationEccentricityTestDto ? this.weighingCalibrationEccentricityTestDto.toJSON() : <any>undefined;
        data["weighingCalibrationLinearityTestDto"] = this.weighingCalibrationLinearityTestDto ? this.weighingCalibrationLinearityTestDto.toJSON() : <any>undefined;
        data["weighingCalibrationRepeatabilityTestDto"] = this.weighingCalibrationRepeatabilityTestDto ? this.weighingCalibrationRepeatabilityTestDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateWeighingCalibrationDto {
        const json = this.toJSON();
        let result = new CreateWeighingCalibrationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeighingCalibrationDto {
    weighingMachineCode: string | undefined;
    weighingMachineId: number | undefined;
    frequencyModeld: number;
    make: string | undefined;
    model: string | undefined;
    capacity: number | undefined;
    userEnteredUnitOfMeasurement: string | undefined;
    initialZeroReading: string | undefined;
    unitOfMeasurement: number | undefined;
    leastCount: number | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    isReCalibrated: boolean | undefined;
    doneBy: string | undefined;
    checkedBy: string | undefined;
    spriritLevelBubble: string | undefined;
    reCalibrationRemark: string | undefined;
    calibrationFrequencySelectListDtos: SelectListDto[] | undefined;
    calibrationFrequencyDtos: CalibrationFrequencyDto[] | undefined;
    weighingCalibrationCheckpoints: CheckpointDto[] | undefined;
    lstWeighingCalibrationDetailDto: WeighingCalibrationDetailDto[] | undefined;
    weighingCalibrationDetailCurrentDto: WeighingCalibrationDetailDto;
    weighingCalibrationEccentricityTestDto: WeighingCalibrationEccentricityTestDto;
    weighingCalibrationLinearityTestDto: WeighingCalibrationLinearityTestDto;
    weighingCalibrationRepeatabilityTestDto: WeighingCalibrationRepeatabilityTestDto;
}

export class CreateWeighingCalibrationResultDto implements ICreateWeighingCalibrationResultDto {
    calibrationStatusId: number;
    id: number;

    constructor(data?: ICreateWeighingCalibrationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calibrationStatusId = _data["calibrationStatusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateWeighingCalibrationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeighingCalibrationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calibrationStatusId"] = this.calibrationStatusId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateWeighingCalibrationResultDto {
        const json = this.toJSON();
        let result = new CreateWeighingCalibrationResultDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeighingCalibrationResultDto {
    calibrationStatusId: number;
    id: number;
}

export class WeighingMachineDto implements IWeighingMachineDto {
    weighingMachineCode: string | undefined;
    balancedTypeId: number | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    id: number;

    constructor(data?: IWeighingMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.balancedTypeId = _data["balancedTypeId"];
            this.subPlantId = _data["subPlantId"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.capacity = _data["capacity"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.minimumOperatingCapacity = _data["minimumOperatingCapacity"];
            this.maximumOperatingCapacity = _data["maximumOperatingCapacity"];
            this.leastCount = _data["leastCount"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.eccentricityAcceptanceValue = _data["eccentricityAcceptanceValue"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.linearityAcceptanceValue = _data["linearityAcceptanceValue"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityAcceptanceValue = _data["repeatabilityAcceptanceValue"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyAcceptanceValue = _data["uncertaintyAcceptanceValue"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.percentageRSDValue = _data["percentageRSDValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.meanValue = _data["meanValue"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.formula = _data["formula"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isApprovalRequired = _data["isApprovalRequired"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.approvalStatusDescription = _data["approvalStatusDescription"];
            if (Array.isArray(_data["calibrations"])) {
                this.calibrations = [] as any;
                for (let item of _data["calibrations"])
                    this.calibrations.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestconfigurationDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["balancedTypeId"] = this.balancedTypeId;
        data["subPlantId"] = this.subPlantId;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["capacity"] = this.capacity;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["minimumOperatingCapacity"] = this.minimumOperatingCapacity;
        data["maximumOperatingCapacity"] = this.maximumOperatingCapacity;
        data["leastCount"] = this.leastCount;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["eccentricityAcceptanceValue"] = this.eccentricityAcceptanceValue;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["linearityAcceptanceValue"] = this.linearityAcceptanceValue;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityAcceptanceValue"] = this.repeatabilityAcceptanceValue;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyAcceptanceValue"] = this.uncertaintyAcceptanceValue;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["percentageRSDValue"] = this.percentageRSDValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["meanValue"] = this.meanValue;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["formula"] = this.formula;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isApprovalRequired"] = this.isApprovalRequired;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["approvalStatusDescription"] = this.approvalStatusDescription;
        if (Array.isArray(this.calibrations)) {
            data["calibrations"] = [];
            for (let item of this.calibrations)
                data["calibrations"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineDto {
        const json = this.toJSON();
        let result = new WeighingMachineDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineDto {
    weighingMachineCode: string | undefined;
    balancedTypeId: number | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isApprovalRequired: boolean;
    userEnteredApprovalStatus: string | undefined;
    approvalStatusDescription: string | undefined;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
    id: number;
}

export class WeighingMachineListDto implements IWeighingMachineListDto {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    userEnteredPlantId: string | undefined;
    unitOfMeasurementId: number | undefined;
    userEnteredUOM: string | undefined;
    make: string | undefined;
    modal: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyInstruction: string | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;

    constructor(data?: IWeighingMachineListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.subPlantId = _data["subPlantId"];
            this.userEnteredPlantId = _data["userEnteredPlantId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.userEnteredUOM = _data["userEnteredUOM"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.isActive = _data["isActive"];
            this.approvalStatusId = _data["approvalStatusId"];
            this.userEnteredApprovalStatus = _data["userEnteredApprovalStatus"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeighingMachineListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["subPlantId"] = this.subPlantId;
        data["userEnteredPlantId"] = this.userEnteredPlantId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["userEnteredUOM"] = this.userEnteredUOM;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["isActive"] = this.isActive;
        data["approvalStatusId"] = this.approvalStatusId;
        data["userEnteredApprovalStatus"] = this.userEnteredApprovalStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeighingMachineListDto {
        const json = this.toJSON();
        let result = new WeighingMachineListDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineListDto {
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    userEnteredPlantId: string | undefined;
    unitOfMeasurementId: number | undefined;
    userEnteredUOM: string | undefined;
    make: string | undefined;
    modal: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    eccentricityInstruction: string | undefined;
    linearityInstruction: string | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyInstruction: string | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    isActive: boolean;
    approvalStatusId: number;
    userEnteredApprovalStatus: string | undefined;
    id: number;
}

export class WeighingMachineListDtoPagedResultDto implements IWeighingMachineListDtoPagedResultDto {
    totalCount: number;
    items: WeighingMachineListDto[] | undefined;

    constructor(data?: IWeighingMachineListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WeighingMachineListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeighingMachineListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WeighingMachineListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WeighingMachineListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineListDtoPagedResultDto {
    totalCount: number;
    items: WeighingMachineListDto[] | undefined;
}

export class CreateWeighingMachineDto implements ICreateWeighingMachineDto {
    balancedTypeId: number | undefined;
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;

    constructor(data?: ICreateWeighingMachineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balancedTypeId = _data["balancedTypeId"];
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.subPlantId = _data["subPlantId"];
            this.ipAddress = _data["ipAddress"];
            this.portNumber = _data["portNumber"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
            this.capacity = _data["capacity"];
            this.make = _data["make"];
            this.modal = _data["modal"];
            this.minimumOperatingCapacity = _data["minimumOperatingCapacity"];
            this.maximumOperatingCapacity = _data["maximumOperatingCapacity"];
            this.leastCount = _data["leastCount"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.eccentricityAcceptanceValue = _data["eccentricityAcceptanceValue"];
            this.eccentricityInstruction = _data["eccentricityInstruction"];
            this.linearityAcceptanceValueWg1 = _data["linearityAcceptanceValueWg1"];
            this.linearityAcceptanceValueWg2 = _data["linearityAcceptanceValueWg2"];
            this.linearityAcceptanceValueWg3 = _data["linearityAcceptanceValueWg3"];
            this.linearityAcceptanceValueWg4 = _data["linearityAcceptanceValueWg4"];
            this.linearityAcceptanceValueWg5 = _data["linearityAcceptanceValueWg5"];
            this.eccentricityAcceptanceMinValue = _data["eccentricityAcceptanceMinValue"];
            this.eccentricityAcceptanceMaxValue = _data["eccentricityAcceptanceMaxValue"];
            this.repeatabilityAcceptanceMinValue = _data["repeatabilityAcceptanceMinValue"];
            this.repeatabilityAcceptanceMaxValue = _data["repeatabilityAcceptanceMaxValue"];
            this.linearityAcceptanceMinValueWg1 = _data["linearityAcceptanceMinValueWg1"];
            this.linearityAcceptanceMinValueWg2 = _data["linearityAcceptanceMinValueWg2"];
            this.linearityAcceptanceMinValueWg3 = _data["linearityAcceptanceMinValueWg3"];
            this.linearityAcceptanceMinValueWg4 = _data["linearityAcceptanceMinValueWg4"];
            this.linearityAcceptanceMinValueWg5 = _data["linearityAcceptanceMinValueWg5"];
            this.linearityAcceptanceMaxValueWg1 = _data["linearityAcceptanceMaxValueWg1"];
            this.linearityAcceptanceMaxValueWg2 = _data["linearityAcceptanceMaxValueWg2"];
            this.linearityAcceptanceMaxValueWg3 = _data["linearityAcceptanceMaxValueWg3"];
            this.linearityAcceptanceMaxValueWg4 = _data["linearityAcceptanceMaxValueWg4"];
            this.linearityAcceptanceMaxValueWg5 = _data["linearityAcceptanceMaxValueWg5"];
            this.linearityAcceptanceValue = _data["linearityAcceptanceValue"];
            this.linearityInstruction = _data["linearityInstruction"];
            this.repeatabilityAcceptanceValue = _data["repeatabilityAcceptanceValue"];
            this.repeatabilityInstruction = _data["repeatabilityInstruction"];
            this.uncertaintyAcceptanceValue = _data["uncertaintyAcceptanceValue"];
            this.uncertaintyInstruction = _data["uncertaintyInstruction"];
            this.percentageRSDValue = _data["percentageRSDValue"];
            this.standardDeviationValue = _data["standardDeviationValue"];
            this.meanValue = _data["meanValue"];
            this.meanMinimumValue = _data["meanMinimumValue"];
            this.meanMaximumValue = _data["meanMaximumValue"];
            this.formula = _data["formula"];
            this.frequencyTypeId = _data["frequencyTypeId"];
            this.refrenceSOPNo = _data["refrenceSOPNo"];
            this.formatNo = _data["formatNo"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["calibrations"])) {
                this.calibrations = [] as any;
                for (let item of _data["calibrations"])
                    this.calibrations.push(CalibrationFrequencyDto.fromJS(item));
            }
            if (Array.isArray(_data["weighingMachineTestConfigurations"])) {
                this.weighingMachineTestConfigurations = [] as any;
                for (let item of _data["weighingMachineTestConfigurations"])
                    this.weighingMachineTestConfigurations.push(WeighingMachineTestconfigurationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWeighingMachineDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeighingMachineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balancedTypeId"] = this.balancedTypeId;
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["subPlantId"] = this.subPlantId;
        data["ipAddress"] = this.ipAddress;
        data["portNumber"] = this.portNumber;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        data["capacity"] = this.capacity;
        data["make"] = this.make;
        data["modal"] = this.modal;
        data["minimumOperatingCapacity"] = this.minimumOperatingCapacity;
        data["maximumOperatingCapacity"] = this.maximumOperatingCapacity;
        data["leastCount"] = this.leastCount;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["eccentricityAcceptanceValue"] = this.eccentricityAcceptanceValue;
        data["eccentricityInstruction"] = this.eccentricityInstruction;
        data["linearityAcceptanceValueWg1"] = this.linearityAcceptanceValueWg1;
        data["linearityAcceptanceValueWg2"] = this.linearityAcceptanceValueWg2;
        data["linearityAcceptanceValueWg3"] = this.linearityAcceptanceValueWg3;
        data["linearityAcceptanceValueWg4"] = this.linearityAcceptanceValueWg4;
        data["linearityAcceptanceValueWg5"] = this.linearityAcceptanceValueWg5;
        data["eccentricityAcceptanceMinValue"] = this.eccentricityAcceptanceMinValue;
        data["eccentricityAcceptanceMaxValue"] = this.eccentricityAcceptanceMaxValue;
        data["repeatabilityAcceptanceMinValue"] = this.repeatabilityAcceptanceMinValue;
        data["repeatabilityAcceptanceMaxValue"] = this.repeatabilityAcceptanceMaxValue;
        data["linearityAcceptanceMinValueWg1"] = this.linearityAcceptanceMinValueWg1;
        data["linearityAcceptanceMinValueWg2"] = this.linearityAcceptanceMinValueWg2;
        data["linearityAcceptanceMinValueWg3"] = this.linearityAcceptanceMinValueWg3;
        data["linearityAcceptanceMinValueWg4"] = this.linearityAcceptanceMinValueWg4;
        data["linearityAcceptanceMinValueWg5"] = this.linearityAcceptanceMinValueWg5;
        data["linearityAcceptanceMaxValueWg1"] = this.linearityAcceptanceMaxValueWg1;
        data["linearityAcceptanceMaxValueWg2"] = this.linearityAcceptanceMaxValueWg2;
        data["linearityAcceptanceMaxValueWg3"] = this.linearityAcceptanceMaxValueWg3;
        data["linearityAcceptanceMaxValueWg4"] = this.linearityAcceptanceMaxValueWg4;
        data["linearityAcceptanceMaxValueWg5"] = this.linearityAcceptanceMaxValueWg5;
        data["linearityAcceptanceValue"] = this.linearityAcceptanceValue;
        data["linearityInstruction"] = this.linearityInstruction;
        data["repeatabilityAcceptanceValue"] = this.repeatabilityAcceptanceValue;
        data["repeatabilityInstruction"] = this.repeatabilityInstruction;
        data["uncertaintyAcceptanceValue"] = this.uncertaintyAcceptanceValue;
        data["uncertaintyInstruction"] = this.uncertaintyInstruction;
        data["percentageRSDValue"] = this.percentageRSDValue;
        data["standardDeviationValue"] = this.standardDeviationValue;
        data["meanValue"] = this.meanValue;
        data["meanMinimumValue"] = this.meanMinimumValue;
        data["meanMaximumValue"] = this.meanMaximumValue;
        data["formula"] = this.formula;
        data["frequencyTypeId"] = this.frequencyTypeId;
        data["refrenceSOPNo"] = this.refrenceSOPNo;
        data["formatNo"] = this.formatNo;
        data["version"] = this.version;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.calibrations)) {
            data["calibrations"] = [];
            for (let item of this.calibrations)
                data["calibrations"].push(item.toJSON());
        }
        if (Array.isArray(this.weighingMachineTestConfigurations)) {
            data["weighingMachineTestConfigurations"] = [];
            for (let item of this.weighingMachineTestConfigurations)
                data["weighingMachineTestConfigurations"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateWeighingMachineDto {
        const json = this.toJSON();
        let result = new CreateWeighingMachineDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeighingMachineDto {
    balancedTypeId: number | undefined;
    weighingMachineCode: string | undefined;
    subPlantId: number | undefined;
    ipAddress: string | undefined;
    portNumber: number | undefined;
    unitOfMeasurementId: number | undefined;
    capacity: number | undefined;
    make: string | undefined;
    modal: string | undefined;
    minimumOperatingCapacity: number | undefined;
    maximumOperatingCapacity: number | undefined;
    leastCount: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    eccentricityAcceptanceValue: number | undefined;
    eccentricityInstruction: string | undefined;
    linearityAcceptanceValueWg1: number | undefined;
    linearityAcceptanceValueWg2: number | undefined;
    linearityAcceptanceValueWg3: number | undefined;
    linearityAcceptanceValueWg4: number | undefined;
    linearityAcceptanceValueWg5: number | undefined;
    eccentricityAcceptanceMinValue: number | undefined;
    eccentricityAcceptanceMaxValue: number | undefined;
    repeatabilityAcceptanceMinValue: number | undefined;
    repeatabilityAcceptanceMaxValue: number | undefined;
    linearityAcceptanceMinValueWg1: number | undefined;
    linearityAcceptanceMinValueWg2: number | undefined;
    linearityAcceptanceMinValueWg3: number | undefined;
    linearityAcceptanceMinValueWg4: number | undefined;
    linearityAcceptanceMinValueWg5: number | undefined;
    linearityAcceptanceMaxValueWg1: number | undefined;
    linearityAcceptanceMaxValueWg2: number | undefined;
    linearityAcceptanceMaxValueWg3: number | undefined;
    linearityAcceptanceMaxValueWg4: number | undefined;
    linearityAcceptanceMaxValueWg5: number | undefined;
    linearityAcceptanceValue: number | undefined;
    linearityInstruction: string | undefined;
    repeatabilityAcceptanceValue: number | undefined;
    repeatabilityInstruction: string | undefined;
    uncertaintyAcceptanceValue: number | undefined;
    uncertaintyInstruction: string | undefined;
    percentageRSDValue: number | undefined;
    standardDeviationValue: number | undefined;
    meanValue: number | undefined;
    meanMinimumValue: number | undefined;
    meanMaximumValue: number | undefined;
    formula: string | undefined;
    frequencyTypeId: number | undefined;
    refrenceSOPNo: string | undefined;
    formatNo: string | undefined;
    version: string | undefined;
    description: string | undefined;
    isActive: boolean;
    calibrations: CalibrationFrequencyDto[] | undefined;
    weighingMachineTestConfigurations: WeighingMachineTestconfigurationDto[] | undefined;
}

export class WeighingMachineStampingDueOnListDto implements IWeighingMachineStampingDueOnListDto {
    weighingMachineCode: string | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;

    constructor(data?: IWeighingMachineStampingDueOnListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.stampingDoneOn = _data["stampingDoneOn"] ? moment(_data["stampingDoneOn"].toString()) : <any>undefined;
            this.stampingDueOn = _data["stampingDueOn"] ? moment(_data["stampingDueOn"].toString()) : <any>undefined;
            this.dueDays = _data["dueDays"];
            this.plantId = _data["plantId"];
            this.subPlant = _data["subPlant"];
        }
    }

    static fromJS(data: any): WeighingMachineStampingDueOnListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeighingMachineStampingDueOnListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["stampingDoneOn"] = this.stampingDoneOn ? this.stampingDoneOn.toISOString() : <any>undefined;
        data["stampingDueOn"] = this.stampingDueOn ? this.stampingDueOn.toISOString() : <any>undefined;
        data["dueDays"] = this.dueDays;
        data["plantId"] = this.plantId;
        data["subPlant"] = this.subPlant;
        return data; 
    }

    clone(): WeighingMachineStampingDueOnListDto {
        const json = this.toJSON();
        let result = new WeighingMachineStampingDueOnListDto();
        result.init(json);
        return result;
    }
}

export interface IWeighingMachineStampingDueOnListDto {
    weighingMachineCode: string | undefined;
    stampingDoneOn: moment.Moment | undefined;
    stampingDueOn: moment.Moment | undefined;
    dueDays: number;
    plantId: number | undefined;
    subPlant: string | undefined;
}

export class WeightCaptureDetailsDto implements IWeightCaptureDetailsDto {
    weightCaptureHeaderId: number | undefined;
    tenantId: number | undefined;
    scanBalanceId: number | undefined;
    grossWeightString: string | undefined;
    grossWeight: number | undefined;
    netWeightString: string | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    tareWeightString: string | undefined;
    noOfPacks: number | undefined;
    containerNo: string | undefined;
    weighingMachineCode: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    id: number;

    constructor(data?: IWeightCaptureDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weightCaptureHeaderId = _data["weightCaptureHeaderId"];
            this.tenantId = _data["tenantId"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.grossWeightString = _data["grossWeightString"];
            this.grossWeight = _data["grossWeight"];
            this.netWeightString = _data["netWeightString"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.tareWeightString = _data["tareWeightString"];
            this.noOfPacks = _data["noOfPacks"];
            this.containerNo = _data["containerNo"];
            this.weighingMachineCode = _data["weighingMachineCode"];
            this.leastCountDigitAfterDecimal = _data["leastCountDigitAfterDecimal"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightCaptureDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weightCaptureHeaderId"] = this.weightCaptureHeaderId;
        data["tenantId"] = this.tenantId;
        data["scanBalanceId"] = this.scanBalanceId;
        data["grossWeightString"] = this.grossWeightString;
        data["grossWeight"] = this.grossWeight;
        data["netWeightString"] = this.netWeightString;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["tareWeightString"] = this.tareWeightString;
        data["noOfPacks"] = this.noOfPacks;
        data["containerNo"] = this.containerNo;
        data["weighingMachineCode"] = this.weighingMachineCode;
        data["leastCountDigitAfterDecimal"] = this.leastCountDigitAfterDecimal;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightCaptureDetailsDto {
        const json = this.toJSON();
        let result = new WeightCaptureDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureDetailsDto {
    weightCaptureHeaderId: number | undefined;
    tenantId: number | undefined;
    scanBalanceId: number | undefined;
    grossWeightString: string | undefined;
    grossWeight: number | undefined;
    netWeightString: string | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    tareWeightString: string | undefined;
    noOfPacks: number | undefined;
    containerNo: string | undefined;
    weighingMachineCode: string | undefined;
    leastCountDigitAfterDecimal: number | undefined;
    id: number;
}

export class WeightCaptureDto implements IWeightCaptureDto {
    tenantId: number | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    purchaseOrderId: number;
    purchaseOrderNo: string | undefined;
    weightCaptureHeaderDetails: WeightCaptureDetailsDto[] | undefined;
    materialId: number | undefined;
    mfgBatchNoId: number | undefined;
    unitofMeasurementId: number | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    releaseDate: moment.Moment | undefined;
    weightCaptureDetailsDto: WeightCaptureDetailsDto;
    id: number;

    constructor(data?: IWeightCaptureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceNo = _data["invoiceNo"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            if (Array.isArray(_data["weightCaptureHeaderDetails"])) {
                this.weightCaptureHeaderDetails = [] as any;
                for (let item of _data["weightCaptureHeaderDetails"])
                    this.weightCaptureHeaderDetails.push(WeightCaptureDetailsDto.fromJS(item));
            }
            this.materialId = _data["materialId"];
            this.mfgBatchNoId = _data["mfgBatchNoId"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.manufacturedDate = _data["manufacturedDate"] ? moment(_data["manufacturedDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.weightCaptureDetailsDto = _data["weightCaptureDetailsDto"] ? WeightCaptureDetailsDto.fromJS(_data["weightCaptureDetailsDto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightCaptureDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNo"] = this.invoiceNo;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        if (Array.isArray(this.weightCaptureHeaderDetails)) {
            data["weightCaptureHeaderDetails"] = [];
            for (let item of this.weightCaptureHeaderDetails)
                data["weightCaptureHeaderDetails"].push(item.toJSON());
        }
        data["materialId"] = this.materialId;
        data["mfgBatchNoId"] = this.mfgBatchNoId;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["manufacturedDate"] = this.manufacturedDate ? this.manufacturedDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["weightCaptureDetailsDto"] = this.weightCaptureDetailsDto ? this.weightCaptureDetailsDto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightCaptureDto {
        const json = this.toJSON();
        let result = new WeightCaptureDto();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureDto {
    tenantId: number | undefined;
    invoiceId: number | undefined;
    invoiceNo: string | undefined;
    purchaseOrderId: number;
    purchaseOrderNo: string | undefined;
    weightCaptureHeaderDetails: WeightCaptureDetailsDto[] | undefined;
    materialId: number | undefined;
    mfgBatchNoId: number | undefined;
    unitofMeasurementId: number | undefined;
    manufacturedDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    releaseDate: moment.Moment | undefined;
    weightCaptureDetailsDto: WeightCaptureDetailsDto;
    id: number;
}

export class WeightCaptureListDto implements IWeightCaptureListDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    materialItemCode: string | undefined;
    manufacturedBatchNo: string | undefined;
    subPlantId: number | undefined;
    materialId: number | undefined;
    itemDescription: string | undefined;
    id: number;

    constructor(data?: IWeightCaptureListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.materialItemCode = _data["materialItemCode"];
            this.manufacturedBatchNo = _data["manufacturedBatchNo"];
            this.subPlantId = _data["subPlantId"];
            this.materialId = _data["materialId"];
            this.itemDescription = _data["itemDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightCaptureListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["invoiceNo"] = this.invoiceNo;
        data["materialItemCode"] = this.materialItemCode;
        data["manufacturedBatchNo"] = this.manufacturedBatchNo;
        data["subPlantId"] = this.subPlantId;
        data["materialId"] = this.materialId;
        data["itemDescription"] = this.itemDescription;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightCaptureListDto {
        const json = this.toJSON();
        let result = new WeightCaptureListDto();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureListDto {
    purchaseOrderId: number | undefined;
    purchaseOrderNo: string | undefined;
    invoiceNo: string | undefined;
    materialItemCode: string | undefined;
    manufacturedBatchNo: string | undefined;
    subPlantId: number | undefined;
    materialId: number | undefined;
    itemDescription: string | undefined;
    id: number;
}

export class WeightCaptureListDtoPagedResultDto implements IWeightCaptureListDtoPagedResultDto {
    totalCount: number;
    items: WeightCaptureListDto[] | undefined;

    constructor(data?: IWeightCaptureListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WeightCaptureListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeightCaptureListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightCaptureListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WeightCaptureListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WeightCaptureListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWeightCaptureListDtoPagedResultDto {
    totalCount: number;
    items: WeightCaptureListDto[] | undefined;
}

export class CreateWeightCaptureDto implements ICreateWeightCaptureDto {
    tenantId: number | undefined;
    invoiceId: number;
    invoiceNo: string | undefined;
    purchaseOrderId: number;
    purchaseOrderNo: string | undefined;
    weightCaptureHeaderDetails: WeightCaptureDetailsDto[] | undefined;
    materialId: number;
    mfgBatchNoId: number;
    unitOfMeasurementId: number;

    constructor(data?: ICreateWeightCaptureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceNo = _data["invoiceNo"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.purchaseOrderNo = _data["purchaseOrderNo"];
            if (Array.isArray(_data["weightCaptureHeaderDetails"])) {
                this.weightCaptureHeaderDetails = [] as any;
                for (let item of _data["weightCaptureHeaderDetails"])
                    this.weightCaptureHeaderDetails.push(WeightCaptureDetailsDto.fromJS(item));
            }
            this.materialId = _data["materialId"];
            this.mfgBatchNoId = _data["mfgBatchNoId"];
            this.unitOfMeasurementId = _data["unitOfMeasurementId"];
        }
    }

    static fromJS(data: any): CreateWeightCaptureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeightCaptureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        data["invoiceNo"] = this.invoiceNo;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        if (Array.isArray(this.weightCaptureHeaderDetails)) {
            data["weightCaptureHeaderDetails"] = [];
            for (let item of this.weightCaptureHeaderDetails)
                data["weightCaptureHeaderDetails"].push(item.toJSON());
        }
        data["materialId"] = this.materialId;
        data["mfgBatchNoId"] = this.mfgBatchNoId;
        data["unitOfMeasurementId"] = this.unitOfMeasurementId;
        return data; 
    }

    clone(): CreateWeightCaptureDto {
        const json = this.toJSON();
        let result = new CreateWeightCaptureDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeightCaptureDto {
    tenantId: number | undefined;
    invoiceId: number;
    invoiceNo: string | undefined;
    purchaseOrderId: number;
    purchaseOrderNo: string | undefined;
    weightCaptureHeaderDetails: WeightCaptureDetailsDto[] | undefined;
    materialId: number;
    mfgBatchNoId: number;
    unitOfMeasurementId: number;
}

export class WeightVerificationDto implements IWeightVerificationDto {
    productId: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    cubicalId: number | undefined;
    dispensedId: number | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    isGrossWeight: boolean;
    isSuccess: boolean;
    uom: string | undefined;
    matCode: string | undefined;
    matDesc: string | undefined;
    id: number;

    constructor(data?: IWeightVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.batchId = _data["batchId"];
            this.batchno = _data["batchno"];
            this.lotId = _data["lotId"];
            this.lotno = _data["lotno"];
            this.processOrderId = _data["processOrderId"];
            this.cubicalId = _data["cubicalId"];
            this.dispensedId = _data["dispensedId"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.noOfContainers = _data["noOfContainers"];
            this.noOfPacks = _data["noOfPacks"];
            this.recivedNoOfPacks = _data["recivedNoOfPacks"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.dispGrossWeight = _data["dispGrossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.grossWeight = _data["grossWeight"];
            this.isGrossWeight = _data["isGrossWeight"];
            this.isSuccess = _data["isSuccess"];
            this.uom = _data["uom"];
            this.matCode = _data["matCode"];
            this.matDesc = _data["matDesc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["batchId"] = this.batchId;
        data["batchno"] = this.batchno;
        data["lotId"] = this.lotId;
        data["lotno"] = this.lotno;
        data["processOrderId"] = this.processOrderId;
        data["cubicalId"] = this.cubicalId;
        data["dispensedId"] = this.dispensedId;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["noOfContainers"] = this.noOfContainers;
        data["noOfPacks"] = this.noOfPacks;
        data["recivedNoOfPacks"] = this.recivedNoOfPacks;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["dispGrossWeight"] = this.dispGrossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["grossWeight"] = this.grossWeight;
        data["isGrossWeight"] = this.isGrossWeight;
        data["isSuccess"] = this.isSuccess;
        data["uom"] = this.uom;
        data["matCode"] = this.matCode;
        data["matDesc"] = this.matDesc;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightVerificationDto {
        const json = this.toJSON();
        let result = new WeightVerificationDto();
        result.init(json);
        return result;
    }
}

export interface IWeightVerificationDto {
    productId: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    cubicalId: number | undefined;
    dispensedId: number | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    isGrossWeight: boolean;
    isSuccess: boolean;
    uom: string | undefined;
    matCode: string | undefined;
    matDesc: string | undefined;
    id: number;
}

export class CreateWeightVerificationDto implements ICreateWeightVerificationDto {
    productId: number | undefined;
    productCode: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    cubicalId: number | undefined;
    dispensedId: number | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    isGrossWeight: boolean;

    constructor(data?: ICreateWeightVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.batchId = _data["batchId"];
            this.batchno = _data["batchno"];
            this.lotId = _data["lotId"];
            this.lotno = _data["lotno"];
            this.processOrderId = _data["processOrderId"];
            this.cubicalId = _data["cubicalId"];
            this.dispensedId = _data["dispensedId"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.noOfContainers = _data["noOfContainers"];
            this.noOfPacks = _data["noOfPacks"];
            this.recivedNoOfPacks = _data["recivedNoOfPacks"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.dispGrossWeight = _data["dispGrossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.grossWeight = _data["grossWeight"];
            this.isGrossWeight = _data["isGrossWeight"];
        }
    }

    static fromJS(data: any): CreateWeightVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeightVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["batchId"] = this.batchId;
        data["batchno"] = this.batchno;
        data["lotId"] = this.lotId;
        data["lotno"] = this.lotno;
        data["processOrderId"] = this.processOrderId;
        data["cubicalId"] = this.cubicalId;
        data["dispensedId"] = this.dispensedId;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["noOfContainers"] = this.noOfContainers;
        data["noOfPacks"] = this.noOfPacks;
        data["recivedNoOfPacks"] = this.recivedNoOfPacks;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["dispGrossWeight"] = this.dispGrossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["grossWeight"] = this.grossWeight;
        data["isGrossWeight"] = this.isGrossWeight;
        return data; 
    }

    clone(): CreateWeightVerificationDto {
        const json = this.toJSON();
        let result = new CreateWeightVerificationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWeightVerificationDto {
    productId: number | undefined;
    productCode: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    cubicalId: number | undefined;
    dispensedId: number | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    isGrossWeight: boolean;
}

export class WeightVerificationListDto implements IWeightVerificationListDto {
    productId: number | undefined;
    productCode: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    processOrderno: string | undefined;
    cubicalId: number | undefined;
    cubicleno: string | undefined;
    dispensedId: number | undefined;
    dispensedno: string | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    uom: string | undefined;
    id: number;

    constructor(data?: IWeightVerificationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.batchId = _data["batchId"];
            this.batchno = _data["batchno"];
            this.lotId = _data["lotId"];
            this.lotno = _data["lotno"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderno = _data["processOrderno"];
            this.cubicalId = _data["cubicalId"];
            this.cubicleno = _data["cubicleno"];
            this.dispensedId = _data["dispensedId"];
            this.dispensedno = _data["dispensedno"];
            this.unitofMeasurementId = _data["unitofMeasurementId"];
            this.noOfContainers = _data["noOfContainers"];
            this.noOfPacks = _data["noOfPacks"];
            this.recivedNoOfPacks = _data["recivedNoOfPacks"];
            this.scanBalanceId = _data["scanBalanceId"];
            this.scanBalanceNo = _data["scanBalanceNo"];
            this.dispGrossWeight = _data["dispGrossWeight"];
            this.netWeight = _data["netWeight"];
            this.tareWeight = _data["tareWeight"];
            this.grossWeight = _data["grossWeight"];
            this.materialCode = _data["materialCode"];
            this.arNo = _data["arNo"];
            this.uom = _data["uom"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WeightVerificationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightVerificationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["batchId"] = this.batchId;
        data["batchno"] = this.batchno;
        data["lotId"] = this.lotId;
        data["lotno"] = this.lotno;
        data["processOrderId"] = this.processOrderId;
        data["processOrderno"] = this.processOrderno;
        data["cubicalId"] = this.cubicalId;
        data["cubicleno"] = this.cubicleno;
        data["dispensedId"] = this.dispensedId;
        data["dispensedno"] = this.dispensedno;
        data["unitofMeasurementId"] = this.unitofMeasurementId;
        data["noOfContainers"] = this.noOfContainers;
        data["noOfPacks"] = this.noOfPacks;
        data["recivedNoOfPacks"] = this.recivedNoOfPacks;
        data["scanBalanceId"] = this.scanBalanceId;
        data["scanBalanceNo"] = this.scanBalanceNo;
        data["dispGrossWeight"] = this.dispGrossWeight;
        data["netWeight"] = this.netWeight;
        data["tareWeight"] = this.tareWeight;
        data["grossWeight"] = this.grossWeight;
        data["materialCode"] = this.materialCode;
        data["arNo"] = this.arNo;
        data["uom"] = this.uom;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeightVerificationListDto {
        const json = this.toJSON();
        let result = new WeightVerificationListDto();
        result.init(json);
        return result;
    }
}

export interface IWeightVerificationListDto {
    productId: number | undefined;
    productCode: string | undefined;
    batchId: number | undefined;
    batchno: string | undefined;
    lotId: number | undefined;
    lotno: string | undefined;
    processOrderId: number | undefined;
    processOrderno: string | undefined;
    cubicalId: number | undefined;
    cubicleno: string | undefined;
    dispensedId: number | undefined;
    dispensedno: string | undefined;
    unitofMeasurementId: number | undefined;
    noOfContainers: number | undefined;
    noOfPacks: number | undefined;
    recivedNoOfPacks: number | undefined;
    scanBalanceId: number;
    scanBalanceNo: string | undefined;
    dispGrossWeight: number | undefined;
    netWeight: number | undefined;
    tareWeight: number | undefined;
    grossWeight: number | undefined;
    materialCode: string | undefined;
    arNo: string | undefined;
    uom: string | undefined;
    id: number;
}

export class WeightVerificationListDtoPagedResultDto implements IWeightVerificationListDtoPagedResultDto {
    totalCount: number;
    items: WeightVerificationListDto[] | undefined;

    constructor(data?: IWeightVerificationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WeightVerificationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeightVerificationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightVerificationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WeightVerificationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WeightVerificationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWeightVerificationListDtoPagedResultDto {
    totalCount: number;
    items: WeightVerificationListDto[] | undefined;
}

export class CreateWIPLineClearanceDto implements ICreateWIPLineClearanceDto {
    lineClearanceDate: moment.Moment;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleBarcode: string | undefined;
    equipmentBarcodeId: number;
    equipmentBarcode: string | undefined;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifierBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    canApproved: boolean;
    checklistTypeId: number | undefined;
    remarks: string | undefined;
    id: number;

    constructor(data?: ICreateWIPLineClearanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineClearanceDate = _data["lineClearanceDate"] ? moment(_data["lineClearanceDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.equipmentBarcodeId = _data["equipmentBarcodeId"];
            this.equipmentBarcode = _data["equipmentBarcode"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.approvedBy = _data["approvedBy"];
            this.verifierBy = _data["verifierBy"];
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isVerified = _data["isVerified"];
            this.canApproved = _data["canApproved"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.remarks = _data["remarks"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateWIPLineClearanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWIPLineClearanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineClearanceDate"] = this.lineClearanceDate ? this.lineClearanceDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["equipmentBarcodeId"] = this.equipmentBarcodeId;
        data["equipmentBarcode"] = this.equipmentBarcode;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["verifierBy"] = this.verifierBy;
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        data["isVerified"] = this.isVerified;
        data["canApproved"] = this.canApproved;
        data["checklistTypeId"] = this.checklistTypeId;
        data["remarks"] = this.remarks;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateWIPLineClearanceDto {
        const json = this.toJSON();
        let result = new CreateWIPLineClearanceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWIPLineClearanceDto {
    lineClearanceDate: moment.Moment;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleBarcode: string | undefined;
    equipmentBarcodeId: number;
    equipmentBarcode: string | undefined;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifierBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    canApproved: boolean;
    checklistTypeId: number | undefined;
    remarks: string | undefined;
    id: number;
}

export class WIPLineClearanceTransactionDto implements IWIPLineClearanceTransactionDto {
    clearanceDate: moment.Moment;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleBarcode: string | undefined;
    equipmentBarcodeId: number;
    equipmentBarcode: string | undefined;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    isApproved: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    batchNo: string | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    remarks: string | undefined;
    id: number;

    constructor(data?: IWIPLineClearanceTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clearanceDate = _data["clearanceDate"] ? moment(_data["clearanceDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.processOrderId = _data["processOrderId"];
            this.processOrderNo = _data["processOrderNo"];
            this.cubicleBarcodeId = _data["cubicleBarcodeId"];
            this.cubicleBarcode = _data["cubicleBarcode"];
            this.equipmentBarcodeId = _data["equipmentBarcodeId"];
            this.equipmentBarcode = _data["equipmentBarcode"];
            this.statusId = _data["statusId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.stopTime = _data["stopTime"] ? moment(_data["stopTime"].toString()) : <any>undefined;
            this.approvedTime = _data["approvedTime"] ? moment(_data["approvedTime"].toString()) : <any>undefined;
            this.approvedBy = _data["approvedBy"];
            this.verifiedBy = _data["verifiedBy"];
            if (Array.isArray(_data["lineClearanceCheckpoints"])) {
                this.lineClearanceCheckpoints = [] as any;
                for (let item of _data["lineClearanceCheckpoints"])
                    this.lineClearanceCheckpoints.push(CheckpointDto.fromJS(item));
            }
            this.isVerified = _data["isVerified"];
            this.isApproved = _data["isApproved"];
            this.canApproved = _data["canApproved"];
            this.canVerified = _data["canVerified"];
            this.approvedByName = _data["approvedByName"];
            this.creatorName = _data["creatorName"];
            this.isInValidTransaction = _data["isInValidTransaction"];
            this.batchNo = _data["batchNo"];
            this.checklistTypeId = _data["checklistTypeId"];
            this.inspectionChecklistId = _data["inspectionChecklistId"];
            this.remarks = _data["remarks"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WIPLineClearanceTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WIPLineClearanceTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearanceDate"] = this.clearanceDate ? this.clearanceDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["processOrderId"] = this.processOrderId;
        data["processOrderNo"] = this.processOrderNo;
        data["cubicleBarcodeId"] = this.cubicleBarcodeId;
        data["cubicleBarcode"] = this.cubicleBarcode;
        data["equipmentBarcodeId"] = this.equipmentBarcodeId;
        data["equipmentBarcode"] = this.equipmentBarcode;
        data["statusId"] = this.statusId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["stopTime"] = this.stopTime ? this.stopTime.toISOString() : <any>undefined;
        data["approvedTime"] = this.approvedTime ? this.approvedTime.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["verifiedBy"] = this.verifiedBy;
        if (Array.isArray(this.lineClearanceCheckpoints)) {
            data["lineClearanceCheckpoints"] = [];
            for (let item of this.lineClearanceCheckpoints)
                data["lineClearanceCheckpoints"].push(item.toJSON());
        }
        data["isVerified"] = this.isVerified;
        data["isApproved"] = this.isApproved;
        data["canApproved"] = this.canApproved;
        data["canVerified"] = this.canVerified;
        data["approvedByName"] = this.approvedByName;
        data["creatorName"] = this.creatorName;
        data["isInValidTransaction"] = this.isInValidTransaction;
        data["batchNo"] = this.batchNo;
        data["checklistTypeId"] = this.checklistTypeId;
        data["inspectionChecklistId"] = this.inspectionChecklistId;
        data["remarks"] = this.remarks;
        data["id"] = this.id;
        return data; 
    }

    clone(): WIPLineClearanceTransactionDto {
        const json = this.toJSON();
        let result = new WIPLineClearanceTransactionDto();
        result.init(json);
        return result;
    }
}

export interface IWIPLineClearanceTransactionDto {
    clearanceDate: moment.Moment;
    productId: number | undefined;
    productCode: string | undefined;
    processOrderId: number | undefined;
    processOrderNo: string | undefined;
    cubicleBarcodeId: number;
    cubicleBarcode: string | undefined;
    equipmentBarcodeId: number;
    equipmentBarcode: string | undefined;
    statusId: number;
    startTime: moment.Moment;
    stopTime: moment.Moment | undefined;
    approvedTime: moment.Moment | undefined;
    approvedBy: number | undefined;
    verifiedBy: number | undefined;
    lineClearanceCheckpoints: CheckpointDto[] | undefined;
    isVerified: boolean;
    isApproved: boolean;
    canApproved: boolean;
    canVerified: boolean;
    approvedByName: string | undefined;
    creatorName: string | undefined;
    isInValidTransaction: boolean;
    batchNo: string | undefined;
    checklistTypeId: number | undefined;
    inspectionChecklistId: number | undefined;
    remarks: string | undefined;
    id: number;
}

export class CreateWipPickingDto implements ICreateWipPickingDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;

    constructor(data?: ICreateWipPickingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.productId = _data["productId"];
            this.stage = _data["stage"];
            this.suggestedLocationId = _data["suggestedLocationId"];
            this.locationId = _data["locationId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.batch = _data["batch"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): CreateWipPickingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWipPickingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["productId"] = this.productId;
        data["stage"] = this.stage;
        data["suggestedLocationId"] = this.suggestedLocationId;
        data["locationId"] = this.locationId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["batch"] = this.batch;
        data["productName"] = this.productName;
        return data; 
    }

    clone(): CreateWipPickingDto {
        const json = this.toJSON();
        let result = new CreateWipPickingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWipPickingDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;
}

export class WipPickingDto implements IWipPickingDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    processOrderNo: string | undefined;
    processOrder: string | undefined;
    id: number;

    constructor(data?: IWipPickingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.productId = _data["productId"];
            this.stage = _data["stage"];
            this.suggestedLocationId = _data["suggestedLocationId"];
            this.locationId = _data["locationId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.batch = _data["batch"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.processOrderNo = _data["processOrderNo"];
            this.processOrder = _data["processOrder"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WipPickingDto {
        data = typeof data === 'object' ? data : {};
        let result = new WipPickingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["productId"] = this.productId;
        data["stage"] = this.stage;
        data["suggestedLocationId"] = this.suggestedLocationId;
        data["locationId"] = this.locationId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["batch"] = this.batch;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["processOrderNo"] = this.processOrderNo;
        data["processOrder"] = this.processOrder;
        data["id"] = this.id;
        return data; 
    }

    clone(): WipPickingDto {
        const json = this.toJSON();
        let result = new WipPickingDto();
        result.init(json);
        return result;
    }
}

export interface IWipPickingDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    processOrderNo: string | undefined;
    processOrder: string | undefined;
    id: number;
}

export class WipPickingListDto implements IWipPickingListDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    processOrder: string | undefined;
    productCode: string | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IWipPickingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processOrderId = _data["processOrderId"];
            this.productId = _data["productId"];
            this.processOrder = _data["processOrder"];
            this.productCode = _data["productCode"];
            this.stage = _data["stage"];
            this.suggestedLocationId = _data["suggestedLocationId"];
            this.locationId = _data["locationId"];
            this.containerId = _data["containerId"];
            this.containerCode = _data["containerCode"];
            this.containerCount = _data["containerCount"];
            this.quantity = _data["quantity"];
            this.batch = _data["batch"];
            this.productName = _data["productName"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WipPickingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WipPickingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processOrderId"] = this.processOrderId;
        data["productId"] = this.productId;
        data["processOrder"] = this.processOrder;
        data["productCode"] = this.productCode;
        data["stage"] = this.stage;
        data["suggestedLocationId"] = this.suggestedLocationId;
        data["locationId"] = this.locationId;
        data["containerId"] = this.containerId;
        data["containerCode"] = this.containerCode;
        data["containerCount"] = this.containerCount;
        data["quantity"] = this.quantity;
        data["batch"] = this.batch;
        data["productName"] = this.productName;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): WipPickingListDto {
        const json = this.toJSON();
        let result = new WipPickingListDto();
        result.init(json);
        return result;
    }
}

export interface IWipPickingListDto {
    processOrderId: number | undefined;
    productId: number | undefined;
    processOrder: string | undefined;
    productCode: string | undefined;
    stage: string | undefined;
    suggestedLocationId: number | undefined;
    locationId: number | undefined;
    containerId: number | undefined;
    containerCode: string | undefined;
    containerCount: number | undefined;
    quantity: number;
    batch: string | undefined;
    productName: string | undefined;
    isActive: boolean;
    id: number;
}

export class WipPickingListDtoPagedResultDto implements IWipPickingListDtoPagedResultDto {
    totalCount: number;
    items: WipPickingListDto[] | undefined;

    constructor(data?: IWipPickingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WipPickingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WipPickingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WipPickingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WipPickingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WipPickingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWipPickingListDtoPagedResultDto {
    totalCount: number;
    items: WipPickingListDto[] | undefined;
}

export class ZDto implements IZDto {
    zField: string | undefined;
    descriptionField: string | undefined;
    id: number;

    constructor(data?: IZDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zField = _data["zField"];
            this.descriptionField = _data["descriptionField"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ZDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zField"] = this.zField;
        data["descriptionField"] = this.descriptionField;
        data["id"] = this.id;
        return data; 
    }

    clone(): ZDto {
        const json = this.toJSON();
        let result = new ZDto();
        result.init(json);
        return result;
    }
}

export interface IZDto {
    zField: string | undefined;
    descriptionField: string | undefined;
    id: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}